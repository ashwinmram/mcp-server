{
    "meta": {
        "title": "AI Testing Patterns - Laravel Application",
        "version": "1.4",
        "last_updated": "2026-01-06",
        "description": "Comprehensive testing patterns and best practices",
        "related_docs": [
            "docs/AI_LESSONS_LEARNED.json - Consolidated lessons from 20+ development sessions",
            "docs/AI_TESTING_QUICK_REFERENCE.json - Quick reference for common testing scenarios"
        ]
    },
    "backend_patterns": {
        "feature_test_structure": {
            "imports": [
                "use Tests\\TestCase",
                "use Illuminate\\Foundation\\Testing\\RefreshDatabase"
            ],
            "traits": ["RefreshDatabase"],
            "naming": "test_descriptive_action_expected_result",
            "structure": "Arrange (create data) \u2192 Act (make request) \u2192 Assert (verify response/database)",
            "common_assertions": {
                "status": "assertStatus(200)",
                "database": "assertDatabaseHas('table', ['column' => 'value'])",
                "inertia": "assertInertia(fn($page) => $page->has('prop'))",
                "redirect": "assertRedirect('/path')",
                "session": "assertSessionHas('flash.banner', 'message')",
                "inertia_partial": "assertInertia(fn($page) => $page->has('prop')->where('prop.key', 'value'))",
                "inertia_component": "assertInertia(fn($page) => $page->component('ComponentName'))"
            }
        },
        "tdd_workflow": {
            "red": "Write failing test first",
            "green": "Write minimal code to pass",
            "refactor": "Improve while keeping tests green",
            "never_skip_red": "Tests MUST fail before implementation"
        },
        "common_setup": {
            "database": "use RefreshDatabase",
            "auth": "actingAs($user)",
            "csrf": "withoutMiddleware(VerifyCsrfToken::class)",
            "session": "startSessionForAuth()"
        },
        "phpunit_attributes": {
            "modern_syntax": "#[\\PHPUnit\\Framework\\Attributes\\Test]",
            "example": "#[\\PHPUnit\\Framework\\Attributes\\Test]\\npublic function admin_can_view_action_page()",
            "migration": "Use #[\\PHPUnit\\Framework\\Attributes\\Test] for all test methods"
        },
        "query_parameter_testing": {
            "description": "Proper handling of query parameters in Laravel route tests",
            "correct_pattern": {
                "http_build_query": "Use http_build_query() to build query string manually: route('route.name', $param) . '?' . http_build_query(['key' => 'value'])",
                "get_request": "Use $this->get($url) with manually built query string instead of passing array",
                "example": "$url = route('action.show', $user) . '?' . http_build_query(['entity_id' => $id, 'expires_at' => $date]); $response = $this->get($url);"
            },
            "incorrect_pattern": {
                "array_parameter": "Passing array as second parameter to $this->get() may not work correctly for query parameters",
                "example": "$this->get(route('action.show', $user), ['entity_id' => $id]) may fail validation"
            },
            "benefits": [
                "Reliable query parameter passing in tests",
                "Consistent behavior with actual URL generation",
                "Proper parameter validation in controller tests",
                "Easier debugging with explicit query strings"
            ]
        },
        "filesystem_testing": {
            "description": "Testing file operations using Laravel Storage facade instead of real files",
            "correct_pattern": {
                "setup": "Storage::fake('public') in setUp() method",
                "service_instantiation": "new ImageUploadService('public') for tests",
                "assertions": "Storage::disk('public')->assertExists() and assertMissing()",
                "no_cleanup": "Storage::fake() automatically handles cleanup"
            },
            "incorrect_pattern": {
                "real_files": "Using real file operations in tests",
                "manual_cleanup": "File::deleteDirectory() in tearDown()",
                "asset_assertions": "assertStringContainsString('/images/...')",
                "hardcoded_paths": "public_path('images/...') in tests"
            },
            "test_examples": {
                "filename_preservation": "Test that original filenames are preserved",
                "conflict_handling": "Test filename conflicts with number suffixes",
                "sanitization": "Test special character removal and sanitization",
                "url_generation": "Test URL generation with Storage::disk()->url()"
            },
            "assertion_patterns": {
                "file_exists": "Storage::disk('public')->assertExists('logos/company-logo.png')",
                "file_missing": "Storage::disk('public')->assertMissing('logos/old-logo.png')",
                "url_generation": "assertStringContainsString('/storage/', $url)",
                "filename_preservation": "assertEquals('logos/company-logo.png', $result)"
            }
        },
        "mail_logo_embedding": {
            "description": "Validating CID logo embedding in expiry reminder mailables",
            "test_strategy": {
                "preview_route": "Return new EntityExpiryReminderMail($tenantName, $summary, $features, $user) from a debug route to visually inspect CID rendering in the browser before sending real emails.",
                "symfony_message_inspection": "Use Mail::fake(); Mail::assertSent(EntityExpiryReminderMail::class, function ($mail) { $mail->build(); $message = $mail->withSymfonyMessage(fn($m) => $m); return str_contains($message->getHtmlBody(), 'cid:tenant-logo'); });",
                "storage_fakes": "When logos live on local/public disks, wrap tests with Storage::fake('public') and seed a logo file so embedFromPath succeeds without touching real files.",
                "remote_disk_guard": "For R2/S3 disks, prefer integration smoke tests that dispatch the command in a staging environment because temporary file streaming uses actual credentials."
            },
            "fallback_assertions": {
                "absolute_url": "Assert Tenant::getLogoUrlForEmail() returns an https:// URL so Blade fallback has a valid source when CID embedding is skipped.",
                "view_logic": "Assert rendered markdown contains either cid: or https:// to guarantee at least one path renders the logo."
            }
        },
        "environment_flag_requirements": {
            "description": "ALWAYS use APP_ENV=testing when running tests to ensure proper database isolation",
            "implementation": {
                "test_commands": "APP_ENV=testing php artisan test",
                "specific_tests": "APP_ENV=testing php artisan test --filter=test_method_name",
                "coverage_tests": "APP_ENV=testing php artisan test --coverage",
                "never_without_flag": "Never run tests without APP_ENV=testing flag"
            },
            "database_isolation": {
                "development_database": "loyalty (from .env file)",
                "testing_database": "loyalty_dusk (from phpunit.xml)",
                "automatic_switching": "Laravel automatically switches databases based on APP_ENV"
            },
            "benefits": [
                "Prevents accidental data corruption between environments",
                "Ensures tests use correct database schema",
                "Maintains proper database isolation",
                "Prevents production database accidents"
            ]
        },
        "frontend_test_warning_resolution": {
            "description": "Systematic approach to resolving Vue warnings in frontend tests",
            "common_warnings": {
                "missing_required_props": "Components with required props not receiving them in tests",
                "undefined_properties": "Accessing undefined properties in component templates",
                "prop_validation_errors": "Vue prop validation warnings in test environments"
            },
            "resolution_workflow": {
                "identify_warnings": "Run tests and identify all Vue warnings in output",
                "trace_to_source": "Trace warnings to specific components and prop usage",
                "check_real_usage": "Verify how components are used in actual application",
                "fix_source_bugs": "Fix actual component bugs before test workarounds",
                "update_test_stubs": "Improve test stubs with proper prop definitions",
                "verify_resolution": "Re-run tests to confirm warnings are eliminated"
            },
            "test_stub_optimization": {
                "prop_definitions": "Include all props that the real component expects",
                "template_simplification": "Use simple templates that don't trigger complex logic",
                "data_testid_usage": "Add data-testid attributes for better test targeting",
                "example": "ProfilePhoneOtp: { template: '<div data-testid=\"profile-phone-otp\"></div>', props: ['phoneNumber', 'disabled', 'profileData'] }"
            },
            "prevention_strategies": {
                "component_documentation": "Document all required props clearly",
                "prop_validation": "Use TypeScript or prop validation for better error catching",
                "test_coverage": "Test components with all required props"
            }
        },
        "component_refactoring_props_to_usepage": {
            "description": "Updating tests when refactoring components from props to usePage()",
            "problem": "When components are refactored to read data from usePage() instead of props, tests may pass props that are no longer accepted, causing Vue warnings about extraneous non-props attributes",
            "warning_example": "[Vue warn]: Extraneous non-props attributes (tenant) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes",
            "solution": {
                "extract_prop_from_test": "In test setup, extract the prop from test props object before passing to component",
                "update_mock_page_props": "Update mockPageProps instead of passing prop to component mount",
                "remove_from_component_props": "Remove the prop from the props object passed to component mount"
            },
            "implementation_pattern": {
                "before": "getMountOptions: (props = {}) => { return { props: { ...props, memberCount: 0 } }; }",
                "after": "getMountOptions: (props = {}) => { const { tenant, ...componentProps } = props; if (tenant !== undefined) { mockPageProps.tenant = tenant; } return { props: { ...componentProps, memberCount: 0 } }; }",
                "explanation": "Extract tenant from props, update mockPageProps.tenant, and only pass remaining componentProps to component"
            },
            "test_example": {
                "setup": "const mockPageProps = { tenant: null }; vi.mock('@inertiajs/vue3', () => ({ usePage: vi.fn(() => ({ props: mockPageProps })) }));",
                "test_helper": "const getMountOptions = (props = {}) => { const { tenant, ...componentProps } = props; if (tenant !== undefined) { mockPageProps.tenant = tenant; } return { props: { ...componentProps } }; };",
                "usage": "wrapper = mount(SystemActivation, getMountOptions({ tenant: { is_active: true } }));"
            },
            "benefits": [
                "Eliminates Vue warnings about extraneous props",
                "Tests correctly reflect component's actual data source (usePage() instead of props)",
                "More accurate test coverage of component behavior",
                "Cleaner test output without warnings"
            ],
            "common_scenarios": [
                "Refactoring components to use global shared data from HandleInertiaRequests",
                "Moving from prop-based data passing to Inertia shared props",
                "Consolidating data access patterns across components"
            ],
            "prevention": "When refactoring components from props to usePage(), always update tests to remove props from component mount and update mockPageProps instead"
        },
        "paginator_assertions": {
            "description": "Consistent backend assertions when routes return LengthAwarePaginator props to Inertia views",
            "common_props": [
                "items.current_page",
                "items.per_page",
                "items.total",
                "items.data"
            ],
            "assertion_patterns": {
                "metadata": "$response->assertInertia(fn (Assert $page) => $page->where('items.per_page', 5)->where('items.total', 12));",
                "data_length": "$response->assertInertia(fn (Assert $page) => $page->has('items.data', 5));",
                "ordering": "$response->assertInertia(fn (Assert $page) => $page->where('items.data.0.id', $orderedItems[0]->id));",
                "stats_presence": "$response->assertInertia(fn (Assert $page) => $page->has('actionStats')->has('userStats'));"
            },
            "query_parameters": {
                "preservation": "When asserting pagination with filters (e.g., active=true), verify paginator path and query via ->where('items.path', url('/users/'.$user->id.'/items'));",
                "manual_paginators": "For filtered in-memory collections, ensure LengthAwarePaginator receives ['path' => $request->url(), 'query' => $request->query()] so links remain accurate"
            },
            "regression_tests": [
                "DashboardAllCardsPaginationTest.php",
                "FeatureIconActiveFilterTest.php",
                "MultipleFeaturesModalDisplayBugTest.php"
            ],
            "benefits": [
                "Prevents regressions when pagination defaults change",
                "Ensures dashboard stats remain available on paginated routes",
                "Encourages explicit assertions on paginator metadata"
            ]
        },
        "inertia_first_architecture": {
            "core_principles": {
                "all_operations_inertia": "Use Inertia for ALL operations - page navigation AND data operations",
                "no_fetch_axios": "NEVER use fetch() or axios for Inertia routes - use Inertia router methods",
                "api_routes_exception": "Use dedicated API routes with JsonResource for data operations when needed",
                "minimize_shared_props": "Only essential data in HandleInertiaRequests",
                "optimization_only": "Use smart partial reloads and lazy evaluation only when performance issues are identified"
            },
            "frontend_patterns": {
                "data_operations": "router.post('/items/123/increment', {}, { preserveState: true })",
                "page_navigation": "router.visit('/dashboard')",
                "form_submissions": "Use Inertia Form component or router methods",
                "loading_states": "Use Inertia's built-in loading indicators"
            },
            "backend_patterns": {
                "flash_messages": "session()->flash('flash.banner', 'Success message')",
                "redirects": "return redirect()->back()->with('flash.banner', 'Success')",
                "inertia_responses": "return Inertia::render('Component', ['data' => $data])"
            },
            "optimization_patterns": {
                "smart_partial_reloads": "router.post('/items/123/update', {}, { only: ['item', 'dashboardMetrics'] }) - Use only when performance issues exist",
                "lazy_evaluation": "return Inertia::render('Dashboard', ['item' => fn() => $item->fresh()]) - Use only when performance issues exist"
            },
            "testing_patterns": {
                "all_routes_inertia": "Use post() and assertInertia() or assertRedirect()",
                "partial_reloads": "assertInertia(fn($page) => $page->has('prop')->where('prop.key', 'value'))",
                "flash_messages": "assertSessionHas('flash.banner', 'Success message')",
                "never_postjson": "All routes are Inertia routes - never use postJson()"
            }
        },
        "jsonresource_api_architecture": {
            "dual_route_approach": {
                "api_routes": "Use /api/* routes for data operations with JsonResource responses",
                "web_routes": "Use web routes for page navigation with Inertia responses",
                "separation": "Keep API and web routes separate for different use cases",
                "backward_compatibility": "Maintain web routes for existing Inertia components"
            },
            "controller_patterns": {
                "api_methods": "Create separate API methods that return JsonResource responses",
                "web_methods": "Create separate web methods that return RedirectResponse",
                "same_controller": "Both API and web methods can exist in same controller",
                "session_consistency": "Both architectures use same session storage for state"
            },
            "jsonresource_classes": {
                "purpose": "Standardize API response format across all endpoints",
                "structure": "All responses wrapped in 'data' property",
                "examples": "SmsSendResource, SmsVerifyResource, PhoneExistsResource",
                "benefits": "Consistent response structure, better error handling, reusable"
            },
            "frontend_conversion": {
                "inertia_to_fetch": "Convert components from Inertia router to fetch API",
                "csrf_handling": "Manual CSRF token retrieval and header inclusion",
                "error_handling": "Implement try/catch blocks for network errors",
                "response_parsing": "Parse JsonResource structure: data.data.success"
            },
            "testing_patterns": {
                "api_route_testing": "Use postJson() with assertStatus() and assertJson()",
                "web_route_testing": "Use post() with assertRedirect() and assertSessionHas()",
                "frontend_mocking": "Mock global.fetch for API calls in component tests",
                "dual_architecture": "Test both API and web routes separately"
            }
        }
    },
    "ordering_patterns": {
        "deterministic_ordering": "When asserting order, set explicit ORDER BY with secondary tie-breakers (e.g., created_at DESC, id DESC)",
        "brittleness_avoidance": "If order is not business-critical, assert presence rather than position"
    },
    "frontend_patterns": {
        "vue_test_structure": {
            "imports": [
                "describe",
                "test",
                "expect",
                "vi",
                "beforeEach",
                "mount",
                "flushPromises"
            ],
            "mounting": "Use data-testid for selectors",
            "async": "Use flushPromises() for async operations",
            "mocking": "Mock Inertia.js completely",
            "approach": "Test behavior, not implementation"
        },
        "vitest_hoisted_pattern": {
            "description": "CRITICAL: Use vi.hoisted() to define mocks that can be accessed in both mock factory and test suite",
            "problem": "ReferenceError: Cannot access 'mockPage' before initialization when mocks are referenced in vi.mock() factory",
            "solution": {
                "pattern": "const { mockPage, mockRouter, mockForm } = vi.hoisted(() => ({ mockPage: { props: {...} }, mockRouter: { post: vi.fn() }, mockForm: { errors: {}, ... } }));",
                "why": "vi.hoisted() runs before vi.mock() factory, allowing mocks to be defined and then referenced",
                "when_to_use": "Always use vi.hoisted() when creating mocks that are referenced in vi.mock() factory functions"
            },
            "example": {
                "setup": "const { mockPage } = vi.hoisted(() => ({ mockPage: { props: { auth: { user: {...} } } } }));",
                "mock_factory": "vi.mock('@inertiajs/vue3', () => ({ usePage: vi.fn(() => ({ props: mockPage.props })) }));",
                "test_usage": "Can access mockPage in tests to update props: mockPage.props.auth.user = { id: 1 };"
            },
            "benefits": [
                "Prevents 'Cannot access before initialization' errors",
                "Allows mocks to be updated in tests",
                "Cleaner separation between mock definition and usage"
            ]
        },
        "inertia_mocking": {
            "complete_mock": {
                "usePage": "Returns props with auth, brand, tenant, jetstream",
                "router": "Mock post, put, delete, reload, get, flushAll methods",
                "useForm": "Mock processing, errors, data properties - CRITICAL: Include errors object structure",
                "Head": "CRITICAL: Always include Head component: { name: 'Head', template: '<div><slot /></div>' }",
                "Link": "CRITICAL: Always include Link component: { name: 'Link', props: ['href'], template: '<a :href=\"href\"><slot /></a>' }",
                "Form": "CRITICAL: Always include Form component when used: { name: 'Form', template: '<form><slot v-bind=\"{ errors: {}, processing: false }\" /></form>' }"
            },
            "global_properties": {
                "route": "Mock route function with current method",
                "csrf": "document.head.innerHTML = '<meta name=\"csrf-token\" content=\"test-token\">'",
                "fetch": "CRITICAL: Mock global.fetch for components making API calls - prevents 'Cannot read properties of undefined' errors"
            },
            "form_errors_structure": {
                "description": "CRITICAL: Form mocks must include errors object with all form fields",
                "pattern": "mockForm: { processing: false, errors: { name: undefined, email: undefined, password: undefined }, data: {}, post: vi.fn(), clearErrors: vi.fn() }",
                "why": "Components access form.errors.fieldName - undefined errors object causes TypeError",
                "when_to_use": "Always include errors object in form mocks, initialize all form fields to undefined"
            }
        },
        "composable_mocking": {
            "description": "Mock composables in ALL test files that use components importing them",
            "useTranslations": {
                "pattern": "vi.mock('@/composables/useTranslations', () => ({ useTranslations: () => ({ t: (key: string) => key, locale: { value: 'en' } }) }));",
                "when_to_use": "All components using translations"
            },
            "useInitials": {
                "pattern": "vi.mock('@/composables/useInitials', () => ({ useInitials: () => ({ getInitials: (name: string) => name.charAt(0).toUpperCase() }), getInitials: (name: string) => name.charAt(0).toUpperCase() }));",
                "when_to_use": "Components using UserInfo or getInitials function"
            },
            "useAppearance": {
                "pattern": "vi.mock('@/composables/useAppearance', () => ({ useAppearance: () => ({ appearance: ref('light'), updateAppearance: vi.fn() }) }));",
                "when_to_use": "Components using appearance composable",
                "note": "Must import ref from vue when using ref() in mock"
            }
        },
        "context_provider_mocking": {
            "description": "Components using inject() need context providers wrapped in test",
            "sidebar_provider": {
                "pattern": "Wrap component in SidebarProvider using global.components: { components: { SidebarProvider, Sidebar, ComponentName }, template: '<SidebarProvider><Sidebar><ComponentName /></Sidebar></SidebarProvider>' }",
                "error": "Injection Symbol(SidebarContext) not found. Component must be used within Sidebar",
                "when_to_use": "Components using Sidebar, SidebarTrigger, SidebarMenu, SidebarMenuButton",
                "example_components": [
                    "AppSidebar",
                    "AppSidebarHeader",
                    "NavUser",
                    "NavMain",
                    "NavFooter"
                ]
            },
            "dropdown_menu": {
                "pattern": "Wrap component in DropdownMenu using global.components: { components: { DropdownMenu, DropdownMenuContent, ComponentName }, template: '<DropdownMenu><DropdownMenuContent><ComponentName /></DropdownMenuContent></DropdownMenu>' }",
                "error": "Injection Symbol(MenuRootContext) not found. Component must be used within MenuRoot",
                "when_to_use": "Components using DropdownMenuLabel, DropdownMenuItem, DropdownMenuSeparator",
                "example_components": ["UserMenuContent"]
            }
        },
        "v_show_testing": {
            "description": "CRITICAL: v-show hides element but keeps in DOM - use isVisible() not exists()",
            "problem": "v-show sets display: none, element still exists in DOM, causing assertion failures",
            "solution": {
                "correct": "expect(wrapper.find('div').isVisible()).toBe(false);",
                "incorrect": "expect(wrapper.find('div').exists()).toBe(false); // Wrong - element exists in DOM",
                "alternative": "Check for empty text content: expect(wrapper.find('div').text()).toBe('');"
            },
            "when_to_use": "When testing components using v-show directive for conditional rendering",
            "example": "InputError component uses v-show - test with isVisible() not exists()"
        },
        "fetch_api_mocking": {
            "description": "CRITICAL: Mock global.fetch for components making API calls",
            "when_needed": "Components that call fetch() API (auth pages fetching businesses)",
            "pattern": {
                "setup": "global.fetch = vi.fn();",
                "mock_response": "global.fetch.mockResolvedValue({ ok: true, json: () => Promise.resolve({ data: [] }) });",
                "cleanup": "vi.restoreAllMocks() in afterEach"
            },
            "error_prevention": "Prevents 'Cannot read properties of undefined (reading ok)' errors when response is undefined",
            "example_pages": ["ForgotPassword", "Login", "ResetPassword"]
        },
        "page_prop_structure": {
            "description": "CRITICAL: Page components need proper prop structures matching component expectations",
            "users_index": {
                "pattern": "mockPage.props.users = { data: [...], current_page: 1, last_page: 1, per_page: 15, total: 0 };",
                "why": "Components access users.length - missing data array causes TypeError"
            },
            "users_show": {
                "pattern": "mockPage.props.user = { id: 1, name: 'Test', email: 'test@example.com', role: 'admin', status: 'active' };",
                "why": "Components access user.name, user.currency_code, etc. - missing properties cause TypeError"
            },
            "business_settings": {
                "pattern": "mockPage.props.business = { id: 1, name: 'Test Business', currency_code: 'INR' };",
                "why": "Components access business.name, business.currency_code - missing properties cause TypeError"
            }
        },
        "common_selectors": {
            "data_testid": "wrapper.find('[data-testid=\"element\"]')",
            "button": "wrapper.find('button[title*=\"text\"]')",
            "component": "wrapper.findComponent({ name: 'ComponentName' })",
            "class": "wrapper.find('.class-name')"
        },
        "pagination_component_testing": {
            "fixtures": "Mock paginator objects with data arrays: { data: [...], current_page: 1, per_page: 5, total: 10 }",
            "router_expectations": "Expect router.get to preserve pathname (`/dashboard/all-cards`) and merge existing query params when page changes",
            "partial_reload": "Assert router.get options include preserveState: true, preserveScroll: true, only: ['items'], replace: true",
            "index_offset": "Verify components compute cardIndexOffset using (current_page - 1) * per_page for numbering assertions"
        },
        "server_validation_testing": {
            "jetstream_flash_mock": "Mock page.props.jetstream.flash with banner and bannerStyle properties",
            "router_post_mock": "Mock router.post and simulate Inertia response with jetstream flash structure",
            "visual_feedback_assertions": "Assert on CSS classes: expect(input.classes()).toContain('border-green-300')",
            "validation_mode_testing": "Test that server-only mode triggers validation, client mode does not",
            "flash_message_structure": "page.props.jetstream.flash = { banner: 'Message', bannerStyle: 'success' or 'danger' }",
            "controller_responses": "Use back() helper function, NOT Inertia::back() which doesn't exist",
            "flash_location": "Controller sets session()->flash('flash.banner'), component reads page.props.jetstream.flash"
        },
        "index_agnostic_assertions": {
            "principle": "Avoid brittle array index assertions; locate items by stable keys (id, email) or properties (is_completed, quantity)",
            "when_to_use": "Use when order is not guaranteed or multiple sources affect sorting. CRITICAL: When collections are ordered by created_at DESC, the newest item is first, not the oldest",
            "desc_ordering_gotcha": "Tests assuming first item in DESC-ordered collection matches expected state will fail - newest item (first) may have different state than expected",
            "solution": "Use firstWhere() to find items by their properties rather than assuming array position",
            "example": "where('users', fn(u) => collect(u).firstWhere('id', $user->id)['has_available_feature'] === true)",
            "desc_ordering_example": "const incompleteItem = $items->firstWhere('is_completed', false); const completedItem = $items->firstWhere('is_completed', true);"
        },
        "complex_component_testing": {
            "description": "Testing patterns for complex components with dialogs, forms, and conditional logic",
            "useForm_mock_with_initial_values": {
                "description": "Mock useForm to handle initial values from props correctly",
                "pattern": "useForm: vi.fn((initial = {}) => { Object.assign(mockForm, initial); return mockForm; })",
                "example": "Component calls useForm({ active: props.tenant?.active ?? false })",
                "why": "Components initialize forms with prop values, so mock must merge initial values into shared mockForm object",
                "benefits": [
                    "Component can read initial values",
                    "Component can update form properties",
                    "Tests can verify form state changes"
                ]
            },
            "direct_method_calls": {
                "description": "Directly call component methods instead of triggering events for more reliable testing",
                "pattern": "wrapper.vm.methodName() instead of wrapper.find('[data-testid=\"button\"]').trigger('click')",
                "when_to_use": [
                    "Complex event handlers",
                    "Conditional logic that might prevent events",
                    "More reliable test execution"
                ],
                "example": "wrapper.vm.toggleActiveStatus() instead of toggle.trigger('change')",
                "benefits": [
                    "More reliable",
                    "Easier to debug",
                    "Can verify internal state directly"
                ]
            },
            "dialog_testing": {
                "description": "Testing patterns for dialog components with conditional rendering",
                "state_and_rendering": {
                    "description": "Test both internal state and rendered component",
                    "pattern": "expect(wrapper.vm.showDialog).toBe(true) AND expect(wrapper.find('[data-testid=\"dialog\"]').exists()).toBe(true)",
                    "why": "Dialogs are conditionally rendered with v-if, so need to test both state and rendering"
                },
                "dialog_interactions": {
                    "description": "Test dialog close/confirm events",
                    "pattern": "const dialog = wrapper.findComponent({ name: 'DialogName' }); await dialog.vm.$emit('close');",
                    "verification": "Verify dialog is hidden AND state is updated after event"
                }
            },
            "computed_property_testing": {
                "description": "Testing computed properties that depend on complex prop structures",
                "pattern": "Test computed property with different prop configurations",
                "example": "Test hasBothConfigurationTypes with different existingConfigurations arrays",
                "setup": "Mount component with props that trigger different computed outcomes",
                "assertions": "expect(wrapper.vm.computedProperty).toBe(expectedValue)"
            },
            "form_mock_structure": {
                "description": "Shared mockForm object that components can read and update",
                "pattern": "const mockForm = { property: value, errors: {}, put: vi.fn() }; useForm returns this object",
                "requirements": [
                    "Shared object reference",
                    "Can be updated by component",
                    "Test can read updates"
                ],
                "benefits": [
                    "Component updates are visible in tests",
                    "Can verify form state changes",
                    "Consistent form behavior"
                ]
            }
        }
    },
    "integration_patterns": {
        "conditional_execution": {
            "check": "if (!shouldRunIntegrationTests()) $this->markTestSkipped()",
            "helper": "function shouldRunIntegrationTests(): bool { return env('RUN_INTEGRATION_TESTS', false); }",
            "group": "php artisan test --group=integration"
        },
        "external_services": {
            "mock_expensive": "Http::fake(['api.example.com/*' => Http::response()])",
            "real_critical": "Use real APIs for payment, auth flows",
            "rate_limits": "Handle gracefully, skip if exceeded"
        },
        "cleanup": {
            "database": "RefreshDatabase trait",
            "files": "Storage::fake()",
            "external": "Clean up test data after tests"
        }
    },
    "backend_testing_patterns": {
        "password_reset_testing": {
            "lesson": "Password::fake() does not exist - use Notification::fake() instead",
            "correct_pattern": "\\Illuminate\\Support\\Facades\\Notification::fake()",
            "assertion": "Notification::assertSentTo($user, \\App\\Notifications\\ResetPasswordNotification::class)",
            "incorrect_pattern": "Password::fake() - This method does not exist",
            "why": "Password::sendResetLink() sends a notification, so we need to fake the notification system, not a non-existent Password facade method"
        },
        "nullable_enum_properties": {
            "lesson": "Enum properties (role, status) can be null - always use optional chaining",
            "correct_pattern": "$user->role?->value ?? 'regular'",
            "incorrect_pattern": "$user->role->value - Fails when role is null",
            "when_to_use": "When accessing enum properties in test data setup, especially for update operations",
            "example": "When building update request data: 'role' => $user->role?->value ?? 'regular'"
        },
        "transaction_deletion_cross_business": {
            "lesson": "firstOrFail() returns 404, not 403 for cross-business access",
            "correct_assertion": "$response->assertNotFound()",
            "incorrect_assertion": "$response->assertForbidden()",
            "why": "When using firstOrFail() in controllers, missing records return 404 (ModelNotFoundException), not 403",
            "pattern": "Controllers using firstOrFail() for cross-business checks will return 404, not 403"
        },
        "database_unsigned_constraints": {
            "lesson": "BIGINT UNSIGNED columns cannot store negative values - expect 500 errors for constraint violations",
            "correct_test_pattern": "$response->assertStatus(500) when operation would result in negative value",
            "example": "Limit decrease below outstanding balance results in negative available balance",
            "verification": "Verify account wasn't updated (transaction should have rolled back)",
            "pattern": "When testing edge cases that would violate unsigned constraints, expect database errors (500 status), not success"
        },
        "unsupported_update_fields": {
            "lesson": "Don't test for updates to fields not included in FormRequest validation",
            "example": "UserUpdateRequest doesn't include 'name' field, so name updates aren't supported",
            "pattern": "Check FormRequest validation rules before writing update tests",
            "action": "Remove or comment out tests for unsupported field updates"
        },
        "currency_change_testing": {
            "lesson": "When testing currency changes, ensure business is refreshed and use proper transaction filtering",
            "pattern": "Create transactions with explicit created_at timestamps, filter by transaction ID to get correct one",
            "example": "Use ->where('id', '!=', $oldTransaction->id) to exclude old transactions when finding new ones"
        }
    },
    "common_issues": {
        "backend": {
            "session_auth": "Add withoutMiddleware(VerifyCsrfToken::class)",
            "database": "Use RefreshDatabase, proper assertions",
            "mocking": "Close Mockery in tearDown",
            "csrf": "Disable CSRF middleware for tests",
            "refresh_database_not_working": "Remove database configuration override from TestCase.php setUp() method. Let phpunit.xml handle configuration.",
            "singleton_pattern_issues": "Update controllers to use singleton access patterns. Replace relationship calls with direct model queries.",
            "foreign_key_column_errors": "Remove assertions and queries for fields that no longer exist after schema refactoring.",
            "route_singleton_issues": "Remove ->where('foreign_key_id', $id) conditions from routes when using singleton pattern.",
            "password_reset_fake": "Use Notification::fake() not Password::fake() - Password::fake() does not exist",
            "nullable_enum_access": "Always use optional chaining for enum properties: $user->role?->value ?? 'default'",
            "firstOrFail_returns_404": "firstOrFail() returns 404 (ModelNotFoundException), not 403 for missing records",
            "unsigned_constraint_violations": "BIGINT UNSIGNED columns cause 500 errors when trying to store negative values - expect assertStatus(500)"
        },
        "frontend": {
            "component_mounting": "Use data-testid, flushPromises for async",
            "inertia_warnings": "Mock complete usePage structure",
            "headless_ui_modals": "Test through parent components",
            "ziggy_errors": "Mock route function with current method",
            "csrf_token": "Mock CSRF token in document head",
            "mocked_components": "Mock TextInput with :type='type' to properly pass type attribute",
            "test_assertions": "Use wrapper.exists() and component.find() instead of text().toContain() for reliability",
            "form_testing": "Test form structure and input presence, not specific text content",
            "vue_prop_validation": "Make props optional with default null when component may not use them",
            "conditional_rendering": "Use v-if guards to prevent rendering when props are null",
            "stderr_warnings": "Fix Vue prop validation warnings by making props optional and adding guards",
            "component_detection_failures": "When findComponent() fails, use text content verification or HTML structure testing",
            "route_mocking_complexity": "Mock route function to handle both string returns and object returns with current method",
            "layout_component_testing": "Test layout components by checking HTML structure and text content rather than component detection",
            "mobile_responsive_testing": "Use CSS class selectors (.sm\\:hidden) to test mobile-specific elements",
            "inertia_v2_mocking": "CRITICAL: When using Inertia 2.0 features (WhenVisible, Deferred), must mock them in ALL test files",
            "console_error_prevention": "Ensure all variables are properly defined and imported to prevent ReferenceError",
            "when_visible_mock": "WhenVisible: { name: 'WhenVisible', template: '<div><slot /></div>', props: ['data', 'buffer'] }",
            "deferred_mock": "Deferred: { name: 'Deferred', template: '<div><slot /></div>', props: ['data'] }",
            "current_user_definition": "Always define currentUser from page.props.auth?.user in components that use it",
            "jetstream_flash_location": "Read flash messages from page.props.jetstream.flash, NOT page.props.flash",
            "inertia_back_method": "Use back() helper function, NOT Inertia::back() which doesn't exist",
            "visual_feedback_testing": "Always test CSS classes (border-green-300, border-red-300) for visual feedback",
            "server_validation_missing": "Test scenarios where flash messages are missing - component should handle gracefully",
            "router_reload_logout": "NEVER use router.reload() after form submissions - causes logout and session invalidation",
            "wrong_route_usage": "Use user-password.update for password changes, user-profile-information.update for profile changes",
            "missing_form_fields": "Include all required fields (name, email, password) when switching between email and phone",
            "authentication_state_loss": "Test that user stays authenticated after profile updates - add session regeneration in backend",
            "form_data_synchronization": "Update parent form data before emitting events to child components"
        },
        "integration": {
            "credentials": "Skip if not configured",
            "rate_limits": "Handle gracefully, skip if exceeded",
            "network": "Add retry logic, timeout handling"
        }
    },
    "data_flow_patterns": {
        "backend_to_frontend": {
            "principle": "Backend provides exactly what frontend needs",
            "page_specific": "Route controllers for page-specific data",
            "shared_data": "HandleInertiaRequests for cross-page data",
            "testing": "Test that backend provides complete data structure"
        },
        "testing_data_structure": {
            "backend": "Test that controllers provide complete data",
            "frontend": "Test that components handle data correctly",
            "integration": "Test end-to-end data flow"
        }
    },
    "recent_patterns_2025": {
        "route_response_types": {
            "internal_routes": "ALWAYS return Inertia responses (redirect()->back(), Inertia::render())",
            "external_routes": "ALWAYS return JSON responses (response()->json()) for 3rd party integrations",
            "testing_internal": "Use post() and assertRedirect() with assertSessionHas()",
            "testing_external": "Use postJson() and assertStatus() with assertJson()",
            "never_mix": "Don't use postJson() for internal routes or post() for external routes",
            "examples": {
                "internal": "User management, entities, features, dashboard, profile",
                "external": "Twilio SMS routes (/sms/resend), external API integrations"
            }
        },
        "inertia_router_conversion": {
            "frontend_rules": "NEVER use fetch() - always use Inertia's router methods",
            "backend_rules": "NEVER return JSON for internal routes - always return Inertia responses",
            "testing_rules": "NEVER use postJson() for Inertia routes - use post() and assertRedirect()",
            "flash_messages": "Use session()->flash() for user feedback, not JSON responses",
            "error_handling": "Use router.reload() instead of window.location.reload()",
            "success_messages": "Remove success flash messages for increment/decrement operations as per user request"
        },
        "pivot_table_logic": {
            "requirement": "Check if user has any incomplete records in pivot table where is_completed = false",
            "implementation": "Loop through all user entities, check features() relationship with wherePivot('is_completed', false)",
            "testing": "Create actual feature records in pivot table with is_completed = false for tests",
            "database_queries": "Use exists() method for efficient checking of incomplete features"
        },
        "tenant_model_refactor": {
            "old": "Tenant::factory()->create(['user_id' => $user->id])",
            "new": "Tenant::factory()->create()",
            "testing": "Test global tenant model, no user_id needed"
        },
        "conditional_rendering": {
            "test_both": "Test both null and existing data scenarios",
            "backend": "Test that backend conditionally passes data",
            "frontend": "Test component visibility based on props"
        },
        "shadow_styling": {
            "consistent": "Use shadow-xl consistently",
            "testing": "Test that shadow classes are applied correctly"
        },
        "inertia_router": {
            "use_router": "Use router.post() instead of fetch",
            "test_flash": "Test flash messages and redirects",
            "no_alerts": "Never use alert() or console.error()"
        },
        "admin_authorization": {
            "test_protection": "Test admin-only features with proper user mocking",
            "frontend": "Test admin controls visibility",
            "backend": "Test authorization in controllers"
        },
        "responsive_components": {
            "test_behavior": "Test with data that triggers responsive behavior",
            "window_resize": "Test window resize events and cleanup",
            "pagination": "Test with data that exceeds limits"
        },
        "data_structure_changes": {
            "update_all": "Update ALL related tests when changing backend data",
            "frontend_compatibility": "Test that frontend handles both old and new formats",
            "backend_structure": "Test that backend provides correct data structure"
        },
        "price_fields_implementation": {
            "database_migration": "Add decimal columns with proper precision (10,2) for price fields",
            "model_updates": "Add price fields to fillable array and casts (decimal:2)",
            "validation_rules": "Use numeric, min:0, max:999999.99 for price validation",
            "frontend_forms": "Use type='number' with step='0.01' for price inputs",
            "display_formatting": "Use parseFloat(price).toFixed(2) for consistent decimal display",
            "responsive_design": "Use flex-col sm:flex-row for mobile-first price display",
            "factory_updates": "Use faker->optional(0.7)->randomFloat(2, 0, 50) for realistic test data"
        },
        "comprehensive_feature_testing": {
            "backend_coverage": "Test create, update, validation, display, and edge cases",
            "frontend_coverage": "Test form rendering, input validation, and display logic",
            "integration_coverage": "Test data flow from backend to frontend display",
            "edge_cases": "Test null values, empty strings, zero values, and large numbers",
            "validation_testing": "Test positive, negative, non-numeric, and boundary values"
        },
        "qr_code_modal_implementation": {
            "component_props": "Make feature and position props optional with default null",
            "conditional_rendering": "Use v-if guards throughout template to prevent rendering when props are null",
            "qr_generation": "Add guards in functions to return early if props are null",
            "modal_visibility": "Update Modal :show condition to include prop validation",
            "testing_approach": "Test both with and without props, ensure no stderr warnings"
        },
        "phpunit_modernization": {
            "attribute_syntax": "Use #[\\PHPUnit\\Framework\\Attributes\\Test] for all test methods",
            "deprecation_warnings": "PHPUnit 12 warns about doc-comment metadata, use attributes instead",
            "migration_pattern": "Use #[\\PHPUnit\\Framework\\Attributes\\Test] for all test methods",
            "benefits": "Future-proof, no deprecation warnings, cleaner syntax"
        },
        "inertia_v2_polling": {
            "usePoll_import": "Import usePoll from @inertiajs/vue3 for polling functionality",
            "mock_usePoll": "Always mock usePoll in test files that use components with polling",
            "polling_structure": "usePoll returns { start: function, stop: function }",
            "test_mock": "usePoll: vi.fn(() => ({ start: vi.fn(), stop: vi.fn() }))",
            "real_time_updates": "Use polling to check for action status and provide real-time updates"
        },
        "multiple_features_handling": {
            "backend_array_processing": "Backend receives feature_ids as array, splits into individual database records",
            "database_records": "Each feature gets separate entity_feature_pivot record with same position",
            "frontend_aggregation": "Frontend calculates totals (cost_price, selling_price) across all features",
            "qr_code_generation": "QR code includes comma-separated feature_ids for multiple features",
            "validation_approach": "Validate all features exist and are available at position",
            "display_logic": "Show all feature names, descriptions, and aggregated pricing"
        },
        "qr_action_modal_patterns": {
            "conditional_rendering": "Use v-if guards throughout template to prevent rendering when props are null",
            "prop_validation": "Make feature and position props optional with default null",
            "modal_visibility": "Update Modal :show condition to include prop validation",
            "qr_generation_guards": "Add guards in functions to return early if props are null",
            "testing_approach": "Test both with and without props, ensure no stderr warnings",
            "auto_close_behavior": "Modal closes automatically once action is successfully processed"
        },
        "cost_price_calculation_fixes": {
            "backend_data_provision": "Ensure EntityService includes cost_price and selling_price in feature data",
            "frontend_parsing": "Use parseFloat() to handle string/number conversion for price calculations",
            "defensive_programming": "Add null checks and default values in template before calling .toFixed()",
            "computed_properties": "Update computed properties to handle edge cases (null, undefined, string values)",
            "template_safety": "Use (totalCostPrice || 0).toFixed(2) pattern in templates"
        },
        "test_mock_consistency": {
            "inertia_mocks": "All test files using Inertia components must include complete mock structure",
            "usePoll_mocking": "Any component using usePoll requires usePoll mock in ALL related test files",
            "mock_completeness": "Include all Inertia exports used by components (usePage, usePoll, router, etc.)",
            "test_isolation": "Each test file should have complete mocks to prevent cross-file dependencies"
        },
        "mobile_navigation_testing": {
            "layout_component_testing": "Test layout components by checking HTML structure and text content rather than component detection",
            "mobile_responsive_testing": "Use CSS class selectors (.sm\\:hidden) to test mobile-specific elements",
            "simplified_testing_approach": "Focus on testing functionality and structure rather than complex component mocking",
            "text_content_verification": "Use wrapper.text().toContain() to verify component presence when component detection fails",
            "mobile_toggle_patterns": "Test mobile navigation elements by verifying they appear in the correct responsive sections"
        },
        "route_mocking_complexity": {
            "route_function_mocking": "Mock route function to handle both string returns and object returns with current method",
            "global_route_mocks": "Set up global.route mock in beforeEach to ensure consistency across tests",
            "route_current_method": "Mock route().current() method to return boolean for active route testing",
            "ziggy_mocking": "Mock ziggy-js module for complex routing scenarios",
            "page_props_mocking": "Mock $page global property with complete props structure for layout components"
        },
        "component_testing_simplification": {
            "avoid_complex_mocking": "When component detection fails, use text content verification instead",
            "html_structure_testing": "Test HTML structure and class presence rather than component instance detection",
            "stub_approach": "Use simple template stubs for components that are difficult to mock",
            "test_focus": "Focus on testing the behavior and structure rather than implementation details",
            "debugging_approach": "Use console.log or text content verification to debug test failures"
        },
        "layout_component_patterns": {
            "mobile_navigation_structure": "Test mobile navigation by verifying elements appear in .sm:hidden sections",
            "responsive_design_testing": "Test both desktop and mobile layouts using appropriate CSS selectors",
            "dark_mode_toggle_testing": "Test dark mode toggles by verifying they appear in correct responsive sections",
            "navigation_element_positioning": "Test element positioning using CSS class selectors and text content verification",
            "hamburger_menu_testing": "Test hamburger menu functionality alongside other mobile navigation elements"
        },
        "session_lessons_2025": {
            "route_type_distinction": {
                "critical_rule": "Internal app routes MUST return Inertia responses, SMS API routes MUST return JSON",
                "internal_examples": "User management, entities, features, dashboard, profile",
                "sms_examples": "SMS send/verify/resend (/api/sms/*) - API routes only with JSON responses",
                "testing_approach": "Use post() for internal routes, postJson() for SMS API routes",
                "never_mix": "Don't use postJson() for internal routes or post() for SMS API routes"
            },
            "inertia_conversion_patterns": {
                "frontend_conversion": "Replace ALL fetch() calls with Inertia router methods (router.post(), router.get(), etc.)",
                "backend_conversion": "Replace ALL JSON responses with Inertia responses (redirect()->back(), Inertia::render())",
                "flash_messaging": "Use session()->flash() for user feedback instead of JSON responses",
                "error_handling": "Use router.reload() instead of window.location.reload()",
                "csrf_handling": "Inertia automatically handles CSRF tokens, no manual token retrieval needed"
            },
            "pivot_table_requirements": {
                "new_logic": "Check if user has any incomplete records in pivot table where is_completed = false",
                "implementation": "Loop through all user entities, check features() relationship with wherePivot('is_completed', false)",
                "testing_approach": "Create actual feature records in pivot table with is_completed = false for tests",
                "database_efficiency": "Use exists() method for efficient checking of incomplete features",
                "user_experience": "Users have has_available_feature = true only when they have actual incomplete feature records"
            },
            "test_updates_required": {
                "json_to_redirect": "Update tests expecting JSON responses to expect redirects for internal routes",
                "postJson_to_post": "Replace postJson() with post() for internal route tests",
                "assertJson_to_assertSessionHas": "Replace assertJson() with assertSessionHas() for flash messages",
                "status_codes": "Replace assertStatus(200) with assertRedirect() for internal routes",
                "test_data_creation": "Create actual pivot table records for tests that check has_available_feature"
            },
            "cursorrules_updates": {
                "route_response_types": "Added comprehensive section on internal vs external route response types",
                "inertia_patterns": "Added detailed Inertia.js patterns and testing guidelines",
                "testing_helpers": "Added proper Inertia testing helpers (assertInertia) instead of just checking redirects",
                "critical_rules": "Added NEVER/ALWAYS rules for route response types and testing approaches"
            }
        },
        "system_activation_refactoring_2025": {
            "component_architecture_lessons": {
                "single_responsibility_principle": "Each component should handle one specific responsibility - single card, not multiple cards",
                "parent_child_separation": "Use parent components for data management, child components for display logic",
                "prop_design_patterns": "Design props for single items (item: Object), not collections (items: Array)",
                "separation_of_concerns": "Separate data management from display logic across components"
            },
            "component_refactoring_patterns": {
                "extract_functionality": "Move specific functionality (like activation toggle) to dedicated components",
                "maintain_backend_compatibility": "Ensure extracted components use same backend routes and form fields",
                "preserve_user_experience": "Keep all existing functionality (confirmation dialogs, member count checks) intact",
                "update_parent_integration": "Update parent components to include new child components with proper conditional rendering"
            },
            "form_data_handling": {
                "complete_form_fields": "When extracting components, include ALL required form fields, not just the extracted field",
                "backend_validation_requirements": "Backend validation may require all configuration fields, not just the extracted field",
                "form_submission_consistency": "Use same form submission logic and routes as original component",
                "data_preservation": "Ensure all current configuration values are preserved in form data"
            },
            "testing_approach_updates": {
                "component_mocking": "Mock new components in parent component tests",
                "prop_verification": "Test that new components receive correct props from parent",
                "conditional_rendering": "Test that components are shown/hidden based on data availability",
                "integration_testing": "Test that parent-child component integration works correctly",
                "backend_compatibility": "Verify that backend tests still pass after frontend refactoring"
            },
            "frontend_build_issues": {
                "async_function_fixes": "Fix async/await syntax errors in Vue components for successful builds",
                "function_declaration_updates": "Ensure all functions using await are properly marked as async",
                "build_verification": "Always run npm run build after making changes to verify no syntax errors",
                "error_resolution": "Fix build errors systematically, one file at a time"
            },
            "user_experience_preservation": {
                "functionality_consistency": "Ensure all existing functionality works exactly the same after refactoring",
                "ui_placement": "Position new components in logical locations within the page structure",
                "conditional_visibility": "Show components only when appropriate data is available",
                "form_behavior": "Maintain same form submission behavior and user feedback"
            }
        },
        "singleton_pattern_implementation": {
            "database_schema_refactoring": {
                "foreign_key_removal": "When removing foreign key columns, always drop foreign key constraints first, then drop columns",
                "migration_challenges": "Handle foreign key constraint issues by dropping constraints before columns",
                "test_database_sync": "Ensure test database schema matches production after schema changes",
                "bulk_updates": "Use sed commands for bulk updates across many test files when removing foreign key references"
            },
            "singleton_testing_patterns": {
                "service_container_bindings": "Test singleton bindings with app('tenant') and app('configuration')",
                "service_class_testing": "Test static methods and caching behavior of singleton service classes",
                "model_static_methods": "Test getInstance(), getActiveInstance(), and updateInstance() methods",
                "helper_function_testing": "Test global helper functions like tenant() and configuration()",
                "temporary_verification": "Create temporary tests to verify singleton implementations, then delete after verification"
            },
            "model_relationship_cleanup": {
                "remove_unnecessary_relationships": "Remove foreign key relationships that are no longer needed",
                "update_fillable_arrays": "Remove foreign key fields from fillable arrays when dropping columns",
                "update_casts_arrays": "Remove foreign key fields from casts arrays when dropping columns",
                "add_singleton_methods": "Add static methods for singleton access to models"
            },
            "service_layer_updates": {
                "update_service_queries": "Update services to work without foreign key relationships",
                "use_singleton_access": "Use singleton access patterns instead of relationships",
                "simplify_queries": "Use latest() instead of complex where clauses with foreign keys",
                "remove_configuration_references": "Remove configuration_id references from service methods when using singleton pattern"
            },
            "factory_updates": {
                "remove_foreign_key_fields": "Remove foreign key fields from factory definitions when dropping columns",
                "update_factory_relationships": "Update factories to work with singleton patterns",
                "simplify_factory_definitions": "Simplify factory definitions by removing unnecessary foreign key relationships"
            },
            "test_bulk_updates": {
                "sed_commands": "Use find and sed commands to bulk update test files",
                "remove_configuration_id": "find tests -name '*.php' -exec sed -i '' \"s/'configuration_id' => \\$[^,]*,\\s*//g\" {} \\;",
                "remove_tenant_id": "find tests -name '*.php' -exec sed -i '' \"s/'tenant_id' => \\$[^,]*,\\s*//g\" {} \\;",
                "update_database_assertions": "Remove foreign key references from assertDatabaseHas and assertDatabaseMissing calls"
            }
        },
        "refresh_database_fixes": {
            "problem": "RefreshDatabase trait not working due to configuration conflicts",
            "root_cause": "TestCase.php overriding database configuration in setUp() method",
            "solution": "Remove database configuration override from TestCase.php",
            "result": "RefreshDatabase works correctly, no manual cleanup needed",
            "prevention": "Never override database configuration in TestCase.php setUp() method"
        },
        "controller_singleton_updates": {
            "problem": "Controllers trying to access relationships that no longer exist",
            "solution": "Update controllers to use singleton access patterns",
            "pattern": "Replace $model->relationship with \\App\\Models\\Model::where('is_active', true)->first()",
            "files_affected": "ActionController, routes/web.php, and other controllers"
        },
        "test_assertion_updates": {
            "problem": "Tests asserting fields that no longer exist in singleton pattern",
            "solution": "Remove assertions for non-existent fields",
            "examples": {
                "configuration_id": "Remove assertions for this field in singleton pattern",
                "database_queries": "Update queries to work without foreign key relationships"
            }
        },
        "final_test_validation": {
            "initial_status": "Many tests failing due to singleton pattern implementation",
            "final_status": "481 tests passing, 7 skipped (expected), 0 failing",
            "validation_commands": {
                "full_suite": "php artisan test",
                "integration": "php artisan test --group=integration",
                "specific_tests": "php artisan test --filter=TestName"
            }
        },
        "styling_consistency_testing": {
            "shadow_class_testing": {
                "principle": "Test that shadow classes are applied consistently across components",
                "implementation": "Verify shadow-lg is applied instead of shadow-xl",
                "testing": "Test that shadow classes are applied correctly in component tests",
                "example": "expect(wrapper.find('.shadow-lg').exists()).toBe(true)"
            },
            "spacing_testing": {
                "principle": "Test that spacing between components is correct",
                "implementation": "Test margin classes (mb-4, mb-8) are applied correctly",
                "testing": "Test that spacing between multiple components works",
                "example": "Test EntityList renders multiple Entity components with proper spacing"
            },
            "modal_overflow_testing": {
                "principle": "Test that modal content stays within modal boundaries",
                "implementation": "Test with various content lengths to prevent overflow",
                "testing": "Test that w-full prevents overflow better than w-[calc(100%+7rem)]",
                "example": "Test action modal with long descriptions"
            }
        },
        "component_architecture_testing": {
            "single_responsibility_testing": {
                "principle": "Test that each component has one clear responsibility",
                "implementation": "Test individual components with specific props",
                "testing": "Test Entity with single item prop, not array",
                "example": "Test Entity handles single item display correctly"
            },
            "parent_child_testing": {
                "principle": "Test how parent and child components work together",
                "implementation": "Test data flow from parent to child components",
                "testing": "Test EntityList renders multiple Entity components",
                "example": "Test parent loops over array, child handles individual items"
            },
            "prop_design_testing": {
                "principle": "Test that props are designed for single items, not collections",
                "implementation": "Test components with single item props",
                "testing": "Test item: Object, not items: Array",
                "example": "Test Entity receives single item and itemNumber"
            }
        },
        "vue_warnings_resolution": {
            "extraneous_attributes_warning": {
                "problem": "Vue warnings about 'Extraneous non-props attributes (class) were passed to component'",
                "root_cause": "Component had multiple root elements (fragment), preventing automatic attribute inheritance",
                "solution": "Wrapped entire component content in single root <div> element",
                "testing": "Verify no Vue warnings in console during component rendering",
                "prevention": "Always use single root element for reusable components"
            },
            "attribute_inheritance_testing": {
                "principle": "Test that components can inherit attributes from parent",
                "implementation": "Test that class attributes are properly inherited",
                "testing": "Test that components with single root element inherit attributes",
                "example": "Test Entity inherits class attributes from EntityList"
            }
        },
        "modal_overflow_prevention": {
            "width_class_testing": {
                "principle": "Test that modal content stays within modal boundaries",
                "implementation": "Test with w-full instead of w-[calc(100%+7rem)]",
                "testing": "Test modal content with various description lengths",
                "example": "Test action modal with long feature descriptions"
            },
            "responsive_modal_testing": {
                "principle": "Test that modals work on different screen sizes",
                "implementation": "Test modal behavior on mobile, tablet, and desktop",
                "testing": "Test modal content containment across screen sizes",
                "example": "Test modal overflow prevention on different screen sizes"
            }
        },
        "component_architecture_refactoring": {
            "single_card_component_pattern": {
                "principle": "Each component should handle one specific responsibility - single card, not multiple cards",
                "parent_looping": "Use parent components to handle iteration, child components for individual items",
                "prop_design": "Design props for single items (item: Object), not collections (items: Array)",
                "separation_of_concerns": "Separate data management from display logic"
            },
            "component_renaming": {
                "file_rename": "StampCardDisplay.vue \u2192 StampCard.vue",
                "test_file_rename": "StampCardDisplay.test.js \u2192 StampCard.test.js",
                "import_updates": "Update all import statements to use new component name",
                "component_references": "Update all component name references in tests and parent components"
            },
            "dashboard_integration": {
                "parent_looping": "v-for=\"item in items.data\" with :key=\"item.id\"",
                "component_instances": "Create multiple Entity instances, each receiving single item prop",
                "spacing": "Add space-y-6 class for proper vertical spacing between items"
            }
        },
        "git_based_conditional_testing": {
            "performance_optimization": {
                "problem": "Expensive tests (20+ seconds) running on every test execution even when file unchanged",
                "solution": "Implement git-based conditional test execution",
                "time_saved": "~20 seconds per test run when expensive tests are skipped",
                "automatic_detection": "No manual intervention required"
            },
            "implementation_pattern": {
                "git_check_function": "Check if test file has been modified since last commit using git diff --name-only HEAD",
                "conditional_execution": "Use describe.skip when file unchanged, describe when modified",
                "fail_safe_behavior": "Run tests if git check fails to ensure nothing is missed",
                "console_feedback": "Clear messages showing when tests are skipped vs running"
            },
            "code_example": {
                "git_check": "function hasFileChangedSinceLastCommit() { const lastCommit = execSync('git rev-parse HEAD', { encoding: 'utf8' }).trim(); const result = execSync(`git diff --name-only ${lastCommit}`, { encoding: 'utf8' }); return result.includes('EmailOrPhoneTypeDetection.test.js'); }",
                "conditional_describe": "(shouldRunTests ? describe : describe.skip)('EmailOrPhone Type Detection', () => { ... });"
            }
        },
        "vue_prop_validation_fixes": {
            "stderr_warnings_prevention": {
                "problem": "Vue components showing stderr warnings about undefined props in test context",
                "solution": "Make props optional with default null and add v-if guards",
                "optional_props": "Make props optional with default null to prevent stderr warnings",
                "conditional_rendering": "Use v-if guards to prevent rendering when props are null"
            },
            "template_safety": {
                "prop_definition": "const props = defineProps({ item: Object, // Single item object });",
                "computed_safety": "const currentItem = computed(() => { return props.item || null; });",
                "template_guards": "v-if=\"currentItem\" to prevent rendering when prop is null",
                "function_guards": "Add guards in functions to return early if props are null"
            }
        },
        "test_file_organization_updates": {
            "synchronized_changes": {
                "test_file_rename": "Keep test file names in sync with component names",
                "prop_updates": "Update tests to pass single props instead of arrays",
                "component_references": "Update all component name references in tests",
                "assertion_updates": "Update test assertions to expect single item behavior"
            },
            "dashboard_test_updates": {
                "component_detection": "Update findAllComponents to use new component name",
                "prop_assertions": "Update assertions to check single item prop on individual components",
                "variable_naming": "Fix variable name conflicts (items vs itemComponents)"
            }
        },
        "entity_filtering_testing": {
            "comprehensive_coverage": {
                "problem": "Need to test filtering logic that hides expired items and items without available features",
                "solution": "Create dedicated filtering test suite with multiple scenarios",
                "test_scenarios": [
                    "Filters out expired items except most recent",
                    "Filters out items without available features except most recent",
                    "Includes items with available features",
                    "Includes recent item even if expired and no available features",
                    "Returns empty collection when no items"
                ]
            },
            "test_data_setup": {
                "realistic_data": "Create test data that matches real-world scenarios",
                "filtering_criteria": "Ensure test items have has_available_feature = true and future expires_at",
                "timing_considerations": "Use sleep() to ensure different timestamps in tests",
                "ordering_consistency": "Test with ascending order (oldest first) for natural progression"
            },
            "existing_test_updates": {
                "problem": "Existing tests expected all items to be shown, but filtering reduces visible items",
                "solution": "Update test data to ensure items pass filtering criteria",
                "example": "DashboardEntityTest updated to set has_available_feature = true and future expires_at"
            }
        },
        "bug_reproduction_testing": {
            "approach": "Create test that reproduces the bug, then fix and verify",
            "example": "EntityAvailableFeatureBugTest shows bug reproduction and fix verification",
            "benefits": "Ensures bug is actually fixed and doesn't regress",
            "implementation": {
                "reproduce_bug": "Write test that demonstrates the bug exists",
                "implement_fix": "Fix the bug in the code",
                "verify_fix": "Update test to verify bug is fixed",
                "comprehensive_testing": "Test both the fix and related functionality"
            }
        },
        "inertia_router_testing": {
            "frontend_testing": {
                "problem": "Components using fetch() instead of Inertia router methods",
                "solution": "Test that components use Inertia router methods correctly",
                "mock_requirements": "Mock Inertia router methods in tests",
                "behavior_testing": "Test that state updates happen automatically without page refreshes"
            },
            "backend_testing": {
                "route_response_types": "Test that internal routes return Inertia responses (redirects)",
                "flash_messages": "Test that flash messages are set correctly",
                "no_json_responses": "Ensure internal routes don't return JSON responses"
            }
        },
        "item_ordering_testing": {
            "ascending_order": "Test that items are displayed in ascending order (oldest first)",
            "filtering_with_ordering": "Test that filtering works correctly with ascending order",
            "most_recent_identification": "Test that most recent item is correctly identified in ascending order",
            "consistency": "Test that both Dashboard and EntityList use same ordering"
        },
        "modal_ui_cleanup_testing": {
            "ui_element_removal": "When removing UI elements, update all related tests immediately",
            "vue_directive_cleanup": "Remove orphaned v-else directives when removing v-if elements",
            "template_syntax_fixes": "Use correct computed property access in templates (no .value)",
            "spacing_optimization": "Test that modal spacing is optimized after UI cleanup",
            "functionality_preservation": "Ensure core functionality works after UI element removal"
        },
        "vue_template_syntax_fixes": {
            "computed_property_access": "Computed properties auto-unwrap in templates - don't use .value",
            "directive_cleanup": "Always clean up Vue directives when removing conditional elements",
            "orphaned_directives": "Remove orphaned v-else directives to prevent syntax errors",
            "template_safety": "Use defensive programming in templates with null checks"
        },
        "frontend_test_updates": {
            "assertion_updates": "Update test assertions when removing UI elements",
            "test_synchronization": "Keep tests in sync with UI changes",
            "functionality_testing": "Test both UI and functionality after changes",
            "vue_syntax_testing": "Ensure no broken Vue syntax in tests"
        },
        "frontend_test_fixing": {
            "route_function_mocking": "Mock global.route function for Vue components using Ziggy",
            "banner_component_mocking": "Mock Banner component to prevent flash errors",
            "disabled_button_testing": "Account for disabled button title differences in selectors",
            "inertia_router_mocking": "Use expect.objectContaining() for flexible Inertia router assertions",
            "vue_global_properties": "Provide global properties ($page, route) in mount options"
        },
        "button_state_testing": {
            "disabled_buttons": "Disabled buttons have different titles and are excluded from selectors",
            "conditional_rendering": "Some buttons may not render based on user state or permissions",
            "mobile_desktop": "Account for responsive design differences in test environment",
            "state_logic": "Understand the business logic behind button states before writing tests"
        },
        "route_component_mismatch": {
            "component_naming_conventions": "Use singular component for single items, plural component for arrays",
            "prop_structure_mismatch": "Match prop structure to component expectations (item vs items)",
            "data_filtering_vs_display": "Pass all filtered items to component that can handle multiple items",
            "component_responsibility_separation": "Design components with clear single responsibility"
        },
        "route_fix_patterns": {
            "component_selection": "Check for both singular and plural component variants, match data structure to component type",
            "data_passing_strategy": "Pass single objects to singular components, arrays to plural components",
            "component_architecture": "Use clear naming to distinguish single vs multiple item components"
        },
        "test_fix_patterns": {
            "model_field_updates": "When adding new model fields, update both model fillable/casts and test expectations",
            "service_filtering_test_data": "Ensure test data meets all filtering criteria (is_available = true, future expires_at)",
            "data_structure_index_updates": "Update test assertions when data structure changes (items.data.1 to items.data.0)",
            "pivot_table_undo_operations": "Use updateExistingPivot for undo operations, never delete records. Assert updated status, not missing records",
            "inertia_component_naming": "Keep route component names consistent with test expectations",
            "test_assertion_updates": "Update assertions when changing from delete to update operations"
        },
        "systematic_test_fixing": {
            "identify_failures": "Run full test suite to identify all failing tests",
            "create_todo_list": "Create TODO list to track each failing test",
            "root_cause_analysis": "Understand why each test is failing before making changes",
            "fix_one_by_one": "Fix one test at a time, verify resolution before moving to next",
            "comprehensive_updates": "Update all related tests when making changes",
            "verification": "Run tests after each fix to ensure resolution"
        },
        "database_constraint_testing": {
            "unique_constraint_design": {
                "principle": "Design unique constraints to match business logic requirements",
                "example": "Same item can appear at different positions on same order",
                "implementation": "Use (order_id, product_id, position) instead of just (order_id, product_id)",
                "testing": "Test that same entity at different contexts is allowed"
            },
            "migration_challenges": {
                "constraint_modification_issues": "MySQL may prevent dropping constraints due to foreign key dependencies",
                "solution": "Recreate entire table instead of modifying existing constraint",
                "rollback_strategy": "Always provide rollback functionality in migrations",
                "testing": "Test constraint modifications in development first"
            },
            "pivot_record_creation": {
                "atomic_operations": "Create all dependent records when creating parent records",
                "duplicate_prevention": "Check for existing records using combination of all relevant fields",
                "existing_data_handling": "Handle scenarios where parent records exist but pivot records are missing",
                "testing": "Test both creation and duplicate prevention scenarios"
            }
        },
        "database_testing_patterns": {
            "unique_constraint_testing": {
                "test_constraint_behavior": "Create tests that verify unique constraints work correctly",
                "test_edge_cases": "Test same entity at different positions/contexts should be allowed",
                "test_violations": "Verify that duplicate records cause appropriate errors",
                "example": "OrderItemPositionUniqueConstraintTest validates that same item can appear at different positions"
            },
            "pivot_record_testing": {
                "test_creation": "Verify pivot records are created when parent records are created",
                "test_relationships": "Verify proper relationships between parent and pivot records",
                "test_duplicate_prevention": "Ensure duplicate pivot records are not created",
                "test_existing_data": "Test with existing records that may have missing pivot records"
            },
            "migration_testing": {
                "test_constraint_changes": "Verify migrations that modify constraints work correctly",
                "test_rollback": "Ensure migration rollbacks work as expected",
                "test_table_recreation": "When constraint modifications fail, test table recreation approach",
                "example": "Test unique constraint updates and table recreation scenarios"
            }
        },
        "test_suite_fixing_patterns": {
            "migration_file_issues": {
                "problem": "Empty migration files cause 'Class not found' errors in tests",
                "solution": "Ensure all migration files have proper PHP class structure",
                "prevention": "Always create migrations with proper up() and down() methods",
                "fix_example": "Add proper migration class structure even for placeholder migrations"
            },
            "inertia_component_name_mismatches": {
                "problem": "Tests expect different component names than routes actually use",
                "solution": "Check actual route component names and update test assertions",
                "common_mismatch": "UserItem vs UserItems (singular vs plural)",
                "fix_pattern": "Update test assertions to match actual Inertia::render() component names"
            },
            "pivot_record_count_expectations": {
                "problem": "Tests expect different pivot record counts than system actually creates",
                "solution": "Understand system behavior and update test expectations accordingly",
                "system_behavior": "System ensures ALL items have required pivot records when activated",
                "test_updates": "Update assertions to match actual system behavior, not assumptions"
            },
            "phpunit_12_attribute_migration": {
                "problem": "PHPUnit 12 requires modern attribute syntax for test methods",
                "solution": "Convert all doc-comment metadata to PHPUnit 12 attributes",
                "pattern": "Use #[\\PHPUnit\\Framework\\Attributes\\Test] for all test methods",
                "bulk_conversion": "Use find and replace to convert all instances at once"
            },
            "systematic_test_fixing_approach": {
                "identify_all_issues": "Run full test suite to identify all failures and warnings",
                "categorize_issues": "Group similar issues together (migrations, component names, etc.)",
                "fix_systematically": "Fix one category at a time, verify before moving to next",
                "comprehensive_verification": "Run complete test suite after all fixes to ensure success"
            },
            "inertia_v2_feature_implementation": {
                "deferred_props": {
                    "backend_implementation": "Use Inertia::defer(fn() => $this->generateExpensiveData()) for heavy operations",
                    "frontend_implementation": "Use <Deferred data=\"propName\"> with fallback template",
                    "testing_requirement": "Mock Deferred component in all test files using components with deferred props",
                    "benefits": "Faster initial page load, progressive data loading"
                },
                "when_visible": {
                    "frontend_implementation": "Wrap content with <WhenVisible data=\"propName\" :buffer=\"200\">",
                    "testing_requirement": "Mock WhenVisible component in ALL test files using components with lazy loading",
                    "benefits": "Improved performance by loading data only when visible",
                    "buffer_setting": "Use 200px buffer for smooth loading experience"
                },
                "prefetching": {
                    "frontend_implementation": "Use router.prefetch('/path', { method: 'get', data: params }, { cacheFor: '5m', cacheTags: ['tag'] })",
                    "use_cases": "Hover-based prefetching for faster navigation",
                    "benefits": "Instant page loading when user clicks prefetched content",
                    "replaces": "Custom image preloading and manual data fetching"
                },
                "testing_requirements": {
                    "when_visible_mock": "WhenVisible: { name: 'WhenVisible', template: '<div><slot /></div>', props: ['data', 'buffer'] }",
                    "deferred_mock": "Deferred: { name: 'Deferred', template: '<div><slot /></div>', props: ['data'] }",
                    "comprehensive_mocking": "Include ALL Inertia exports used by components in test mocks",
                    "test_isolation": "Each test file should have complete mocks to prevent cross-file dependencies"
                }
            },
            "console_error_debugging": {
                "reference_error_prevention": "Always define variables before using them in components",
                "current_user_pattern": "const currentUser = page.props.auth?.user; // Define in components that use it",
                "cascading_errors": "Fix root cause errors first, then address cascading Vue warnings",
                "browser_logs_debugging": "Use mcp_laravel-boost_browser-logs to check for JavaScript errors",
                "error_prevention": "Ensure all imports and variable definitions are complete"
            },
            "progressive_loading_patterns": {
                "separate_loading_states": "Use different state variables for different components (isGeneratingQR, isQRCodeLoaded, isTimerReady)",
                "immediate_feedback": "Show content as soon as it's ready, use placeholders for pending content",
                "fallback_mechanisms": "Implement multiple timeout fallbacks to ensure loading states are cleared",
                "user_experience": "Users prefer immediate feedback over waiting for complete loading",
                "implementation_example": "QR code shows immediately when image loads, timer shows placeholder until ready"
            },
            "dashboard_component_testing": {
                "component_logic_changes": {
                    "problem": "Frontend tests failing due to component structure changes in DashboardContent.vue",
                    "solution": "Update test expectations to match new component behavior for active vs inactive systems",
                    "active_system": "Shows user stats + redemption statistics",
                    "inactive_system": "Shows user stats + setup metrics",
                    "testing_approach": "Create separate mock data for active and inactive systems"
                },
                "mock_data_organization": {
                    "active_system_mock": "Include userStats, redemptionStats, and stampCardConfiguration.is_active = true",
                    "inactive_system_mock": "Include userStats, setup metrics, and stampCardConfiguration.is_active = false",
                    "test_isolation": "Use appropriate mock data for each test scenario"
                },
                "component_rendering_logic": {
                    "conditional_rendering": "Component shows different content based on system state and user role",
                    "admin_users": "See user stats + redemption stats (active) or user stats + setup metrics (inactive)",
                    "regular_users": "See user stats + personal redemption stats (active) or user stats + system status (inactive)",
                    "testing_approach": "Test both active and inactive system scenarios with appropriate mock data"
                },
                "icon_color_testing": {
                    "shield_check_icons": "Test that shield check icons show correct colors based on system state",
                    "active_system": "Green icons (text-green-500) for active systems",
                    "inactive_system": "Red icons (text-red-500) for inactive systems",
                    "testing_approach": "Update test expectations to match actual component behavior"
                },
                "dark_mode_class_testing": {
                    "css_class_updates": "Test that dark mode classes are applied correctly after component changes",
                    "class_verification": "Verify that dark:bg-gray-800, dark:bg-gray-900, and dark:bg-white/10 classes exist",
                    "testing_approach": "Update test expectations to match actual CSS classes used in component"
                },
                "card_count_testing": {
                    "dynamic_card_counts": "Test that correct number of cards are displayed based on system state",
                    "active_system": "User stats + redemption stats + individual reward cards",
                    "inactive_system": "User stats + setup metrics (business setup, system status, etc.)",
                    "testing_approach": "Update test expectations to match actual card counts for each scenario"
                }
            },
            "frontend_test_systematic_fixing": {
                "identify_failures": "Run full test suite to identify all failing tests",
                "categorize_issues": "Group similar issues together (component logic, mock data, assertions)",
                "fix_systematically": "Fix one category at a time, verify before moving to next",
                "comprehensive_verification": "Run complete test suite after all fixes to ensure success",
                "update_patterns": {
                    "mock_data_updates": "Update mock data to reflect new component behavior",
                    "assertion_updates": "Update test assertions to match new component structure",
                    "icon_color_fixes": "Update icon color expectations to match actual component behavior",
                    "card_count_fixes": "Update card count expectations to match new rendering logic"
                }
            },
            "component_architecture_lessons": {
                "single_responsibility": "Each component should handle one specific responsibility",
                "parent_child_separation": "Use parent components for data management, child components for display",
                "prop_design": "Design props for single items (item: Object), not collections (items: Array)",
                "testing_approach": "Test components with single item props and verify parent-child interaction"
            },
            "dashboard_statistics_display": {
                "active_system_display": "Show user stats + redemption statistics for active systems",
                "inactive_system_display": "Show user stats + setup metrics for inactive systems",
                "user_role_differentiation": "Admin users see system-wide stats, regular users see personal stats",
                "testing_approach": "Test both active and inactive system scenarios with appropriate mock data"
            },
            "redemption_statistics_implementation": {
                "backend_calculation": "Calculate redemption statistics from all active rewards",
                "frontend_display": "Display total redemptions and individual reward breakdowns",
                "user_specific_stats": "Show personal redemption statistics for regular users",
                "testing_approach": "Test that statistics are calculated correctly and displayed appropriately"
            },
            "type_safety_lessons": {
                "database_string_conversion": "Convert database string values to numbers before calling .toFixed()",
                "frontend_type_safety": "Use Number() constructor to convert strings to numbers",
                "testing_approach": "Test that string values from database are handled correctly in frontend"
            },
            "caching_issues_lessons": {
                "cache_clearing": "Clear all Laravel caches when code changes don't take effect",
                "cache_commands": "Use php artisan cache:clear, config:clear, route:clear, view:clear",
                "verification": "Verify that code changes are actually being executed",
                "testing_approach": "Test that changes are applied correctly after cache clearing"
            },
            "server_validation_patterns": {
                "jetstream_flash_structure": "CRITICAL: Laravel Jetstream uses nested flash structure - read from page.props.jetstream.flash, not page.props.flash",
                "controller_responses": "Use back() helper function for Inertia responses. NEVER use Inertia::back() - it doesn't exist",
                "flash_message_setting": "Controller: session()->flash('flash.banner', 'message'), session()->flash('flash.bannerStyle', 'success' or 'danger')",
                "visual_feedback_testing": "Always test CSS classes for borders (border-green-300 for success, border-red-300 for error)",
                "server_validation_flow": "User types \u2192 debounce (750ms) \u2192 router.post('/check-email-or-phone') \u2192 controller returns back() \u2192 component reads jetstream flash \u2192 sets CSS classes",
                "validation_mode_isolation": "Test that server-only mode triggers server validation, client mode does not (performance optimization)",
                "missing_data_handling": "Test scenarios where flash messages are missing - component should handle gracefully without crashing",
                "component_reading": "Component reads: page.props.jetstream?.flash?.banner and page.props.jetstream?.flash?.bannerStyle",
                "border_styling_logic": "Green: validationMode === 'server-only' && serverSuccess, Red: emailError || serverError"
            },
            "profile_switching_patterns": {
                "switching_detection": {
                    "parent_tracking": "Track originalInputType and currentInputType in parent component",
                    "child_events": "Child component emits type-change event with new input data",
                    "detection_logic": "Compare originalInputType.isPhone with currentInputType.isEmail",
                    "example": "isSwitchingFromPhoneToEmail = originalInputType.isPhone && currentInputType.isEmail"
                },
                "conditional_ui_messages": {
                    "visibility_condition": "isSwitchingFromPhoneToEmail && !hasFormBeenSubmitted",
                    "message_content": "Include dynamic data like originalPhoneNumber",
                    "styling": "Use consistent colors and icons for user guidance",
                    "example": "\ud83d\udca1 Your current password is your mobile number: +15551234567"
                },
                "form_prepopulation": {
                    "trigger": "Watch for switching condition changes",
                    "fields_to_populate": ["current_password", "email", "name"],
                    "data_sources": [
                        "originalPhoneNumber",
                        "currentInputType.email",
                        "user.name"
                    ],
                    "example": "form.current_password = props.originalPhoneNumber"
                },
                "route_selection_logic": {
                    "password_updates": "Always use user-password.update route",
                    "profile_updates": "Use user-profile-information.update route",
                    "switching_logic": "Include email/name in password route when switching",
                    "benefit": "Ensures proper validation and processing for each operation type"
                },
                "authentication_preservation": {
                    "session_regeneration": "Use request()->session()->regenerate() when email field changes",
                    "testing_approach": "Test that Auth::check() remains true after profile updates",
                    "logout_prevention": "Avoid router.reload() calls that cause session invalidation",
                    "backend_implementation": "Add session regeneration to UpdateUserProfileInformation action"
                }
            },
            "logout_prevention_patterns": {
                "avoid_router_reload": {
                    "problem": "router.reload() causes logout and session invalidation",
                    "solution": "Remove router.reload() calls from form submissions",
                    "alternative": "Let user data update on next navigation",
                    "benefit": "Maintains authentication state"
                },
                "session_regeneration": {
                    "trigger": "When switching between email and phone",
                    "implementation": "request()->session()->regenerate() in backend",
                    "placement": "After user->forceFill($updateData)->save()",
                    "benefit": "Prevents logout when email field changes"
                },
                "form_state_management": {
                    "implementation": "hasFormBeenSubmitted ref",
                    "usage": "Hide conditional messages after form submission",
                    "benefit": "Clean UI state management"
                },
                "testing_authentication": {
                    "test_auth_state": "Always test Auth::check() remains true after profile updates",
                    "test_no_logout": "Verify user stays authenticated when switching email/phone",
                    "test_session_preservation": "Ensure session is maintained after profile changes"
                }
            }
        },
        "testing_commands": {
            "backend": {
                "all": "php artisan test",
                "file": "php artisan test tests/Feature/ExampleTest.php",
                "method": "php artisan test --filter=test_method_name",
                "coverage": "php artisan test --coverage",
                "integration": "php artisan test --group=integration",
                "stop_on_failure": "php artisan test --stop-on-failure",
                "specific_class": "php artisan test --filter=TestClassName"
            },
            "frontend": {
                "all": "npm test",
                "watch": "npm run test:watch",
                "file": "npm test -- tests/Unit/pages/ExampleTest.spec.js"
            },
            "browser": {
                "dusk": "./scripts/run-dusk.sh",
                "manual": "php artisan dusk --env=dusk.local"
            }
        },
        "environment_setup": {
            "testing_database": {
                "connection": "DB_CONNECTION=sqlite",
                "database": "DB_DATABASE=database/testing.sqlite"
            },
            "integration_tests": {
                "enable": "RUN_INTEGRATION_TESTS=1",
                "twilio": "TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN"
            }
        },
        "image_storage_migration": {
            "storage_link_to_public": "Migrate from storage:link to direct public/images access",
            "model_url_updates": "Update model URL attributes to use asset('images/') instead of Storage::url()",
            "controller_upload_changes": "Update controllers to save files directly to public/images instead of storage/app/public",
            "test_updates": "Update all tests to check file_exists(public_path()) instead of Storage::disk('public')->exists()",
            "url_structure_changes": "Change from /storage/rewards/image.jpg to /images/rewards/image.jpg",
            "file_cleanup": "Remove old storage directories and symbolic links after migration",
            "basename_usage": "Use basename() to extract filename from stored path for URL generation",
            "directory_structure": "Create public/images/rewards/, public/images/logos/, public/images/favicons/ directories",
            "controller_file_handling": "Use $file->move(public_path('images/rewards'), $filename) instead of Storage::disk('public')->store()",
            "test_assertion_updates": "Update test assertions to check for timestamped filenames instead of hashName()",
            "model_import_cleanup": "Remove Storage facade imports from models when no longer needed",
            "url_generation_patterns": "Use asset('images/rewards/' . basename($this->image_path)) for consistent URL generation",
            "global_data_sharing": "Business logo and favicon URLs are shared globally through HandleInertiaRequests middleware",
            "authentication_pages": "Login and Register pages automatically use business logo and favicon from public/images folder"
        }
    },
    "laravel_cloud_object_storage_testing": {
        "description": "Testing patterns for Laravel Cloud Object Storage (R2) implementation",
        "storage_fake_patterns": {
            "setup": "Storage::fake('public') in setUp() method for testing",
            "service_instantiation": "new ImageUploadService('public') for test environment",
            "assertions": [
                "Storage::disk('public')->assertExists('logos/company-logo.png')",
                "Storage::disk('public')->assertMissing('logos/old-logo.png')",
                "assertStringContainsString('/storage/', $url)",
                "assertEquals('logos/company-logo.png', $result)"
            ],
            "no_cleanup": "Storage::fake() automatically handles cleanup"
        },
        "service_testing_patterns": {
            "filename_preservation": "Test that original filenames are preserved during upload",
            "conflict_handling": "Test filename conflicts with number suffixes (logo-1.png, logo-2.png)",
            "sanitization": "Test special character removal and filename sanitization",
            "url_generation": "Test URL generation with Storage::disk()->url() for different disks",
            "temporary_urls": "Test temporary URL generation for private buckets with expiration"
        },
        "model_testing_patterns": {
            "url_attribute_testing": "Test model URL attributes for different disk configurations",
            "private_bucket_detection": "Test private bucket detection and temporary URL generation",
            "fallback_handling": "Test fallback behavior when image paths are null or empty",
            "basename_usage": "Test basename() extraction for URL generation"
        },
        "controller_testing_patterns": {
            "disk_configuration": "Test controller uses correct disk configuration",
            "service_integration": "Test ImageUploadService integration in controllers",
            "old_file_cleanup": "Test old file deletion when updating images",
            "validation_integration": "Test file validation integration with Form Requests"
        },
        "cloud_storage_testing": {
            "r2_configuration": "Test R2 disk configuration and environment variables",
            "s3_compatibility": "Test S3-compatible settings for R2 storage",
            "environment_variables": "Test automatic environment variable injection",
            "cors_policy": "Test CORS policy management for cloud storage"
        }
    },
    "inertia_v2_advanced_testing": {
        "description": "Testing patterns for Inertia v2 advanced features including InfiniteScroll",
        "infinite_scroll_testing": {
            "pagination_metadata": "Test that pagination metadata (current_page, last_page, per_page, total) is included",
            "data_appending": "Test that new data is appended instead of replacing existing data",
            "loading_states": "Test loading indicators and end-of-list messages",
            "intersection_observer": "Test IntersectionObserver behavior for automatic loading",
            "scroll_behavior": "Test smooth scrolling and scroll position management"
        },
        "inertia_scroll_testing": {
            "scroll_response": "Test Inertia::scroll() responses with proper data structure",
            "pagination_integration": "Test pagination integration with Inertia::scroll()",
            "search_integration": "Test search functionality combined with infinite scroll",
            "performance_testing": "Test with large datasets (50+ records) for realistic scenarios"
        },
        "frontend_infinite_scroll_testing": {
            "component_rendering": "Test InfiniteScroll component renders correctly",
            "data_binding": "Test proper data binding to InfiniteScroll component",
            "loading_templates": "Test loading and end-of-list templates",
            "responsive_behavior": "Test infinite scroll behavior on different screen sizes",
            "scroll_position": "Test scroll position management during loading"
        },
        "backend_pagination_testing": {
            "controller_structure": "Test controller returns proper pagination structure",
            "query_efficiency": "Test efficient queries for large datasets",
            "search_pagination": "Test search functionality with pagination",
            "metadata_completeness": "Test all pagination metadata is included in responses"
        }
    },
    "search_functionality_testing": {
        "description": "Testing patterns for comprehensive search functionality with debouncing",
        "search_backend_testing": {
            "form_request_validation": "Test SearchUsersRequest validation rules",
            "query_building": "Test conditional query building with when() method",
            "search_scope": "Test search scope with OR conditions for multiple fields",
            "case_insensitive_search": "Test case-insensitive search implementation",
            "pagination_maintenance": "Test pagination state maintenance with search results"
        },
        "search_frontend_testing": {
            "debounced_input": "Test debounced search input with proper cleanup",
            "search_state_management": "Test search query state management",
            "empty_state_ui": "Test empty state messages and clear search functionality",
            "responsive_layout": "Test responsive search layout and button positioning",
            "input_validation": "Test search input validation and sanitization"
        },
        "search_integration_testing": {
            "search_pagination": "Test search functionality with pagination",
            "infinite_scroll_search": "Test search combined with infinite scroll",
            "url_preservation": "Test search parameters preserved in pagination URLs",
            "performance_testing": "Test search performance with large datasets",
            "real_time_search": "Test real-time search with debouncing"
        },
        "search_ui_testing": {
            "search_layout": "Test flex justify-between layout for search and buttons",
            "responsive_design": "Test responsive stacking on mobile vs inline on desktop",
            "input_styling": "Test consistent input styling with focus states",
            "button_positioning": "Test proper button positioning relative to search input",
            "empty_state_messaging": "Test meaningful empty state messages with clear search button"
        }
    },
    "ui_enhancement_testing": {
        "description": "Testing patterns for modern UI enhancements including floating buttons",
        "floating_button_testing": {
            "visibility_conditions": "Test floating button visibility based on scroll position and data conditions",
            "smooth_scrolling": "Test smooth scrolling behavior when button is clicked",
            "transition_effects": "Test opacity, translate, and scale transition effects",
            "positioning": "Test fixed positioning and z-index for proper layering",
            "accessibility": "Test proper titles, ARIA labels, and keyboard navigation"
        },
        "scroll_detection_testing": {
            "scroll_threshold": "Test scroll threshold detection (e.g., 200px)",
            "event_listener_management": "Test proper add/remove of scroll event listeners",
            "conditional_logic": "Test combination of scroll position and data conditions",
            "performance": "Test scroll event handling performance"
        },
        "transition_testing": {
            "vue_transitions": "Test Vue Transition component with proper enter/leave classes",
            "css_transitions": "Test CSS transition effects for smooth animations",
            "animation_timing": "Test animation timing and easing functions",
            "accessibility": "Test respect for user's motion preferences"
        },
        "responsive_design_testing": {
            "mobile_first": "Test mobile-first design approach",
            "responsive_layouts": "Test flex-col sm:flex-row responsive stacking",
            "touch_targets": "Test appropriate sizing for mobile touch targets",
            "breakpoint_testing": "Test layouts on different screen sizes and orientations",
            "consistent_spacing": "Test consistent spacing patterns across breakpoints"
        }
    },
    "advanced_feature_testing": {
        "description": "Testing patterns for advanced features and performance optimization",
        "performance_testing": {
            "large_dataset_testing": "Test with 50+ records for realistic performance scenarios",
            "scroll_performance": "Test smooth scrolling performance with large datasets",
            "search_performance": "Test search performance with large user bases",
            "infinite_scroll_performance": "Test infinite scroll performance with continuous loading",
            "memory_usage": "Test memory usage during long scrolling sessions"
        },
        "integration_testing": {
            "search_infinite_scroll": "Test search functionality integrated with infinite scroll",
            "floating_button_scroll": "Test floating button behavior during infinite scroll",
            "responsive_features": "Test responsive behavior across all advanced features",
            "end_to_end": "Test complete user workflows with all features combined"
        },
        "accessibility_testing": {
            "keyboard_navigation": "Test keyboard navigation for all interactive elements",
            "screen_reader": "Test screen reader compatibility for dynamic content",
            "motion_preferences": "Test respect for user's motion preferences",
            "focus_management": "Test proper focus management during dynamic content loading",
            "aria_labels": "Test proper ARIA labels and descriptions"
        },
        "error_handling_testing": {
            "network_errors": "Test handling of network errors during infinite scroll",
            "search_errors": "Test handling of search errors and timeouts",
            "empty_states": "Test proper empty state handling for all features",
            "fallback_behavior": "Test fallback behavior when advanced features fail",
            "graceful_degradation": "Test graceful degradation for unsupported browsers"
        }
    },
    "route_security_testing": {
        "description": "Testing patterns for route security with proper middleware combinations",
        "middleware_combination_testing": {
            "guest_access_testing": {
                "expectation": "Guest users should be redirected to login, not get 403 errors",
                "test_pattern": "Expect assertRedirect('/login') for guest users",
                "middleware_requirement": "Use ['auth:sanctum', 'verified', 'can:admin'] for proper guest handling",
                "never_can_admin_alone": "Never use can:admin alone as it causes 403 for guests"
            },
            "admin_access_testing": {
                "expectation": "Admin users should have successful access to admin routes",
                "test_pattern": "Expect successful operations for admin users",
                "user_setup": "Create admin user with admin: true for testing",
                "authorization_testing": "Test that admin gate works correctly"
            },
            "non_admin_access_testing": {
                "expectation": "Authenticated non-admin users should get 403 Forbidden",
                "test_pattern": "Expect 403 Forbidden for authenticated non-admin users",
                "user_setup": "Create regular user with admin: false for testing",
                "middleware_testing": "Test all middleware combinations properly"
            }
        },
        "data_structure_consistency_testing": {
            "backend_frontend_alignment": {
                "principle": "Backend must return exact structure expected by frontend",
                "testing_approach": "Test that controller returns proper data structure",
                "pagination_testing": "Test pagination metadata separately from data",
                "array_vs_object": "Test flattened arrays vs objects with data property"
            },
            "controller_response_testing": {
                "structure_verification": "Test that controllers return consistent data structures",
                "frontend_compatibility": "Ensure data structure matches frontend component props",
                "test_updates": "Update test assertions when changing data structures",
                "data_flow_testing": "Test complete data flow from backend to frontend"
            }
        }
    },
    "table_column_testing_patterns": {
        "description": "Testing table columns in Vue/Inertia pages - both backend and frontend",
        "backend_testing": {
            "description": "Testing that table column data is included in Inertia responses",
            "pattern": {
                "verify_data_structure": "$response->assertInertia(fn (Assert $page) => $page->has('users.0.outstanding_balance')->where('users.0.outstanding_balance', 500))",
                "verify_formatting": "Extract page data and verify values are correctly converted from smallest currency unit to main currency unit",
                "verify_multiple_users": "Test with multiple users having different values (positive, zero, undefined) to ensure all cases are handled"
            },
            "example": {
                "test_name": "it('includes outstanding_balance in users index response')",
                "setup": "Create users with credit accounts having different outstanding_balance values",
                "assertion": "$response->assertInertia(fn (Assert $page) => $page->has('users.0.outstanding_balance')->where('users.0.outstanding_balance', 500))",
                "currency_conversion": "Verify values are converted from smallest unit (paisa) to main unit (INR) using CurrencyService"
            },
            "key_points": [
                "Always verify data structure with assertInertia()",
                "Test currency conversion from smallest unit to main unit",
                "Test edge cases: positive values, zero, undefined/null",
                "Use collect() to find users by name when order is not guaranteed"
            ]
        },
        "frontend_testing": {
            "description": "Testing table column display, styling, and formatting in Vue components",
            "component_stubs": {
                "description": "Complex Vue pages require extensive component stubbing",
                "pattern": {
                    "extract_shared_stubs": "Create componentStubs constant with all required stubs to avoid duplication",
                    "required_stubs": [
                        "AppLayout (with template and props)",
                        "All child components (VoiceSearchButton, Modals, Forms, etc.)",
                        "UI components (Button, Input, Select, etc.)",
                        "Inertia components (Head, Link)",
                        "HeadlessUI components (Dialog, DialogPanel, etc.)"
                    ]
                },
                "example": {
                    "shared_stubs": "const componentStubs = { AppLayout: { template: '<div><slot /></div>', props: ['breadcrumbs'] }, VoiceSearchButton: true, ... };",
                    "usage": "mount(Component, { global: { stubs: componentStubs } })"
                }
            },
            "table_column_tests": {
                "column_header": {
                    "description": "Test that column header is displayed in correct position",
                    "pattern": "const headers = wrapper.findAll('thead th'); expect(headers[0].text()).toContain('outstanding_balance');"
                },
                "column_cells": {
                    "description": "Test that column cells display correct values",
                    "pattern": "const rows = wrapper.findAll('tbody tr'); const firstRowCells = rows[0].findAll('td'); expect(firstRowCells[0].text()).toContain('1,234.56');"
                },
                "conditional_styling": {
                    "description": "Test conditional CSS classes based on values",
                    "pattern": "const yellowSpan = firstCell.find('span.text-yellow-600'); expect(yellowSpan.exists()).toBe(true);",
                    "when_to_test": "Test yellow color when value > 0, gray color when value is 0"
                },
                "formatting": {
                    "description": "Test currency symbol and number formatting",
                    "pattern": "expect(text).toContain(''); expect(text).toContain('1,234.56');",
                    "edge_cases": "Test undefined/null values display '', zero values display formatted '0.00'"
                }
            },
            "key_points": [
                "Extract shared component stubs to reduce duplication",
                "Test column position (first, last, specific index)",
                "Test conditional styling (yellow for > 0, gray for 0)",
                "Test formatting (currency symbols, commas, decimals)",
                "Test edge cases (undefined, null, zero values)"
            ]
        },
        "table_column_implementation": {
            "description": "Adding new columns to existing tables",
            "steps": {
                "1": "Add <th> header element in <thead> with translation key",
                "2": "Add <td> cell element in <tbody> with formatted value",
                "3": "Update colspan in empty state row to account for new column",
                "4": "Use flex layout with items-center for vertical alignment",
                "5": "Apply conditional styling based on values (e.g., yellow when > 0)"
            },
            "formatting_pattern": {
                "currency_symbol": "Use getCurrencySymbol(user.currency_code || props.currency_code || 'INR')",
                "number_formatting": "Use formatMetricValue() or toLocaleString() for commas and decimals",
                "conditional_display": "Show '' when value is undefined or null"
            },
            "alignment_pattern": {
                "description": "Align table cells with other column content using flex layout",
                "pattern": "<div class=\"flex items-center\"><span :class=\"conditionalClasses\">{{ formattedValue }}</span></div>",
                "why": "Ensures vertical alignment with other column content (e.g., name with buttons)"
            }
        }
    },
    "frontend_test_component_mocking": {
        "link_component_requirement": {
            "description": "CRITICAL: All Inertia test mocks must include Link component when components use it",
            "problem": "Components using Link from @inertiajs/vue3 fail with 'No Link export is defined' error",
            "solution": {
                "include_in_all_mocks": "Always include Link component in ALL Inertia mocks, even if component doesn't currently use it",
                "mock_structure": "Link: { name: 'Link', props: ['href'], template: '<a :href=\"href\"><slot /></a>' }",
                "affected_files": "All test files that use components importing Link from @inertiajs/vue3"
            },
            "prevention": {
                "default_mock_template": "Include Link in all Inertia mocks by default as a best practice",
                "test_file_updates": "When adding Link to components, immediately update all related test mocks"
            },
            "benefits": [
                "Prevents test failures due to missing Link export",
                "Consistent mock structure across all test files",
                "Future-proofs tests when components start using Link"
            ]
        },
        "url_parameter_expectations": {
            "description": "Update test expectations when routes add query parameters",
            "problem": "Tests fail when routes add query parameters but test expectations don't include them",
            "solution": {
                "update_expectations": "Update test expectations to match actual URL format with query parameters",
                "example": "RewardIcon.test.js: Expect '/users/123/loyalty-cards?activecards=true' instead of '/users/123/loyalty-cards'",
                "route_changes": "When modifying routes to include query parameters, update all related test expectations"
            },
            "prevention": {
                "review_route_changes": "Review route changes and identify all affected test files",
                "update_systematically": "Update all related test expectations when routes change"
            }
        }
    },
    "frontend_test_expectation_patterns": {
        "description": "Frontend test expectation patterns for router.post calls and data structures",
        "router_post_call_testing": {
            "object_containing_pattern": {
                "principle": "Always use expect.objectContaining() for router.post calls",
                "reason": "Implementation includes onError/onSuccess callback functions",
                "pattern": "expect.objectContaining({ preserveScroll: true, preserveState: true })",
                "never_exact_matching": "Never use exact object matching as it fails with callbacks"
            },
            "preserve_state_testing": {
                "behavior_variation": "Some routes use preserveState: true, others don't include it",
                "testing_approach": "Match actual implementation behavior in tests",
                "preserve_scroll_consistency": "Most routes use preserveScroll: true consistently",
                "implementation_verification": "Verify actual router.post call parameters"
            },
            "callback_function_handling": {
                "onError_onSuccess": "Router.post calls include onError/onSuccess callback functions",
                "test_expectations": "Account for callback functions in test expectations",
                "flexible_matching": "Use expect.objectContaining() to match partial objects",
                "test_updates": "Update test expectations when implementation changes"
            }
        },
        "data_structure_testing_patterns": {
            "exact_structure_testing": {
                "principle": "Frontend expects specific data structure from backend",
                "testing_approach": "Test exact structure expected by frontend components",
                "pagination_separation": "Test pagination metadata separately from data",
                "array_vs_object_distinction": "Distinguish between arrays and objects with data property"
            },
            "controller_response_format": {
                "structure_consistency": "Ensure controller returns expected format",
                "frontend_compatibility": "Match data structure to component prop expectations",
                "test_assertion_updates": "Update test assertions when changing data structures",
                "data_flow_verification": "Test complete data flow from backend to frontend"
            }
        },
        "database_verification_patterns": {
            "description": "Always verify data is actually saved to database, not just in memory",
            "core_principles": {
                "dual_verification": "Use both Eloquent queries and raw database queries to verify persistence",
                "json_column_verification": "Query directly from database using DB::table() and json_decode() for JSON columns",
                "configuration_count_verification": "Assert only 1 active configuration exists after activation",
                "before_and_after_verification": "Verify data exists in database before AND after operations"
            },
            "implementation_patterns": {
                "eloquent_verification": {
                    "pattern": "Prefer scoped Eloquent queries for verification; only bypass scopes when intentionally testing cross-tenant behavior",
                    "example": "$dbConfiguration = StampCardConfiguration::query()->where('id', $configuration->id)->first(); $this->assertEquals([...], $dbConfiguration->reward_positions);"
                },
                "raw_database_verification": {
                    "pattern": "Use raw database queries to verify JSON columns and avoid model caching",
                    "example": "$rawDbConfig = DB::table('stamp_card_configurations')->where('id', $configuration->id)->first(); $decodedRewardPositions = json_decode($rawDbConfig->reward_positions, true); $this->assertEquals([...], $decodedRewardPositions);"
                },
                "configuration_count_verification": {
                    "pattern": "Assert only 1 active configuration exists to prevent duplicate configurations (prefer scoped queries)",
                    "example": "$activeConfigurationsCount = StampCardConfiguration::query()->where('is_active', true)->count(); $this->assertEquals(1, $activeConfigurationsCount);"
                },
                "total_count_verification": {
                    "pattern": "Verify total configuration count hasn't increased during activation (prefer scoped queries)",
                    "example": "$totalConfigurationsCount = StampCardConfiguration::query()->count(); $this->assertEquals(1, $totalConfigurationsCount);"
                }
            },
            "scope_notes": {
                "tenant_scope_default": "Tests should also trust BusinessScope by default; minimize withoutGlobalScopes() to intentional cross-tenant assertions only",
                "user_model_exception": "User model is not tenant-scoped; continue to filter by business_id explicitly in User tests when needed"
            },
            "testing_patterns": {
                "before_activation": "Verify reward_positions exist in database before activation",
                "after_activation": "Verify reward_positions exist in database after activation using both Eloquent and raw queries",
                "configuration_count": "Assert only 1 active configuration and 1 total configuration exists",
                "json_column_handling": "Use json_decode() to verify JSON columns from raw database queries"
            },
            "benefits": [
                "Catches data persistence issues early",
                "Verifies data is actually saved, not just in memory",
                "Prevents configuration duplication during activation",
                "Ensures JSON columns are properly stored and retrieved"
            ]
        },
        "configuration_update_preservation": {
            "description": "Testing patterns for configuration update field preservation",
            "core_principles": {
                "is_active_preservation": "Test that is_active is preserved when not provided in update request",
                "reward_positions_preservation": "Test that reward_positions are preserved when not provided or when empty array is sent",
                "both_preservation": "Test that both fields are preserved when neither is provided",
                "explicit_changes": "Test that both fields can still be changed when explicitly provided"
            },
            "test_patterns": {
                "preserve_is_active": {
                    "description": "Test that is_active is preserved when editing configuration without providing is_active",
                    "example": "Create active configuration, update with other fields but not is_active, verify is_active remains true"
                },
                "preserve_reward_positions": {
                    "description": "Test that reward_positions are preserved when not provided or empty array sent",
                    "example": "Create configuration with reward_positions, update with empty array, verify reward_positions preserved"
                },
                "preserve_both": {
                    "description": "Test that both is_active and reward_positions are preserved when neither is provided",
                    "example": "Create active configuration with reward_positions, update only stamps_per_card, verify both preserved"
                },
                "explicit_changes": {
                    "description": "Test that explicit changes to is_active and reward_positions work correctly",
                    "example": "Update with explicit is_active and reward_positions values, verify changes are applied"
                }
            },
            "assertion_patterns": {
                "eloquent_assertion": "$configuration->refresh(); $this->assertTrue($configuration->is_active);",
                "database_assertion": "$this->assertDatabaseHas('stamp_card_configurations', ['id' => $id, 'is_active' => 1]);",
                "json_column_assertion": "$this->assertEquals($expectedPositions, $configuration->reward_positions);"
            }
        },
        "configuration_deletion": {
            "description": "Testing patterns for configuration deletion",
            "core_principles": {
                "active_deletion": "Test that active configurations can be deleted",
                "inactive_deletion": "Test that inactive configurations can be deleted",
                "authorization": "Test that only admin users can delete configurations",
                "error_handling": "Test error handling when deletion fails"
            },
            "test_patterns": {
                "delete_active": "Test that active configuration can be deleted without restrictions",
                "delete_inactive": "Test that inactive configuration can be deleted",
                "authorization_check": "Test that non-admin users cannot delete configurations",
                "foreign_key_behavior": "Test that deletion sets related stamp cards' configuration_id to null"
            }
        },
        "reward_icon_logic": {
            "description": "Testing patterns for RewardIcon logic",
            "core_principles": {
                "zero_stamps": "Test that users with 0 stamps do NOT show reward icon",
                "below_threshold": "Test that cards below reward threshold do NOT show reward icon",
                "earned_rewards": "Test that users with earned, unredeemed rewards DO show reward icon",
                "multiple_configurations": "Test logic with multiple cards across different configurations"
            },
            "test_patterns": {
                "new_user_test": {
                    "description": "Test that newly created users with 0 stamps do not show reward icon",
                    "example": "Create user via POST, check /users page, verify has_redeemable_reward = false"
                },
                "below_threshold_test": {
                    "description": "Test that users with stamps below reward threshold do not show reward icon",
                    "example": "Add 2 stamps to card with reward at position 3, verify has_redeemable_reward = false"
                },
                "earned_reward_test": {
                    "description": "Test that users with earned, unredeemed rewards show reward icon",
                    "example": "Add 4 stamps to card with reward at position 3, verify has_redeemable_reward = true"
                },
                "multiple_configs_test": {
                    "description": "Test logic with multiple cards from different configurations",
                    "example": "Create old card with config1 (has unredeemed rewards), new card with config2 (no rewards), verify icon shows"
                }
            },
            "assertion_patterns": {
                "inertia_assertion": "$response->assertInertia(fn ($page) => $page->where('users', function ($users) { return collect($users)->firstWhere('id', $id)['has_redeemable_reward'] === false; }));",
                "view_data_assertion": "$usersData = $response->viewData('page')['props']['users']; $userEntry = collect($usersData)->firstWhere('id', $id); $this->assertFalse($userEntry['has_redeemable_reward']);"
            }
        },
        "stamp_card_configuration_types": {
            "description": "Testing patterns for stamp card configuration types - both types required",
            "core_requirement": "Both first_card_only and all_subsequent_cards configuration types must be active for StampCardService methods to work",
            "test_setup_patterns": {
                "create_both_types": {
                    "description": "Use createBothConfigurationTypes() helper to create both configuration types",
                    "pattern": "$configs = $this->createBothConfigurationTypes(['is_active' => true, 'stamps_per_card' => 10]); $configuration = $configs['all_subsequent_cards'];",
                    "helper_location": "tests/Traits/CreatesBusinessData.php",
                    "benefits": [
                        "Reduces duplication",
                        "Ensures both types are created",
                        "Consistent test setup"
                    ]
                },
                "business_program_activation": {
                    "description": "Activate business.loyalty_program_active for dashboard route tests",
                    "pattern": "$business = $this->setUpBusiness(); $business->loyalty_program_active = true; $business->save();",
                    "why": "Dashboard routes require business program to be active to show stamp cards and stats",
                    "test_requirements": [
                        "Dashboard route tests",
                        "Stats display tests",
                        "Stamp card display tests"
                    ]
                },
                "configuration_switching": {
                    "description": "Deactivate old configs before creating new ones when switching configurations",
                    "pattern": "StampCardConfiguration::where('business_id', $business->id)->update(['is_active' => false]); $configs = $this->createBothConfigurationTypes(['is_active' => true]);",
                    "why": "Prevents conflicts and ensures getActiveConfiguration() returns the correct configuration"
                }
            },
            "reward_creation_patterns": {
                "fixed_type": {
                    "description": "Fixed type rewards must include type, cost_price, and selling_price",
                    "pattern": "$reward = $this->createReward(['name' => 'Free Coffee', 'type' => 'fixed', 'cost_price' => 2.50, 'selling_price' => 4.99]);",
                    "required_fields": ["type", "cost_price", "selling_price"]
                },
                "percentage_type": {
                    "description": "Percentage type rewards must include type and percentage",
                    "pattern": "$reward = $this->createReward(['name' => '10% Off', 'type' => 'percentage', 'percentage' => 10]);",
                    "required_fields": ["type", "percentage"]
                },
                "configuration_binding": {
                    "description": "Include configuration_id when creating or updating rewards so default imagery aligns with the selected setup configuration.",
                    "pattern": "$response = $this->post(route('rewards.store'), ['name' => 'Free Coffee', 'type' => 'fixed', 'cost_price' => '2.50', 'selling_price' => '4.99', 'configuration_id' => $configuration->id]);",
                    "assertion": "$this->assertEquals($configuration->id, Reward::where('name', 'Free Coffee')->first()->configuration_id);"
                },
                "common_mistake": "Creating rewards without type or pricing fields - will fail validation"
            },
            "stamp_card_creation_patterns": {
                "include_configuration_id": {
                    "description": "Always include configuration_id when creating stamp cards in tests",
                    "pattern": "$stampCard = $this->createStampCard(['user_id' => $user->id, 'configuration_id' => $configs['all_subsequent_cards']->id, 'current_stamps' => 5, 'total_stamps' => 10]);",
                    "why": "Links stamp card to correct configuration for position validation and display"
                }
            },
            "pivot_table_patterns": {
                "include_business_id": {
                    "description": "Always include business_id in attach() calls for stamp_cards_rewards pivot table",
                    "pattern": "$stampCard->rewards()->attach($rewardId, ['business_id' => $stampCard->business_id, 'reward_position' => $position, 'selling_price' => $reward->selling_price, 'cost_price' => $reward->cost_price, 'is_redeemed' => false]);",
                    "why": "business_id is required in pivot table and will cause SQL error if missing"
                },
                "include_pricing": {
                    "description": "Include selling_price and cost_price for historical tracking",
                    "pattern": "['business_id' => $stampCard->business_id, 'selling_price' => $reward->selling_price, 'cost_price' => $reward->cost_price]",
                    "why": "Historical pricing data is stored in pivot table at redemption time for stats calculations"
                }
            },
            "configuration_update_patterns": {
                "include_type_field": {
                    "description": "Always include type field in PUT requests when updating stamp card configurations",
                    "pattern": "$this->put('/stamp-card-configuration/'.$id, ['type' => 'all_subsequent_cards', 'stamps_per_card' => 10, ...]);",
                    "why": "Type field is required for validation and proper configuration management"
                },
                "activate_both_types": {
                    "description": "When activating configurations, activate both types",
                    "pattern": "Activate first_card_only config, then activate all_subsequent_cards config",
                    "why": "Both types must be active for system to be considered active"
                }
            },
            "common_test_failures": {
                "createStampCardForUser_returns_null": {
                    "cause": "Both configuration types not created or not active",
                    "fix": "Use createBothConfigurationTypes() helper and ensure both are active"
                },
                "dashboard_route_missing_stampCards": {
                    "cause": "business.loyalty_program_active not set to true",
                    "fix": "Activate business program: $business->loyalty_program_active = true; $business->save();"
                },
                "reward_validation_fails": {
                    "cause": "Missing type, cost_price, selling_price (for fixed) or percentage (for percentage)",
                    "fix": "Include all required fields in reward creation"
                },
                "pivot_table_sql_error": {
                    "cause": "Missing business_id in attach() call",
                    "fix": "Include business_id in pivot data: ['business_id' => $stampCard->business_id, ...]"
                },
                "configuration_update_fails": {
                    "cause": "Missing type field in PUT request",
                    "fix": "Include type field: ['type' => 'all_subsequent_cards', ...]"
                }
            },
            "systematic_fix_approach": {
                "step_1": "Identify all failing tests related to stamp card creation or configuration",
                "step_2": "Ensure both configuration types are created using createBothConfigurationTypes()",
                "step_3": "Activate business.loyalty_program_active for dashboard route tests",
                "step_4": "Add type, cost_price, selling_price to reward creation",
                "step_5": "Add configuration_id to stamp card creation",
                "step_6": "Add business_id to pivot table attachments",
                "step_7": "Add type field to configuration update requests",
                "step_8": "Run tests and verify fixes"
            }
        }
    },
    "email_testing_patterns": {
        "queued_email_testing": {
            "description": "Testing queued emails with PDF attachments and service resolution",
            "key_considerations": {
                "service_injection": "Never inject services into queued mailable constructors - causes serialization failures",
                "closure_attachments": "Always use closures for Attachment::fromData() in queued emails",
                "container_resolution": "Resolve services from container inside closures using app(Service::class)"
            },
            "correct_pattern": {
                "mailable_constructor": "public function __construct(public User $user, public string $version) {}",
                "attachments_method": "Attachment::fromData(fn () => app(PolicyVersionService::class)->generatePdf(), 'file.pdf')",
                "why": "Services resolved fresh when job runs, closures serialize properly"
            },
            "incorrect_pattern": {
                "mailable_constructor": "public function __construct(private readonly PolicyVersionService $service) {}",
                "attachments_method": "$pdf = $this->service->generatePdf(); Attachment::fromData($pdf, 'file.pdf')",
                "error": "Serialization fails or TypeError: Argument #1 must be of type Closure"
            },
            "testing_approach": {
                "fake_mail": "Use Mail::fake() to prevent actual email sending",
                "assert_sent": "Mail::assertSent(MailableClass::class, function ($mail) { return $mail->hasTo($user->email); })",
                "test_attachments": "Verify attachments are generated correctly in closures",
                "test_queue": "Test that emails are properly queued when ShouldQueue is implemented"
            }
        },
        "email_template_testing": {
            "description": "Testing email templates without Laravel mail components",
            "template_pattern": {
                "use_plain_html": "Use plain HTML with inline CSS instead of @component('mail::button')",
                "why": "Laravel mail components require published views, plain HTML works everywhere",
                "example": "<a href=\"{{ $url }}\" class=\"button\" style=\"display: inline-block; padding: 12px 24px; ...\">View Policy</a>"
            },
            "testing_approach": {
                "render_view": "Test that email views render without errors",
                "verify_content": "Assert email content includes expected text and links",
                "test_variables": "Verify all template variables are properly passed"
            }
        },
        "policy_version_email_testing": {
            "description": "Testing policy version change notifications and registration confirmation emails",
            "test_scenarios": {
                "registration_email": "Test that registration confirmation email is sent with PDF attachments",
                "version_change_notification": "Test that users are notified when policy versions change",
                "version_update": "Test that user versions are updated only after successful email delivery",
                "dry_run_mode": "Test console command dry-run mode to preview notifications"
            },
            "assertions": {
                "email_sent": "Mail::assertSent(RegistrationConfirmationMail::class)",
                "pdf_attachments": "Verify PDFs are generated and attached correctly",
                "version_stored": "Assert user's policy versions are stored correctly",
                "version_updated": "Assert versions are updated after successful notification"
            }
        },
        "frontend_watcher_testing": {
            "description": "Testing Vue components with watchers and async operations",
            "challenge": "Watchers react to prop changes and perform async operations, requiring proper test setup",
            "pattern": {
                "setup": [
                    "Mount component with initial props (often empty/initial state)",
                    "Set internal state flags that watcher checks (e.g., isWaitingForVoiceSearch = true)",
                    "Set pending values that watcher uses (e.g., pendingVoiceTranscript = 'value')"
                ],
                "trigger": [
                    "Wait for initial state with $nextTick()",
                    "Update props to trigger watcher (e.g., setProps({ users: newUsers }))"
                ],
                "assert": [
                    "Wait for watcher processing with multiple $nextTick() calls",
                    "If watcher calls functions with nextTick(), add extra $nextTick() calls",
                    "Assert expected state changes"
                ]
            },
            "code_example": {
                "setup": "const vm = wrapper.vm; vm.isWaitingForVoiceSearch = true; vm.pendingVoiceTranscript = 'ashwin';",
                "trigger": "await wrapper.vm.$nextTick(); await wrapper.setProps({ users: multipleMatchUsers });",
                "assert": "await wrapper.vm.$nextTick(); await wrapper.vm.$nextTick(); expect(vm.showVoiceUserSelectionModal).toBe(true);"
            },
            "common_pitfalls": {
                "watcher_not_triggering": "Internal state not set before prop update - watcher checks internal state first",
                "async_not_complete": "Not enough $nextTick() calls - watcher or functions it calls use nextTick()",
                "stub_errors": "Component stubs with just 'true' don't handle object props - causes primitive conversion errors"
            }
        },
        "headlessui_combobox_testing": {
            "description": "Testing HeadlessUI Combobox components with clear button functionality",
            "component_structure": {
                "combobox_components": "Combobox, ComboboxInput, ComboboxButton, ComboboxOptions, ComboboxOption, Transition",
                "clear_button": "X button for clearing search input, always visible (not conditional)",
                "input_clearing": "Clear both reactive ref (query.value) and DOM element value",
                "event_sync": "Dispatch input and change events to sync with HeadlessUI internal state",
                "focus_after_clear": "Focus input field after clearing for better UX"
            },
            "testing_patterns": {
                "clear_button_visibility": "Test that X button always exists: expect(wrapper.find('[data-testid=clear-search-button]').exists()).toBe(true)",
                "clear_functionality": "Test query clearing: vm.query = 'test'; await clearButton.trigger('click'); expect(vm.query).toBe('')",
                "stub_definition": "ComboboxInput: { template: '<input />', props: ['displayValue', 'placeholder', 'id'], emits: ['change', 'input'] }",
                "event_handling": "Mock both @change and @input events in ComboboxInput stub"
            },
            "key_lessons": [
                "ALWAYS test clear button visibility (should always be visible, not conditional)",
                "ALWAYS test that clicking clear button resets query ref",
                "ALWAYS mock ComboboxInput with proper event handlers (@change, @input)",
                "ALWAYS use data-testid for clear button to enable reliable testing",
                "ALWAYS verify input clearing works (may require browser testing for DOM manipulation)"
            ],
            "code_example": {
                "clear_button_test": "it('clears the search query when clear button is clicked', async () => { const wrapper = mount(LanguageSelector, { global: { stubs: componentStubs } }); const vm = wrapper.vm; vm.query = 'test search'; await wrapper.vm.$nextTick(); const clearButton = wrapper.find('[data-testid=clear-search-button]'); await clearButton.trigger('click'); await wrapper.vm.$nextTick(); expect(vm.query).toBe(''); });"
            }
        },
        "component_stub_props": {
            "description": "Component stubs must properly accept props to avoid primitive conversion errors",
            "problem": "Stubs defined as just 'true' don't properly handle object props, causing 'Cannot convert object to primitive value' errors",
            "solution": {
                "pattern": "Define stubs with template and props array",
                "code_example": "DebitModal: { template: '<div data-testid=\"debit-modal\"></div>', props: ['isOpen', 'user', 'voiceMode', 'voiceButtonRef'] }",
                "why": "Vue tries to set object props as attributes when stub doesn't define props, causing conversion errors"
            },
            "best_practices": [
                "Always define props array for stubs that receive object props",
                "Include data-testid in template for easier component finding in tests",
                "Match actual component props in stub definition"
            ]
        }
    }
}
