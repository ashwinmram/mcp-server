{
    "meta": {
        "title": "AI Lessons Learned - Laravel Application",
        "version": "1.7",
        "last_updated": "2026-01-XX",
        "description": "Consolidated lessons learned from all AI development sessions",
        "total_sessions": 90,
        "categories": [
            "Component Architecture",
            "Testing Patterns",
            "Database & Backend",
            "Frontend Development",
            "Inertia.js & Routing",
            "Performance & Optimization",
            "Error Handling & Debugging",
            "User Experience",
            "Code Quality & Maintenance",
            "TypeScript Type Safety",
            "Console Statement Cleanup",
            "Authentication Styling",
            "Role-Based Access Control & Authentication Redirects",
            "Global Data Management",
            "Database Safety & Environment Management",
            "Frontend Test Warnings & Component Props",
            "Component Refactoring Tests",
            "Laravel Cloud Object Storage",
            "Inertia v2 Advanced Features",
            "Search & Pagination Patterns",
            "UI Enhancement Patterns",
            "Route Security & Middleware",
            "Frontend Test Expectations",
            "Multi-Tenant Architecture",
            "Error Handling & Banner Patterns",
            "Date Formatting Patterns",
            "Mobile-Responsive UI Patterns",
            "Frontend Test Component Mocking",
            "Session Storage Patterns",
            "Flash Message Behavior",
            "Configuration Activation Patterns",
            "Service Layer Separation",
            "Global Scope Query Patterns",
            "Package Source Code Study",
            "Foreign Key Constraints & Database Design",
            "Production Migration Management",
            "AssemblyAI Keyterms Implementation",
            "Context-Specific Confirmation Words",
            "Modal Microphone Cleanup",
            "AssemblyAI Audio Quality Optimization",
            "FeatureIcon Logic & Configuration Management",
            "Disabled Feature Behavior",
            "Feature Type Conditional Validation",
            "Historical Data & Stats Calculation",
            "LocalStorage UI State Persistence",
            "Action Validation & Configuration Independence",
            "Complex Component Testing Patterns",
            "Entity Configuration Types",
            "Email Validation in Edit Scenarios",
            "Email Notification Deduplication",
            "Vue 3 Script Tags & Structured Data",
            "Decorative Elements in Lists",
            "Multi-Tenant Unique Constraint Validation",
            "Tenant Selection & URL Query Parameters",
            "Modal Scroll Locking & Mobile UX",
            "Client-Side Image Compression",
            "Feature Default Imagery & Configuration Binding",
            "Advertising Consent & Script Injection",
            "Email Delivery & CID Embedding",
            "Laravel Cloud Disk Detection",
            "Email Logo Fallback Patterns",
            "PHP Enum Objects",
            "Business-Based Multi-Tenancy",
            "GDPR Compliance Patterns",
            "Currency Storage & Account Management",
            "Business Settings & Currency Management",
            "Help Page Documentation & Maintenance",
            "Password Reset Notification Customization",
            "Authentication Error Messages & Logout Redirects",
            "Payment Stats Calculation & Data Source Alignment",
            "Nullable Database Fields & Optional Form Fields",
            "Metrics Calculation from Transaction History",
            "Payment Button Disable Logic",
            "Payment Allocation from Transactions",
            "User Edit Modal Patterns - Role Radio Buttons & Status Toggle",
            "Superuser Pattern & Centralized Admin Checks",
            "PHP Variable Scoping & Enum Casting Bypass",
            "Currency Conversion Patterns & Debug Code Cleanup",
            "Translation Completeness & Language Reload",
            "SEO Optimization & Sitemap Management",
            "Clickable Metrics & Modal Details",
            "Route Model Binding Bypass Patterns",
            "JSON API Endpoints for Modals",
            "Scrollable Modal Patterns",
            "Clickable Metric Styling",
            "Table Column Testing & Implementation Patterns",
            "Voice Recognition Code Cleanup & Async Patterns",
            "Documentation & Home Page Updates",
            "Frontend Formatted String Parsing",
            "Account Inclusion in Payments & Metrics",
            "Voice Search Multiple Match Handling",
            "Frontend Testing Watcher Patterns",
            "Voice Recognition Confirmation Words and AssemblyAI Model Selection"
        ]
    },
    "component_architecture": {
        "singleton_pattern": {
            "description": "Global singletons for Tenant and Configuration models",
            "implementation_approaches": [
                "Service container bindings with app()->singleton()",
                "Service classes with static methods and caching",
                "Model static methods (getInstance, getActiveInstance)",
                "Global helper functions (tenant(), configuration())"
            ],
            "database_schema": {
                "no_foreign_keys": "Tenant and Configuration are global singletons",
                "no_tenant_id": "Configuration is global, not tied to specific tenant",
                "no_configuration_id": "All entities use the same global configuration"
            },
            "access_patterns": {
                "controllers": "Always use singleton methods instead of manual queries",
                "services": "Use singleton access patterns instead of foreign key relationships",
                "tests": "Use singleton methods in assertions and setup",
                "factories": "Don't create foreign key relationships for singleton models"
            },
            "advertising_consent_test_data": {
                "lesson": "Admin-visible sections guarded by advertising consent must receive production-like props in Vitest to render.",
                "key_points": [
                    "When mounting `Users.vue`, include an `advertising` payload that either sets `usersBanner.has_consent` true or marks `optOut.hasPaid` true; otherwise the admin table stays hidden.",
                    "Pass pagination metadata (`current_page`, `last_page`, `per_page`, `total`) because the component mirrors Inertia paginator objects before rendering rows.",
                    "Provide a `filters` object (at minimum `{ \"search\": \"\" }`) so watchers do not trigger unexpected router reloads during tests.",
                    "Centralize these props in helper factories to keep assertions consistent across Users page suites."
                ]
            }
        },
        "single_responsibility_principle": {
            "description": "Each component should handle one specific responsibility",
            "patterns": {
                "parent_child_separation": "Parent components handle data management, child components handle display",
                "prop_design": "Design props for single items (item: Object), not collections (items: Array)",
                "looping_patterns": "Use parent-level looping with single-item child components",
                "component_extraction": "Extract specific functionality to dedicated components"
            },
            "benefits": [
                "Easier testing and maintenance",
                "Better reusability",
                "Clearer separation of concerns",
                "Improved code organization"
            ]
        },
        "vue_component_patterns": {
            "prop_validation": {
                "optional_props": "Make props optional with default null to prevent stderr warnings",
                "conditional_rendering": "Use v-if guards to prevent rendering when props are null",
                "defensive_programming": "Add null checks in computed properties and functions"
            },
            "template_syntax": {
                "computed_properties": "Don't use .value on computed properties in templates (auto-unwrap)",
                "directive_cleanup": "Remove orphaned v-else directives when removing v-if elements",
                "single_root_element": "Use single root element for automatic attribute inheritance"
            },
            "component_looping": {
                "parent_looping": "Use v-for in parent component to create multiple child instances",
                "prop_passing": "Pass individual items and calculated values to child components",
                "spacing_management": "Handle spacing between components at parent level"
            }
        }
    },
    "testing_patterns": {
        "systematic_test_fixing": {
            "approach": "Identify \u2192 Categorize \u2192 Fix \u2192 Verify",
            "steps": [
                "Run full test suite to identify all failures",
                "Categorize issues by type (component logic, mock data, assertions)",
                "Fix one category at a time, verify before moving to next",
                "Run complete test suite after all fixes"
            ],
            "benefits": [
                "Prevents introducing new issues while fixing existing ones",
                "Ensures comprehensive resolution of all problems",
                "Provides clear verification of success"
            ]
        },
        "phpunit_12_modernization": {
            "attribute_syntax": "Use #[\\PHPUnit\\Framework\\Attributes\\Test] for all test methods",
            "benefits": [
                "Future-proof code",
                "No deprecation warnings",
                "Cleaner, more explicit syntax",
                "Better IDE support"
            ],
            "migration": "Replace @test doc-comment metadata with modern attributes"
        },
        "frontend_test_patterns": {
            "inertia_mocking": {
                "complete_mock": "Mock all Inertia exports including WhenVisible, Deferred",
                "usePage_structure": "Provide complete page props structure with auth, flash, etc.",
                "router_mocking": "Mock router methods (post, put, delete, get) with proper parameters"
            },
            "component_testing": {
                "single_component_focus": "Test individual components with specific props",
                "prop_validation": "Test components with various prop combinations",
                "behavior_testing": "Test component behavior, not implementation details"
            },
            "visual_testing": {
                "css_class_assertions": "Test that correct CSS classes are applied",
                "conditional_rendering": "Test both showing and hiding of conditional elements",
                "responsive_testing": "Test components on different screen sizes"
            },
            "use_page_mocking": {
                "lesson": "Whenever Vue components depend on usePage() data, update tests to provide a shared usePage mock instead of forcing props directly",
                "key_points": [
                    "Include brand and tenant props in the mock so favicon and layout logic have real data",
                    "Return the same mock router object that production code expects, including Link component definitions",
                    "Keep form state assertions against the shared mock to observe changes triggered inside the component",
                    "Provide a single shared usePage mock whenever AppLayout is part of the test render tree to eliminate 'No usePage export' and 'Invalid vnode type' warnings"
                ]
            }
        },
        "backend_test_patterns": {
            "route_response_types": {
                "internal_routes": "Use post() and assertRedirect() with assertSessionHas()",
                "external_routes": "Use postJson() and assertStatus() with assertJson()",
                "never_mix": "Don't use postJson() for internal routes or post() for external routes"
            },
            "database_testing": {
                "pivot_table_operations": "Use direct DB queries for pivot updates with unique constraints",
                "singleton_pattern": "Use singleton methods in assertions and setup",
                "foreign_key_handling": "Drop foreign key constraints before dropping columns"
            },
            "collection_ordering_assumptions": {
                "lesson": "When testing collections ordered by created_at DESC, the newest item is first, not the oldest",
                "problem": "Tests that assume array position matches expected state will fail when collections are ordered DESC",
                "solution": "Use firstWhere() or where() to find items by their properties (is_completed, quantity) rather than assuming array position",
                "pattern": "const incompleteItem = $items->firstWhere('is_completed', false); const completedItem = $items->firstWhere('is_completed', true);",
                "benefits": [
                    "Tests are resilient to ordering changes",
                    "Tests verify actual state rather than position assumptions",
                    "More maintainable when collection ordering logic changes"
                ],
                "related_patterns": [
                    "Use firstWhere() for property-based lookups in tests",
                    "Avoid index-based assertions unless order is explicitly deterministic",
                    "When order matters, document the expected ordering clearly"
                ]
            }
        },
        "conditional_testing": {
            "git_based_execution": {
                "purpose": "Skip expensive tests when file unchanged since last commit",
                "implementation": "Check git diff --name-only HEAD for file modifications",
                "fail_safe": "Run tests if git check fails to ensure nothing is missed",
                "benefits": "Significantly faster test runs when working on other parts of codebase"
            }
        }
    },
    "database_backend": {
        "foreign_key_constraints": {
            "description": "Foreign key constraint management for multi-tenant database design",
            "restrict_vs_set_null_vs_cascade": {
                "restrict": {
                    "description": "Prevents deletion of parent row if child rows exist - DELETE fails with error",
                    "use_case": "When child records must exist with parent",
                    "example": "Prevent user deletion if entities exist",
                    "laravel_syntax": "->restrictOnDelete()"
                },
                "set_null": {
                    "description": "Allows deletion of parent row - automatically sets foreign key column in child rows to NULL",
                    "use_case": "When you want to allow deletion but preserve child records",
                    "requirement": "Foreign key column must be nullable",
                    "example": "Allow user deletion, set user_id to null on entities",
                    "laravel_syntax": "->nullOnDelete() or ->onDelete('set null')",
                    "migration_pattern": "Make column nullable first: DB::statement('ALTER TABLE table_name MODIFY column_name BIGINT UNSIGNED NULL')"
                },
                "cascade": {
                    "description": "Allows deletion of parent row - automatically DELETES all child rows that reference it",
                    "use_case": "When child records should not exist without parent",
                    "example": "Delete all entities when tenant is deleted",
                    "laravel_syntax": "->cascadeOnDelete()",
                    "restriction": "ONLY use for tenant_id foreign keys - all other foreign keys should be RESTRICT or SET NULL"
                }
            },
            "tenant_id_constraints": {
                "not_null_requirement": "All tenant_id columns must be NOT NULL in tenant tables",
                "tables_required": [
                    "users",
                    "features",
                    "configurations",
                    "entities",
                    "entity_feature_pivot"
                ],
                "cascade_only": "Only tenant_id foreign keys should have CASCADE - all others should be RESTRICT or SET NULL",
                "migration_pattern": "DB::statement('ALTER TABLE table_name MODIFY tenant_id BIGINT UNSIGNED NOT NULL')"
            },
            "current_constraint_configuration": {
                "entities": {
                    "user_id": "SET NULL (allows user deletion, sets user_id to null)",
                    "configuration_id": "SET NULL (allows configuration deletion, sets configuration_id to null)",
                    "tenant_id": "CASCADE (deletes entities when tenant is deleted)"
                },
                "entity_feature_pivot": {
                    "entity_id": "SET NULL (allows entity deletion, sets entity_id to null)",
                    "feature_id": "SET NULL (allows feature deletion, sets feature_id to null)",
                    "tenant_id": "CASCADE (deletes entity_feature_pivot when tenant is deleted)"
                }
            },
            "migration_patterns": {
                "update_foreign_key_constraint": {
                    "steps": [
                        "Drop existing foreign key by constraint name using DB::statement('ALTER TABLE table_name DROP FOREIGN KEY constraint_name')",
                        "Make column nullable if needed: DB::statement('ALTER TABLE table_name MODIFY column_name BIGINT UNSIGNED NULL')",
                        "Recreate foreign key with new delete action: $table->foreign('column')->references('id')->on('table')->nullOnDelete()"
                    ],
                    "example": "See database/migrations/2025_11_02_065423_update_foreign_keys_remove_cascade_deletes.php"
                },
                "drop_foreign_key_by_name": {
                    "description": "Use DB::statement() with try-catch for dropping foreign keys by constraint name",
                    "why": "Laravel's dropForeign(['column']) may not work if constraint name doesn't match Laravel's convention",
                    "pattern": "try { DB::statement('ALTER TABLE table_name DROP FOREIGN KEY constraint_name'); } catch (\\Throwable $e) { /* ignore */ }"
                }
            },
            "unique_constraint_design": {
                "avoid_tenant_id_in_constraints": "When a column already scopes to a tenant (e.g., entity_id belongs to a tenant), unique constraint doesn't need tenant_id",
                "cascade_delete_ordering_issues": "Unique constraints with tenant_id can cause MySQL cascade delete ordering issues",
                "example": "entity_feature_pivot unique constraint should be (entity_id, feature_id, feature_position) not (tenant_id, entity_id, feature_id, feature_position) because entity_id already belongs to a specific tenant",
                "migration_example": "See database/migrations for tenant_id constraint examples"
            }
        },
        "unique_constraints": {
            "pivot_table_design": "Include all meaningful combinations in unique constraints",
            "example": "(entity_id, feature_id, feature_position) instead of just (entity_id, feature_id)",
            "migration_challenges": "Drop foreign key constraints before dropping columns",
            "table_recreation": "Recreate entire table for complex constraint modifications",
            "avoid_tenant_id": "Don't include tenant_id in unique constraints when columns already scope to tenant"
        },
        "pivot_record_management": {
            "creation_patterns": "Create both parent and dependent records atomically",
            "undo_operations": "Use updateExistingPivot for undo operations, never delete",
            "duplicate_prevention": "Check existing records before creating new ones",
            "status_tracking": "Use boolean flags and timestamps for status changes"
        },
        "migration_management": {
            "file_structure": "Always include proper PHP class structure even for placeholder migrations",
            "foreign_key_handling": "Handle foreign key constraints in correct order",
            "test_database_sync": "Ensure test database schema matches production",
            "rollback_planning": "Have rollback plans for complex constraint changes",
            "never_modify_existing_migrations": "NEVER modify migrations that already ran in production - create NEW migrations instead",
            "check_current_state": "Always check current database state using information_schema queries before modifying constraints/indexes",
            "handle_both_scenarios": "Migrations should work for both production (old state) and fresh installs (new state)",
            "preserve_foreign_key_actions": "When dropping/recreating foreign keys to update constraints, preserve their current delete actions (CASCADE/SET NULL/RESTRICT)",
            "foreign_keys_prevent_index_drops": "MySQL may prevent dropping unique indexes if foreign keys reference columns in the index - drop foreign keys first, then update constraint, then recreate foreign keys"
        },
        "php_variable_scoping": {
            "description": "PHP variables are function-scoped, not block-scoped - variables reassigned in loops can overwrite outer scope variables",
            "critical_issue": {
                "problem": "When calculating business-level metrics and then looping through benefactors, reassigning variables like $totalDebits and $totalPayments inside the loop overwrites the outer scope variables",
                "example": "Calculated $totalPayments = 2491 for business, then foreach loop reassigns $totalPayments = 22500 for last benefactor, causing incorrect value to be sent to frontend",
                "symptom": "Frontend receives wrong values (e.g., 22500 instead of 2491) because loop's last iteration overwrites outer scope variables"
            },
            "solution": {
                "use_unique_variable_names": "Always use unique variable names inside loops to avoid overwriting outer scope variables",
                "pattern": "Use $entityTotalDebitsRaw and $entityTotalPaymentsRaw inside loop instead of $totalDebits and $totalPayments",
                "example": "Before: $totalPayments = $entityTransactions->sum('amount'); After: $entityTotalPaymentsRaw = $entityTransactions->sum('amount');"
            },
            "key_lessons": [
                "ALWAYS use unique variable names inside loops to prevent overwriting outer scope variables",
                "ALWAYS be aware that PHP variables are function-scoped, not block-scoped",
                "ALWAYS check for variable name collisions when calculating metrics in loops",
                "ALWAYS use descriptive variable names that indicate scope (e.g., $entityTotalPaymentsRaw vs $totalPayments)",
                "ALWAYS verify calculated values match expected values when debugging incorrect frontend displays"
            ],
            "debugging_tips": [
                "Add debug logging before and after loops to verify variable values",
                "Check if variables are being overwritten by searching for all assignments",
                "Use grep to find all variable assignments: grep -n '\\$variableName =' file.php",
                "Verify database queries return correct values before conversion"
            ]
        },
        "enum_casting_bypass": {
            "description": "Bypass enum casting when querying database to avoid casting issues with raw string values",
            "problem": {
                "enum_casting_issues": "When using ->where('type', 'payment'), Laravel tries to cast 'payment' to CreditTransactionType enum, which can cause issues",
                "raw_database_values": "Database stores raw string values ('debit', 'payment'), but enum casting can interfere with queries"
            },
            "solution": {
                "use_whereRaw": "Use ->whereRaw(\"type = 'payment'\") instead of ->where('type', 'payment') to bypass enum casting",
                "pattern": "Transaction::query()->where('business_id', $businessId)->whereRaw(\"type = 'payment'\")->sum('amount')",
                "benefits": [
                    "Directly queries raw database values without enum casting",
                    "More efficient - single query with SUM() instead of loading all records",
                    "Exact match with SQL specification",
                    "Avoids enum casting errors during query execution"
                ]
            },
            "key_lessons": [
                "ALWAYS use whereRaw() when querying enum columns to bypass casting issues",
                "ALWAYS use whereRaw() for type comparisons in database queries",
                "ALWAYS verify query results match expected SQL behavior",
                "ALWAYS use direct database queries (selectRaw with SUM) for aggregation instead of loading all records"
            ]
        },
        "currency_conversion_patterns": {
            "description": "Currency conversion should be done on backend using CurrencyService before sending to frontend",
            "backend_conversion": {
                "pattern": "Convert from smallest currency unit to main currency unit using CurrencyService on backend",
                "example": "$totalPayments = $currencyService->fromSmallestUnit($totalPaymentsRaw, $currencyCode);",
                "frontend_receives": "Frontend receives converted values (e.g., 2491.00) already in main currency unit",
                "frontend_formatting": "Frontend only formats values for display (adds commas, decimal places) - no conversion needed"
            },
            "key_lessons": [
                "ALWAYS convert currency on backend using CurrencyService before sending to frontend",
                "ALWAYS send converted values (main currency unit) to frontend, not raw database values (smallest unit)",
                "ALWAYS let frontend handle only formatting (commas, decimal places), not conversion",
                "ALWAYS verify conversion is correct by checking raw database values and converted values in debug logs"
            ]
        }
    },
    "frontend_development": {
        "inertia_first_architecture": {
            "core_rules": {
                "always_use_inertia": "Use Inertia for ALL operations - page navigation AND data operations",
                "never_use_fetch": "Never use fetch() or axios for internal app requests",
                "always_return_inertia": "Backend should return Inertia::render() or redirect()->back()",
                "minimize_shared_props": "Only essential data shared globally"
            },
            "frontend_rules": {
                "router_methods": "Use router.post(), router.put(), router.delete(), router.get()",
                "smart_partial_reloads": "Use only: ['prop1', 'prop2'] for data operations",
                "preserve_state": "Use preserveState: true for data operations",
                "loading_states": "Use Inertia's built-in loading indicators"
            },
            "backend_rules": {
                "inertia_responses": "Use Inertia::render() or redirect()->back()",
                "lazy_evaluation": "Use closures for expensive operations",
                "flash_messages": "Use session()->flash() for user feedback",
                "never_return_json": "All operations return Inertia responses"
            }
        },
        "route_response_types": {
            "internal_app_routes": {
                "response_type": "Inertia responses (redirect()->back(), Inertia::render())",
                "user_feedback": "Flash messages (session()->flash())",
                "examples": "User management, entities, features, dashboard, profile",
                "testing": "Use post() and assertRedirect() with assertSessionHas()"
            },
            "external_api_routes": {
                "response_type": "JSON responses (response()->json())",
                "examples": "Twilio SMS routes (/api/sms/*), external API integrations",
                "testing": "Use postJson() and assertStatus() with assertJson()"
            },
            "sms_exception": "SMS verification uses API routes only with JSON responses"
        },
        "vue_development": {
            "console_error_prevention": {
                "variable_definitions": "Ensure all variables are properly defined and imported",
                "currentUser_access": "Define currentUser from Inertia page props",
                "router_imports": "Import router from @inertiajs/vue3 when needed"
            },
            "component_warnings": {
                "extraneous_attributes": "Use single root element for automatic attribute inheritance",
                "prop_validation": "Make props optional with default null to prevent stderr warnings",
                "directive_cleanup": "Remove orphaned v-else when removing v-if elements"
            },
            "form_handling": {
                "csrf_tokens": "Inertia automatically handles CSRF, fetch requires manual handling",
                "error_handling": "Use try/catch blocks for network errors",
                "loading_states": "Manual loading state management with finally blocks",
                "form_data_initialization": {
                    "description": "CRITICAL: All form fields must be in initial useForm() definition for form.post() to include them",
                    "problem": "Properties added dynamically with (form as any).property may not be included in form.post() submissions",
                    "solution": "Always include all form fields (even optional/nullable ones) in the initial useForm() definition",
                    "pattern": "const form = useForm({ email: '', password: '', business_id: null as number | null })",
                    "why": "Inertia's form.post() only sends properties that exist in the form's initial data object",
                    "anti_pattern": "Don't add properties dynamically: (form as any).business_id = businessId",
                    "correct_pattern": "Include in initial definition: business_id: null, then update: form.business_id = businessId",
                    "example": "Login form must include business_id: null in initial definition, then update when business is selected",
                    "benefits": [
                        "Ensures all form data is sent to backend",
                        "TypeScript recognizes properties (no need for 'as any')",
                        "Consistent form submission behavior"
                    ]
                }
            }
        }
    },
    "performance_optimization": {
        "inertia_v2_features": {
            "deferred_props": {
                "implementation": "Use Inertia::defer() for expensive operations",
                "benefits": "Faster initial page load, progressive data loading",
                "backend_pattern": "return Inertia::render('Page', ['data' => Inertia::defer(fn() => $expensiveOperation)])",
                "frontend_pattern": "Use Deferred component with fallback template"
            },
            "when_visible": {
                "implementation": "Wrap components with WhenVisible for lazy loading",
                "benefits": "Improved performance by loading data only when visible",
                "buffer": "200px buffer for smooth loading experience",
                "testing": "Must mock WhenVisible in all test files using components with lazy loading"
            },
            "prefetching": {
                "implementation": "Use router.prefetch() for data preloading",
                "benefits": "Faster modal opening, better user experience",
                "caching": "5-minute cache with tags for invalidation"
            }
        },
        "conditional_testing": {
            "git_based_execution": {
                "purpose": "Skip expensive tests when file unchanged since last commit",
                "implementation": "Check git diff --name-only HEAD for file modifications",
                "fail_safe": "Run tests if git check fails to ensure nothing is missed",
                "performance_gain": "~20 seconds per test run when expensive tests are skipped"
            }
        },
        "caching_strategies": {
            "singleton_caching": "Use Cache::remember() for singleton instances",
            "session_management": "Leverage existing session storage for state management",
            "cache_invalidation": "Consider cache invalidation strategies for singleton instances"
        }
    },
    "error_handling_debugging": {
        "console_error_resolution": {
            "root_cause_analysis": "Fix root cause errors first, then address cascading issues",
            "variable_definitions": "Ensure all variables are properly defined and imported",
            "cascading_errors": "Console errors can cascade and cause Vue warnings"
        },
        "build_error_management": {
            "async_await_syntax": "Ensure all functions using await are marked as async",
            "systematic_resolution": "Fix build errors systematically, one file at a time",
            "verification_process": "Run npm run build after each fix to verify resolution"
        },
        "test_failure_debugging": {
            "systematic_approach": "Identify all failures, categorize issues, fix one category at a time",
            "root_cause_understanding": "Understand why tests are failing before making changes",
            "comprehensive_verification": "Run complete test suite after all fixes"
        },
        "error_banner_pattern": {
            "description": "Using separate errorBanner and error props for different display sections",
            "implementation": {
                "banner_prop": "errorBanner prop displays in banner header (e.g., 'Invalid QR Code')",
                "error_prop": "error prop displays in content section with detailed information (e.g., 'QR Code Expired')",
                "fallback_behavior": "Banner falls back to error prop when errorBanner is not provided: {{ errorBanner || error }}",
                "backend_pattern": "Return both error and errorBanner in Inertia::render() when needed"
            },
            "use_cases": {
                "consistent_banner": "Use errorBanner for consistent banner text across error types",
                "detailed_content": "Use error prop for detailed error information in content section",
                "user_experience": "Banner provides quick context, content provides detailed explanation"
            },
            "benefits": [
                "Consistent banner messaging across different error types",
                "Detailed error information in content section",
                "Better user experience with clear hierarchy",
                "Easier to maintain and update error messages"
            ]
        }
    },
    "user_experience": {
        "progressive_loading": {
            "principle": "Users prefer immediate feedback over waiting for complete loading",
            "implementation": "Show content as soon as it's ready, use placeholders for pending content",
            "separate_states": "Separate loading states for different components"
        },
        "visual_feedback": {
            "border_styling": "Use green/red borders for validation states",
            "loading_states": "Provide clear loading feedback to users",
            "error_messages": "Use consistent error handling via flash messages"
        },
        "form_optimization": {
            "prepopulation": "Auto-fill form fields when switching input types",
            "conditional_messages": "Show helpful messages when switching between input types",
            "validation_feedback": "Provide immediate visual feedback for validation states"
        },
        "image_upload_guidance": {
            "principle": "Frontend instructions for uploads must mirror backend validation so users understand dimension and size requirements",
            "implementation": [
                "Show explicit copy beside favicon/logo inputs describing allowed formats, square dimensions, and max file size",
                "Keep UI messaging in sync with form request rules whenever validation changes",
                "Use copy like 'Upload a square PNG or JPG between 32px and 512px (max 1MB)' so the SquareImage backend rule feels intuitive",
                "Disable submission until mandatory fields such as currency are provided to prevent partial updates"
            ],
            "benefits": [
                "Reduces validation churn by setting expectations up front",
                "Keeps tenant information updates consistent across UI and backend",
                "Improves onboarding flow by highlighting critical fields like currency"
            ]
        }
    },
    "code_quality_maintenance": {
        "formatting": {
            "laravel_pint": "Always run vendor/bin/pint --dirty before finalizing changes",
            "code_consistency": "Follow existing code conventions used in the application",
            "import_cleanup": "Remove unused imports after refactoring"
        },
        "documentation": {
            "pattern_documentation": "Document new testing patterns as they are discovered",
            "lesson_preservation": "Preserve lessons learned in AI documentation",
            "knowledge_sharing": "Make knowledge available for future development"
        },
        "refactoring_safety": {
            "backward_compatibility": "Frontend refactoring should not require backend changes",
            "functionality_preservation": "Keep all existing functionality intact during refactoring",
            "test_coverage": "Maintain comprehensive test coverage during changes"
        }
    },
    "common_pitfalls": {
        "component_architecture": [
            "Using single-item component for multiple-item scenarios",
            "Mixing singular/plural prop names (item vs items)",
            "Not cleaning up Vue directives when removing elements",
            "Using required props without defaults in Vue components"
        ],
        "testing": [
            "Using postJson() for internal routes or post() for external routes",
            "Not updating test assertions when changing component behavior",
            "Only testing with fresh data, not existing data scenarios",
            "Not testing authentication state preservation"
        ],
        "database": [
            "Making unique constraints too restrictive",
            "Creating parent records without dependent records",
            "Using insufficient conditions for duplicate checking",
            "Not handling foreign key constraints when dropping columns"
        ],
        "frontend": [
            "Using router.reload() after form submissions (causes logout)",
            "Reading flash from page.props.flash instead of page.props.jetstream.flash",
            "Using .value on computed properties in templates",
            "Not providing global properties for Vue components in tests"
        ]
    },
    "best_practices": {
        "component_design": {
            "single_responsibility": "Each component should have one clear purpose",
            "prop_design": "Design props for single items, not collections",
            "root_element": "Always use single root element for attribute inheritance",
            "separation": "Separate data management from display logic"
        },
        "testing_approach": {
            "systematic_fixing": "Follow systematic approach when fixing multiple test issues",
            "comprehensive_coverage": "Test both positive and negative scenarios",
            "realistic_data": "Use test data that reflects real-world scenarios",
            "authentication_testing": "Always test that Auth::check() remains true after profile updates"
        },
        "database_design": {
            "constraint_planning": "Design unique constraints to match business logic requirements",
            "migration_safety": "Test migrations in development environment first",
            "foreign_key_handling": "Always drop foreign key constraints before dropping columns",
            "pivot_record_creation": "Create both parent and dependent records atomically"
        },
        "frontend_development": {
            "inertia_usage": "Never use fetch() for internal app requests",
            "route_selection": "Use correct routes for different operations",
            "form_handling": "Include all required form fields when extracting components",
            "visual_feedback": "Always test that correct CSS classes are applied"
        }
    },
    "critical_commands": {
        "testing": {
            "backend_tests": "php artisan test",
            "frontend_tests": "npm test",
            "specific_test": "php artisan test --filter=TestName",
            "integration_tests": "php artisan test --group=integration"
        },
        "code_quality": {
            "format_code": "vendor/bin/pint --dirty",
            "check_linting": "npm run lint",
            "build_verification": "npm run build"
        },
        "database": {
            "migration_status": "php artisan migrate:status",
            "check_constraints": "SHOW CREATE TABLE table_name",
            "drop_foreign_key": "ALTER TABLE table_name DROP FOREIGN KEY constraint_name"
        }
    },
    "future_considerations": {
        "performance_monitoring": [
            "Track test execution times and optimize slow tests",
            "Monitor singleton pattern performance in production",
            "Implement response caching at API level"
        ],
        "architecture_improvements": [
            "Consider API versioning for external routes",
            "Implement rate limiting for API endpoints",
            "Consider CDN integration for production environments"
        ],
        "testing_enhancements": [
            "Develop more comprehensive testing patterns for component extraction",
            "Consider automated build verification in development workflow",
            "Implement git-based conditional testing for other slow test suites"
        ],
        "user_experience": [
            "Consider implementing QR code signing for enhanced security",
            "Add proper ARIA labels for screen readers",
            "Implement image optimization for better performance"
        ]
    },
    "session_summaries": {
        "component_refactoring": "Single Card Component Architecture with parent-level looping and git-based conditional testing",
        "console_errors_inertia_v2": "Fixed critical console errors and implemented Inertia 2.0 deferred props and WhenVisible features",
        "dashboard_testing": "Fixed all 6 failing frontend tests with systematic approach and component logic updates",
        "frontend_test_fixes": "Fixed failing frontend tests for route function mocking and Banner component issues",
        "inertia_conversion": "Complete migration from fetch-based requests to Inertia.js patterns with proper route response types",
        "jsonresource_api": "Converting SMS verification to API calls with JsonResource responses and dual route architecture",
        "modal_ui_improvements": "Modal UI cleanup, frontend test updates, and Vue component prop validation fixes",
        "qr_modal": "QR Code Modal implementation with PHPUnit modernization and Vue component optimization",
        "route_component_mismatch": "Fixed route to show multiple items with proper component naming conventions",
        "singleton_pattern": "Complete singleton pattern implementation with database schema refactoring and test updates",
        "sms_api_only": "SMS API-only architecture refactoring with route cleanup and documentation updates",
        "entity_filtering": "Entity filtering, bug fixes, and Inertia router conversion with comprehensive testing",
        "styling_architecture": "Styling improvements and component architecture refactoring with Vue warnings resolution",
        "system_activation": "System activation component refactoring with form data handling and build error management",
        "test_fixes": "Fixed failing tests after implementing entity filtering and feature action features",
        "test_suite_fixing": "Resolved all backend and frontend test failures and warnings with systematic approach",
        "unique_constraints": "Unique constraints and pivot records management with comprehensive testing approaches",
        "emailorphone_validation": "EmailOrPhone server validation with flash messages and comprehensive test coverage",
        "image_storage_migration": "Image storage migration from storage:link to direct public/images access",
        "profile_switching": "Profile switching and logout fixes with authentication state preservation",
        "authentication_styling_restoration": "Authentication styling restoration, dark mode removal, logo shadow effects, and Jetstream component reversion",
        "database_safety_environment_management": "Database safety rules, environment flag requirements, and production database protection with comprehensive .cursorrules updates",
        "frontend_test_warnings_resolution": "Frontend test warning resolution, component prop requirements, and test stub optimization with systematic warning elimination",
        "smooth_loading_implementation": "Smooth loading pattern implementation using Promise.all() for coordinated QR code and timer loading in FeatureActionModal",
        "user_management_route_security": "User management route security implementation with proper middleware combinations, frontend test expectation fixes, and data structure consistency patterns",
        "multi_tenant_architecture": "Complete migration from singleton to multi-tenant architecture with tenant_id scoping, global scope implementation, and comprehensive test infrastructure using CreatesTenantData trait",
        "infinite_scroll_search": "Implemented elegant infinite scroll with search functionality on Users page using Inertia v2 InfiniteScroll component with debounced search and floating back-to-top button",
        "branding_business_slug_and_scoped_validation": "Login/Register branding via ?business=slug (logo/title), hides BusinessSelector and includes hidden business_id, server validation scoped by business for EmailOrPhone (login/register), root redirect logic (no users\u2192register, else\u2192login), composite unique (business_id,email), dashboard filler cards to complete rows, new business created inactive by default, BusinessSelector autofocus on Login",
        "favicon_branding_and_scoping": "Favicon handling on auth pages: prefer tenant?.favicon_url from query/tenant props, else brand.favicon from middleware, else /favicon.png. Middleware must not default to first Tenant for guests; only use authenticated user's tenant to avoid cross-tenant branding leaks. Ensure default favicon is a square PNG; browsers may ignore non-square favicons.",
        "order_and_test_index_patterns": "Stabilize list ordering with created_at DESC plus id DESC tie-breaker. In tests, avoid index-based assertions; assert presence by id/name or use order-agnostic checks unless deterministic order is required.",
        "redemption_error_handling_improvements": "Implemented error banner pattern with errorBanner and error props for different display sections, DD/MMM/YYYY date formatting for expiry dates, mobile-responsive headers with flex-col/flex-row patterns, and removal of duplicate content sections when moving info to headers. Added comprehensive tests for both frontend and backend error handling with query parameter testing patterns.",
        "frontend_test_link_component_mocking": "CRITICAL: When components use Link from @inertiajs/vue3, ALL test mocks must include Link component. Missing Link export causes 'No Link export is defined' errors. Add Link: { name: 'Link', props: ['href'], template: '<a :href=\"href\"><slot /></a>' } to all Inertia mocks. URL parameter expectations: When adding query parameters to routes (e.g., ?activecards=true), update test expectations to match new URL format.",
        "session_storage_completed_items": "Completed items must be added to session when completed via action routes, not just increment routes. Filter logic: completed items in session should be shown regardless of has_available_features status, as long as they're not expired. This ensures items remain visible in current session even after all features are completed.",
        "has_available_feature_logic_updates": "has_available_feature now includes items with current_value < total_value that are not expired. This means items qualify for feature icon even before reaching feature threshold. Test expectations must be updated when this logic changes - items with current_value < total_value should show has_available_feature = true.",
        "flash_message_behavior_changes": "Flash messages should only be shown when entities are completed, not on every increment. Tests expecting 'Item updated successfully!' need to be updated to expect null or missing flash messages when items are not completed. Completion messages only appear when current_value equals total_value.",
        "test_ordering_assumptions": "Fixed test ordering assumptions: when collections are ordered by created_at DESC, the newest item is first, not the oldest. Use firstWhere() to find items by properties (is_completed, current_value) rather than assuming array position.",
        "php_variable_scoping_currency_metrics": "Fixed variable name collision in Controller where $totalDebits and $totalPayments were overwritten inside entity foreach loop. PHP variables are function-scoped, not block-scoped, so loop variables overwrote outer scope. Solution: Use unique variable names ($entityTotalDebitsRaw) inside loops. Also bypassed enum casting using whereRaw() for direct database queries and ensured CurrencyService conversion happens on backend before sending to frontend.",
        "metrics_calculation_transaction_history": "Fixed business-level and entity-specific metrics to calculate from transaction history (debits - payments) instead of account.outstanding_balance database column which was stale. Use whereRaw() and selectRaw('SUM(amount)') for efficient SQL aggregation queries. Always calculate outstanding balance as debits - payments from transactions, not from database columns.",
        "payment_button_logic": "Fixed payment button disable logic to check actual outstanding balance from entityMetrics instead of entityPaymentLimits (which includes limit). Payment limits are for validation, not button state. Always parse formatted metric values (remove commas) before numeric comparison.",
        "benefactor_payment_allocation_transactions": "Fixed benefactor payment allocation to calculate outstanding balance from transactions for each beneficiary account instead of using credit_accounts.outstanding_balance database column. Only include accounts with calculated outstanding balance > 0 in payment allocation. Transaction history is the source of truth, not database columns.",
        "benefactor_own_account_inclusion": "CRITICAL: When calculating benefactor payment totals and metrics, ALWAYS include the benefactor's own credit account and transactions, not just beneficiaries. The bug was that PaymentAllocationService and UserController::index() only included beneficiary accounts, excluding the benefactor's own debits. Fix: Get benefactor's own credit account and combine with beneficiary accounts before calculating outstanding balances. Update both payment allocation logic AND frontend metrics calculation (benefactorMetrics) to include benefactor's own account. Frontend reads outstanding balance from benefactorMetrics, so both backend calculations must include benefactor's own account."
    },
    "authentication_styling": {
        "light_mode_enforcement": {
            "description": "Force light mode for authentication pages to ensure consistent user experience",
            "implementation": {
                "remove_system_detection": "Remove matchMedia system color scheme detection",
                "force_light_mode": "Use document.documentElement.classList.remove('dark') in onMounted()",
                "remove_dark_classes": "Remove all dark: prefixed classes from authentication components",
                "consistent_styling": "Apply same styling patterns across Login.vue and Register.vue"
            },
            "benefits": [
                "Consistent user experience regardless of system preferences",
                "Simplified code without complex system detection",
                "Better performance without media query listeners",
                "Predictable behavior for authentication pages"
            ]
        },
        "logo_styling_enhancement": {
            "description": "Enhance logo presentation with shadow effects and consistent styling",
            "implementation": {
                "shadow_effects": "Add shadow class to logo containers for subtle depth",
                "rounded_corners": "Apply rounded-lg for modern appearance",
                "white_background": "Use bg-white for consistent logo presentation",
                "proper_spacing": "Use m-2 for proper margin around logo containers"
            },
            "styling_classes": "bg-white m-2 rounded-lg shadow",
            "benefits": [
                "Professional appearance with subtle depth",
                "Consistent styling across authentication pages",
                "Enhanced visual appeal without being overwhelming",
                "Modern design with rounded corners and shadows"
            ]
        },
        "jetstream_component_restoration": {
            "description": "Revert to stock Jetstream components when custom implementations cause issues",
            "scenarios": [
                "2FA implementation issues with custom responses",
                "Component styling conflicts",
                "Functionality regressions after custom modifications",
                "Maintenance complexity with custom implementations"
            ],
            "restoration_process": {
                "identify_issues": "Identify specific problems with custom implementations",
                "backup_customizations": "Backup important custom features before restoration",
                "revert_to_stock": "Use original Jetstream components as base",
                "restore_custom_features": "Carefully restore only essential custom functionality",
                "test_thoroughly": "Verify all functionality works after restoration"
            },
            "benefits": [
                "Reduced maintenance complexity",
                "Better compatibility with Jetstream updates",
                "Cleaner codebase with standard patterns",
                "Easier debugging and troubleshooting"
            ]
        }
    },
    "global_data_management": {
        "handleinertia_requests": {
            "description": "Use HandleInertiaRequests middleware for global data sharing",
            "implementation": {
                "tenant_data": "Share tenant information globally through middleware",
                "brand_data": "Share brand/app information globally",
                "user_data": "Share user authentication data globally",
                "fallback_handling": "Provide fallbacks when global data is not available"
            },
            "data_structure": {
                "tenant": {
                    "id": "Tenant ID",
                    "name": "Tenant name",
                    "logo_url": "Tenant logo URL",
                    "favicon_url": "Tenant favicon URL"
                },
                "brand": {
                    "appName": "Dynamic app name based on tenant",
                    "favicon": "Favicon URL with fallback",
                    "logo": "Logo URL with fallback"
                }
            },
            "access_patterns": {
                "vue_components": "Use page.props.tenant and page.props.brand",
                "avoid_individual_props": "Don't pass tenant data as individual props",
                "global_availability": "Access tenant data anywhere in the application",
                "consistent_access": "Use same access pattern across all components"
            },
            "benefits": [
                "Reduced prop drilling",
                "Consistent data access patterns",
                "Easier maintenance and updates",
                "Better performance with shared data"
            ]
        },
        "authentication_page_optimization": {
            "description": "Optimize authentication pages for better user experience",
            "optimizations": {
                "force_light_mode": "Always display in light mode for consistency",
                "remove_dark_mode": "Remove all dark mode styling and detection",
                "enhance_logos": "Add shadow effects and proper styling to logos",
                "global_data_access": "Use global tenant data instead of individual props"
            },
            "user_experience_improvements": [
                "Consistent visual experience across all devices",
                "Professional appearance with enhanced logo styling",
                "Faster page loads without system detection logic",
                "Simplified maintenance and updates"
            ]
        }
    },
    "database_safety_environment_management": {
        "environment_flag_requirements": {
            "description": "Always use APP_ENV=testing when running tests to ensure proper database isolation",
            "implementation": {
                "test_commands": "APP_ENV=testing php artisan test",
                "specific_tests": "APP_ENV=testing php artisan test --filter=test_method_name",
                "coverage_tests": "APP_ENV=testing php artisan test --coverage",
                "never_without_flag": "Never run tests without APP_ENV=testing flag"
            },
            "database_isolation": {
                "development_database": "loyalty (from .env file)",
                "testing_database": "loyalty_dusk (from phpunit.xml)",
                "automatic_switching": "Laravel automatically switches databases based on APP_ENV",
                "connection_verification": "Use DB::connection()->getPdo() to verify database connectivity"
            },
            "benefits": [
                "Prevents accidental data corruption between environments",
                "Ensures tests use correct database schema",
                "Maintains proper database isolation",
                "Prevents production database accidents"
            ]
        },
        "production_database_protection": {
            "description": "Critical rules to prevent accidental production database migrations",
            "safety_measures": {
                "never_auto_migrate": "NEVER run migrations on production without explicit user approval",
                "always_confirm_environment": "Check APP_ENV before running any database operations",
                "backup_before_migrations": "Suggest database backup before running migrations on production",
                "dry_run_first": "Use php artisan migrate:status to check pending migrations first"
            },
            "safe_commands": {
                "check_status": "php artisan migrate:status",
                "force_migrate": "php artisan migrate --force (only after explicit approval)",
                "test_operations": "php artisan migrate:refresh --seed (only for development/testing)"
            },
            "environment_detection": {
                "development": "Uses .env file \u2192 DB_DATABASE=loyalty",
                "testing": "Uses phpunit.xml \u2192 DB_DATABASE=loyalty_dusk",
                "automatic_switching": "Laravel switches databases based on APP_ENV context"
            }
        },
        "test_environment_verification": {
            "description": "How to verify correct database environment for tests",
            "verification_methods": {
                "config_check": "config('database.connections.mysql.database')",
                "connection_test": "DB::connection()->getPdo()",
                "environment_check": "APP_ENV=testing php artisan tinker --execute='echo config(\"database.connections.mysql.database\")'",
                "database_name_verification": "Use PDO to get current database name"
            },
            "troubleshooting": {
                "wrong_database": "Check APP_ENV and phpunit.xml configuration",
                "connection_failed": "Verify database server is running and credentials are correct",
                "schema_mismatch": "Run php artisan migrate:refresh --seed to sync test database"
            }
        },
        "cursorrules_integration": {
            "description": "Integration of environment flag requirements into .cursorrules",
            "updates": {
                "testing_strategy": "Added environment flag requirements to testing strategy section",
                "quick_commands": "Updated all backend test commands to include APP_ENV=testing",
                "critical_rules": "Added to NEVER and ALWAYS rules for environment flags",
                "database_isolation": "Added database isolation rules and environment commands"
            },
            "enforcement": {
                "always_use_flag": "All test commands must include APP_ENV=testing",
                "never_without_flag": "Never run tests without environment flag",
                "database_context": "Ensure proper database context for all test operations"
            }
        }
    },
    "frontend_test_warnings_component_props": {
        "vue_warning_resolution": {
            "description": "Systematic approach to resolving Vue warnings in frontend tests",
            "common_warnings": {
                "missing_required_props": "Components with required props not receiving them in tests",
                "undefined_properties": "Accessing undefined properties in component templates",
                "prop_validation_errors": "Vue prop validation warnings in test environments"
            },
            "resolution_approach": {
                "identify_source": "Trace warnings to specific components and props",
                "check_actual_usage": "Verify how components are used in real application",
                "fix_source_bugs": "Fix actual bugs in components, not just test mocks",
                "update_test_stubs": "Provide proper prop definitions in test stubs"
            },
            "benefits": [
                "Cleaner test output without warnings",
                "Better component reliability",
                "Improved debugging experience",
                "More accurate test coverage"
            ]
        },
        "component_prop_requirements": {
            "description": "Ensuring all required component props are properly provided",
            "identification_patterns": {
                "vue_warnings": "Look for 'Missing required prop' warnings in test output",
                "component_analysis": "Check component prop definitions for required props",
                "usage_verification": "Verify how components are used in actual application code"
            },
            "fixing_approaches": {
                "source_component_fix": "Add missing props to actual component usage",
                "test_stub_improvement": "Update test stubs to include proper prop definitions",
                "prop_validation": "Ensure all required props have proper types and defaults"
            },
            "prevention_strategies": {
                "component_documentation": "Document all required props clearly",
                "test_coverage": "Test components with all required props",
                "prop_validation": "Use TypeScript or prop validation for better error catching"
            }
        },
        "test_stub_optimization": {
            "description": "Creating effective test stubs that match real component interfaces",
            "stub_requirements": {
                "prop_definitions": "Include all props that the real component expects",
                "template_simplification": "Use simple templates that don't trigger complex logic",
                "data_testid_usage": "Add data-testid attributes for better test targeting"
            },
            "best_practices": {
                "match_real_interface": "Stubs should match the real component's prop interface",
                "minimal_functionality": "Keep stubs simple but functional enough for tests",
                "clear_naming": "Use descriptive names and data-testid attributes"
            },
            "example_implementation": {
                "component_stub": "ProfilePhoneOtp: { template: '<div data-testid=\"profile-phone-otp\"></div>', props: ['phoneNumber', 'disabled', 'profileData'] }",
                "benefits": "Eliminates prop warnings while maintaining test functionality"
            }
        },
        "warning_resolution_workflow": {
            "description": "Systematic workflow for resolving frontend test warnings",
            "steps": [
                "Run tests and identify all warnings",
                "Trace warnings to specific components and lines",
                "Check if warnings indicate real bugs in source code",
                "Fix source code bugs first, then update test mocks",
                "Verify warnings are resolved by re-running tests",
                "Document patterns for future prevention"
            ],
            "priority_order": {
                "source_bugs_first": "Always fix actual component bugs before test workarounds",
                "test_improvements_second": "Improve test stubs and mocks after fixing source issues",
                "documentation_last": "Document patterns and solutions for future reference"
            }
        },
        "component_refactoring_props_to_usepage": {
            "description": "Updating tests when refactoring components from props to usePage()",
            "problem": "When components are refactored to read data from usePage() instead of props, tests may pass props that are no longer accepted, causing Vue warnings about extraneous non-props attributes",
            "warning_example": "[Vue warn]: Extraneous non-props attributes (tenant) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes",
            "solution": {
                "extract_prop_from_test": "In test setup, extract the prop from test props object before passing to component",
                "update_mock_page_props": "Update mockPageProps instead of passing prop to component mount",
                "remove_from_component_props": "Remove the prop from the props object passed to component mount"
            },
            "implementation_pattern": {
                "before": "getMountOptions: (props = {}) => { return { props: { ...props, memberCount: 0 } }; }",
                "after": "getMountOptions: (props = {}) => { const { business, ...componentProps } = props; if (business !== undefined) { mockPageProps.business = business; } return { props: { ...componentProps, memberCount: 0 } }; }",
                "explanation": "Extract business from props, update mockPageProps.business, and only pass remaining componentProps to component"
            },
            "benefits": [
                "Eliminates Vue warnings about extraneous props",
                "Tests correctly reflect component's actual data source (usePage() instead of props)",
                "More accurate test coverage of component behavior",
                "Cleaner test output without warnings"
            ],
            "common_scenarios": [
                "Refactoring components to use global shared data from HandleInertiaRequests",
                "Moving from prop-based data passing to Inertia shared props",
                "Consolidating data access patterns across components"
            ],
            "prevention": "When refactoring components from props to usePage(), always update tests to remove props from component mount and update mockPageProps instead"
        }
    },
    "laravel_cloud_object_storage": {
        "description": "Comprehensive Laravel Cloud Object Storage (R2) implementation patterns",
        "core_principles": {
            "configurable_disks": "Support multiple storage drivers (local, public, S3, R2) through configuration",
            "private_public_buckets": "Handle both private and public bucket visibility with temporary URLs",
            "original_filename_preservation": "Preserve original filenames with conflict handling using number suffixes",
            "cloud_native_integration": "Leverage Laravel Cloud's automatic environment variable injection",
            "cors_ready": "Automatic CORS policy management for cloud storage"
        },
        "implementation_patterns": {
            "service_layer": {
                "image_upload_service": "Centralized service for all image upload operations",
                "configurable_disk_support": "Service accepts disk parameter for different storage drivers",
                "temporary_url_generation": "Generate temporary URLs for private buckets with configurable expiration",
                "filename_conflict_handling": "Add number suffixes for filename conflicts (logo-1.png, logo-2.png)",
                "sanitization": "Remove special characters while preserving readability"
            },
            "model_integration": {
                "url_attribute_generation": "Models generate URLs based on configured disk",
                "private_bucket_detection": "Check disk configuration and visibility for temporary URL generation",
                "fallback_handling": "Provide fallbacks when image paths are null or empty",
                "basename_usage": "Use basename() to extract filename from stored path for URL generation"
            },
            "controller_patterns": {
                "disk_configuration": "Use config('filesystems.image_disk', 'public') for configurable storage",
                "service_instantiation": "Instantiate ImageUploadService with appropriate disk",
                "old_file_cleanup": "Delete old files when updating images",
                "validation_integration": "Integrate with Form Request validation for file types and sizes"
            }
        },
        "environment_configuration": {
            "laravel_cloud_variables": [
                "R2_ACCESS_KEY_ID (auto-injected)",
                "R2_SECRET_ACCESS_KEY (auto-injected)",
                "R2_DEFAULT_REGION=auto",
                "R2_BUCKET (auto-injected)",
                "R2_URL (auto-injected)",
                "R2_ENDPOINT (auto-injected)",
                "R2_USE_PATH_STYLE_ENDPOINT=true"
            ],
            "application_configuration": [
                "IMAGE_DISK=r2 (for Laravel Cloud Object Storage)",
                "PROFILE_PHOTO_DISK=r2 (for user profile photos)"
            ],
            "filesystem_configuration": "Configure R2 disk in config/filesystems.php with S3-compatible settings"
        },
        "testing_patterns": {
            "storage_fake_usage": "Use Storage::fake() for testing file operations instead of real files",
            "service_testing": "Test ImageUploadService with different disk configurations",
            "url_generation_testing": "Test URL generation for both public and private buckets",
            "filename_preservation_testing": "Test that original filenames are preserved with conflict handling",
            "temporary_url_testing": "Test temporary URL generation with proper expiration times"
        },
        "benefits": [
            "Scalable storage solution that works from development to production",
            "Automatic environment variable injection by Laravel Cloud",
            "Consistent API across different storage drivers",
            "Built-in CORS policy management",
            "Temporary URL support for private buckets",
            "Original filename preservation for better user experience"
        ]
    },
    "inertia_v2_advanced_features": {
        "description": "Advanced Inertia v2 features including InfiniteScroll and modern pagination patterns",
        "infinite_scroll_implementation": {
            "core_principles": {
                "inertia_scroll_usage": "Use Inertia::scroll() for proper pagination merging with Laravel patterns",
                "data_appending": "Append new data instead of replacing existing data for seamless scrolling",
                "pagination_metadata": "Include current_page, last_page, per_page, total in controller responses",
                "intersection_observer": "Leverage browser's IntersectionObserver for automatic loading",
                "loading_states": "Provide loading indicators and end-of-list messages for better UX"
            },
            "backend_patterns": {
                "controller_structure": "Return paginated data with metadata using Inertia::scroll()",
                "search_integration": "Combine search functionality with infinite scroll pagination",
                "realistic_testing": "Seed 50+ records for proper infinite scroll testing",
                "performance_considerations": "Use efficient queries and proper indexing for large datasets"
            },
            "frontend_patterns": {
                "infinite_scroll_component": "Use Inertia's InfiniteScroll component with proper data binding",
                "loading_templates": "Provide loading and end-of-list templates for better UX",
                "scroll_behavior": "Implement smooth scrolling and proper scroll position management",
                "responsive_design": "Ensure infinite scroll works well on mobile and desktop"
            }
        },
        "pagination_patterns": {
            "laravel_integration": "Use Laravel's built-in pagination with Inertia::scroll()",
            "metadata_structure": "Include all pagination metadata for frontend consumption",
            "search_pagination": "Maintain pagination state when implementing search functionality",
            "url_preservation": "Preserve search parameters in pagination URLs",
            "stamp_card_pagination": "Return stamp cards as LengthAwarePaginator instances so frontend reads from stampCards.data while keeping redemption stats intact",
            "query_param_preservation": "Frontend pagination handlers must rebuild URLs with existing query params (e.g., activecards=true) when changing pages"
        },
        "testing_approaches": {
            "pagination_testing": "Test pagination metadata, loading states, and data appending",
            "performance_testing": "Test with large datasets to ensure smooth scrolling performance",
            "search_integration_testing": "Test search functionality combined with infinite scroll",
            "responsive_testing": "Test infinite scroll behavior on different screen sizes"
        }
    },
    "search_pagination_patterns": {
        "description": "Comprehensive search functionality with real-time debouncing and pagination integration",
        "search_implementation": {
            "core_principles": {
                "debounced_search": "Use 300ms debounce for real-time search to prevent excessive API calls",
                "case_insensitive_search": "Implement LIKE queries with proper case handling",
                "empty_state_handling": "Show meaningful messages when no search results found",
                "clear_search_functionality": "Provide easy way to clear search and return to full list",
                "pagination_integration": "Ensure search results are properly paginated"
            },
            "backend_patterns": {
                "form_request_validation": "Use SearchUsersRequest for proper validation of search parameters",
                "query_building": "Use when() method for conditional search queries",
                "search_scope": "Implement proper search scope with OR conditions for multiple fields",
                "pagination_maintenance": "Maintain pagination state with search results",
                "fuzzy_search_pagination": "For fuzzy search with in-memory filtering, use manual pagination with collection slicing and manual pagination metadata creation (see fuzzy_search_implementation.pagination_integration)"
            },
            "frontend_patterns": {
                "debounced_input": "Implement debounced search input with proper cleanup",
                "search_state_management": "Manage search query state and results properly",
                "empty_state_ui": "Provide helpful empty state messages with clear search button",
                "responsive_layout": "Implement responsive search layout with proper spacing"
            }
        },
        "ui_patterns": {
            "search_layout": "Use flex justify-between for search input and action buttons",
            "responsive_design": "Stack search and buttons on mobile, inline on desktop",
            "input_styling": "Use consistent input styling with proper focus states",
            "button_positioning": "Position action buttons appropriately relative to search input"
        },
        "testing_patterns": {
            "search_functionality_testing": "Test debounced input, empty states, and search result pagination",
            "validation_testing": "Test search input validation and sanitization",
            "performance_testing": "Test search performance with large datasets",
            "ui_testing": "Test search UI responsiveness and user interactions"
        },
        "fuzzy_search_implementation": {
            "description": "Custom fuzzy search with typo tolerance using PHP similarity matching",
            "core_principles": {
                "spatie_searchable_limitation": "Spatie Laravel Searchable only uses LIKE queries - does NOT provide fuzzy matching or typo tolerance",
                "custom_implementation_required": "For typo tolerance, implement custom fuzzy search using PHP's similar_text() function",
                "similarity_threshold": "Use configurable similarity threshold (default 70%) to balance typo tolerance vs precision",
                "multi_field_search": "Calculate similarity scores for both name and email fields, use highest score",
                "substring_boost": "Boost similarity score when search term is contained in field (exact substring match)",
                "relevance_ranking": "Sort results by similarity score (highest first) for best user experience"
            },
            "implementation_pattern": {
                "get_all_candidates": "Get all users for business (no initial filtering)",
                "calculate_similarity": "Use similar_text() to calculate similarity percentage for each field",
                "apply_boosts": "Boost score to 80% if search term is substring of field",
                "filter_by_threshold": "Filter results to only include users with similarity >= threshold (70%)",
                "sort_by_relevance": "Sort by similarity score descending, then by name",
                "performance_consideration": "For large datasets, consider limiting initial candidate set or using database-level fuzzy matching"
            },
            "pagination_integration": {
                "manual_pagination_required": "Fuzzy search with in-memory filtering requires manual pagination using collection slicing (cannot use Laravel's paginate() which requires a query builder)",
                "pagination_calculation": "Calculate offset = (currentPage - 1) * perPage, then slice the filtered collection: $items = $filteredUsers->slice($offset, $perPage)->values()",
                "pagination_metadata": "Manually create pagination metadata array with current_page, last_page (max 1 when total is 0), per_page, total, from (null when total is 0), to (null when total is 0)",
                "code_example": "$currentPage = $request->get('page', 1); $total = $filteredUsers->count(); $offset = ($currentPage - 1) * $perPage; $items = $filteredUsers->slice($offset, $perPage)->values(); $lastPage = $total > 0 ? (int) ceil($total / $perPage) : 1;",
                "non_search_pagination": "For non-search queries, use Laravel's built-in paginate() method which handles pagination automatically",
                "consistent_per_page": "Use consistent per_page defaults (e.g., 15 for user lists) across the application"
            },
            "frontend_pagination_integration": {
                "search_reset_to_page_1": "When performing a new search, reset to page 1 by including page: '1' in search query parameters",
                "preserve_search_in_pagination": "When navigating pages, preserve the search query in pagination URLs by including the search parameter in goToPage function",
                "partial_reload": "Use router.get() with only: ['users', 'pagination'] to avoid reloading unrelated props like metrics",
                "pagination_ui": "Reuse pagination UI pattern from other pages (e.g., Users/Show.vue) with paginationPages computed property and goToPage function"
            },
            "code_example": {
                "similarity_calculation": "$allUsers->map(function ($user) use ($searchLower) { $name = mb_strtolower($user->name ?? '', 'UTF-8'); similar_text($searchLower, $name, $nameSimilarity); if (str_contains($name, $searchLower)) { $nameSimilarity = max($nameSimilarity, 80); } return ['user' => $user, 'similarity' => $nameSimilarity]; })",
                "filtering_and_sorting": "->filter(fn($item) => $item['similarity'] >= 70)->sortByDesc('similarity')->pluck('user')",
                "manual_pagination": "$currentPage = $request->get('page', 1); $total = $filteredUsers->count(); $offset = ($currentPage - 1) * $perPage; $items = $filteredUsers->slice($offset, $perPage)->values(); $lastPage = $total > 0 ? (int) ceil($total / $perPage) : 1; $pagination = ['current_page' => (int) $currentPage, 'last_page' => $lastPage, 'per_page' => $perPage, 'total' => $total, 'from' => $total > 0 ? $offset + 1 : null, 'to' => $total > 0 ? min($offset + $perPage, $total) : null];"
            },
            "threshold_guidance": {
                "40_percent": "More lenient - catches more typos but may include false positives",
                "70_percent": "Balanced - good typo tolerance while maintaining precision (recommended)",
                "80_percent": "Strict - only very close matches, fewer false positives but may miss some typos"
            },
            "spatie_searchable_interface": {
                "interface_requirement": "If using Spatie Searchable, models must implement Spatie\\Searchable\\Searchable interface",
                "method_name": "Interface requires getSearchResult() method (NOT getSearchableResult())",
                "return_type": "Method must return Spatie\\Searchable\\SearchResult instance",
                "example": "public function getSearchResult(): SearchResult { return new SearchResult($this, $this->name, route('users.show', $this->id)); }"
            },
            "related_files": [
                "app/Http/Controllers/UserController.php",
                "app/Models/User.php",
                "resources/js/pages/Users/Index.vue"
            ]
        }
    },
    "stamp_card_pagination_patterns": {
        "description": "Consistent pagination for dashboard and user stamp card views with Inertia and shared UI components",
        "backend_patterns": {
            "dashboard_all_cards": "Always merge DashboardService::buildPropsForUser() with buildAllCardsProps() so redemption and user stats render alongside paginated stamp cards",
            "per_page_defaults": "Default to 5 cards per page in DashboardService::buildAllCardsProps() and UserStampCardsService::buildUserStampCards(); update docs/tests if this constant changes",
            "active_filter_pagination": "When filtering to active cards, wrap the filtered collection in a manual LengthAwarePaginator with explicit path/query options to keep links accurate",
            "service_methods": "Expose getAllUserStampCardsPaginated() in StampCardService for reusable pagination logic across controllers/services"
        },
        "frontend_patterns": {
            "pagination_component": "Render FrontendPagination with mt-6 spacing, supplying currentPage/itemsPerPage/totalItems derived from paginator metadata",
            "url_management": "handlePageChange must rebuild the current URL, preserving query params and stripping page when navigating to page 1",
            "partial_reload": "Use router.get(targetUrl, {}, { preserveState: true, preserveScroll: true, only: ['stampCards'], replace: true }) to avoid reloading unrelated props",
            "data_access": "Components must iterate over stampCards.data and compute cardIndexOffset from paginator metadata"
        },
        "testing_patterns": {
            "backend_assertions": "Assert paginator metadata with ->where('stampCards.per_page', 5) and ->has('stampCards.data', 5) instead of indexing stampCards directly",
            "frontend_mocks": "Update Vitest fixtures to include stampCards.data, per_page, current_page, total, and verify router.get is called with preserved pathname/query",
            "regression_coverage": "Add assertions ensuring redemptionStats/userStats remain present when hitting paginated dashboard routes",
            "filter_testing": "Cover both activecards=true and default views to ensure manual paginator wiring returns consistent metadata"
        },
        "lessons": [
            "Moving to server pagination requires touching both backend services and frontend componentsdocument default perPage values to keep tests in sync",
            "Inertia partial reloads with only: ['stampCards'] keep dashboards responsive while paginating large datasets",
            "Manual LengthAwarePaginator construction is necessary when filtering in-memory collections to maintain correct pagination links"
        ]
    },
    "ui_enhancement_patterns": {
        "description": "Modern UI enhancement patterns including floating action buttons and smooth transitions",
        "floating_action_buttons": {
            "core_principles": {
                "conditional_visibility": "Show floating buttons only when appropriate (scroll threshold, data conditions)",
                "smooth_transitions": "Implement opacity, translate, and scale effects for gentle appearance",
                "positioning_considerations": "Position floating buttons to avoid overlapping with existing UI elements",
                "smooth_scrolling": "Use scrollTo({ top: 0, behavior: 'smooth' }) for smooth navigation",
                "accessibility": "Provide proper titles and ARIA labels for floating buttons"
            },
            "implementation_patterns": {
                "scroll_detection": "Use window.scrollY to detect scroll position for button visibility",
                "transition_classes": "Use Vue Transition component with proper enter/leave classes",
                "event_listener_management": "Properly add/remove scroll event listeners in onMounted/onUnmounted",
                "conditional_logic": "Combine scroll position with data conditions for smart visibility"
            },
            "styling_patterns": {
                "fixed_positioning": "Use fixed positioning with appropriate z-index for floating buttons",
                "shadow_effects": "Add shadow-lg for proper depth and visibility",
                "hover_states": "Implement proper hover states for better user feedback",
                "icon_usage": "Use consistent SVG icons for floating button actions"
            }
        },
        "responsive_design_patterns": {
            "mobile_first_approach": "Start with mobile layout and enhance for larger screens",
            "responsive_layouts": "Use flex-col sm:flex-row for responsive stacking",
            "touch_target_sizing": "Ensure buttons and inputs are appropriately sized for mobile",
            "consistent_spacing": "Maintain consistent spacing patterns across responsive breakpoints",
            "breakpoint_testing": "Test layouts on different screen sizes and orientations"
        },
        "transition_patterns": {
            "smooth_animations": "Use CSS transitions for smooth state changes",
            "vue_transitions": "Leverage Vue Transition component for complex animations",
            "performance_considerations": "Use transform and opacity for better performance",
            "accessibility": "Respect user's motion preferences for accessibility"
        },
        "testing_patterns": {
            "floating_button_testing": "Test visibility conditions and smooth scrolling behavior",
            "responsive_testing": "Test layouts on different screen sizes and orientations",
            "transition_testing": "Test animation states and timing",
            "accessibility_testing": "Test keyboard navigation and screen reader compatibility"
        }
    },
    "smooth_loading_patterns": {
        "description": "Smooth loading patterns for coordinated UI element loading using Promise.all()",
        "core_principles": {
            "coordinated_loading": "Wait for multiple async operations to complete before updating UI state",
            "promise_all_pattern": "Use Promise.all() to coordinate multiple loading states",
            "eliminate_janky_transitions": "Prevent UI elements from appearing at different times",
            "professional_user_experience": "Ensure smooth, polished loading transitions"
        },
        "implementation_patterns": {
            "promise_all_coordination": {
                "description": "Use Promise.all() to wait for multiple async operations",
                "example": "await Promise.all([waitForQRCodeLoad(), waitForTimerReady()])",
                "benefits": [
                    "Eliminates janky transitions",
                    "Ensures all elements load together",
                    "Professional user experience",
                    "Consistent with established patterns (TwoFactorAuthenticationForm)"
                ]
            },
            "helper_function_pattern": {
                "description": "Create dedicated helper functions for each loading operation",
                "qr_code_loading": "waitForQRCodeLoad() - creates temporary image element to detect load",
                "timer_initialization": "waitForTimerReady() - waits for timer setup delay",
                "error_handling": "Resolve promises even on error to prevent hanging"
            },
            "loading_state_management": {
                "description": "Coordinate multiple loading states effectively",
                "reset_states": "Reset all loading states at the beginning of operation",
                "single_transition": "Update all loading states together after Promise.all() resolves",
                "template_conditions": "Use combined conditions in templates (qrCodeUrl && isQRCodeLoaded)"
            }
        },
        "vue_specific_patterns": {
            "image_loading_detection": {
                "description": "Detect when images are actually loaded, not just when URL is set",
                "implementation": "Create temporary Image() element with onload/onerror handlers",
                "fallback_handling": "Resolve promise even on error to prevent hanging"
            },
            "timer_coordination": {
                "description": "Coordinate timer initialization with other loading operations",
                "delay_pattern": "Use setTimeout() for timer initialization delays",
                "promise_wrapping": "Wrap setTimeout in Promise for Promise.all() compatibility"
            },
            "template_optimization": {
                "description": "Optimize template conditions for smooth loading",
                "combined_conditions": "Use multiple conditions to ensure all elements are ready",
                "placeholder_management": "Show placeholders until all elements are ready"
            }
        },
        "testing_patterns": {
            "loading_state_testing": "Test that loading states coordinate properly",
            "promise_resolution_testing": "Test that Promise.all() resolves correctly",
            "error_handling_testing": "Test graceful handling of loading errors",
            "ui_transition_testing": "Test smooth transitions between loading and loaded states"
        },
        "best_practices": {
            "always_coordinate": "Always coordinate multiple loading operations when they appear together",
            "use_established_patterns": "Follow patterns from existing components (TwoFactorAuthenticationForm)",
            "error_resilience": "Ensure loading operations don't hang on errors",
            "user_experience_first": "Prioritize smooth user experience over individual element loading"
        },
        "common_use_cases": {
            "qr_code_with_timer": "QR code generation with countdown timer",
            "image_with_text": "Image loading with accompanying text content",
            "data_with_ui": "Data fetching with UI element initialization",
            "multiple_async_operations": "Any scenario with multiple async operations that should appear together"
        }
    },
    "route_security_middleware": {
        "description": "Route security patterns with proper middleware combinations for admin-only access",
        "middleware_combination_patterns": {
            "core_principles": {
                "combined_middleware": "Use ['auth:sanctum', 'verified', 'can:admin'] for admin-only routes",
                "never_can_admin_alone": "Never use can:admin alone as it causes 403 errors for guest users",
                "proper_guest_handling": "Guest users should be redirected to login, not get 403 errors",
                "test_guest_access": "Always test that guest users get proper redirects"
            },
            "implementation_patterns": {
                "route_grouping": "Group admin routes under combined middleware for consistency",
                "middleware_order": "Order matters: auth:sanctum first, then verified, then can:admin",
                "guest_redirect_behavior": "Combined middleware ensures proper redirect to login for guests",
                "non_admin_403_behavior": "Authenticated non-admin users get 403 Forbidden"
            },
            "testing_patterns": {
                "guest_access_tests": "Expect assertRedirect('/login') for guest users",
                "admin_access_tests": "Expect successful operations for admin users",
                "non_admin_access_tests": "Expect 403 Forbidden for authenticated non-admin users",
                "middleware_testing": "Test all middleware combinations properly"
            }
        },
        "data_structure_consistency": {
            "description": "Ensuring backend returns exact structure expected by frontend components",
            "core_principles": {
                "match_frontend_expectations": "Backend must return exact structure expected by frontend",
                "verify_data_flow": "Test that controller returns proper data structure",
                "update_test_assertions": "Update test assertions when changing data structures",
                "test_pagination_metadata": "Ensure pagination metadata is properly structured"
            },
            "common_patterns": {
                "flattened_arrays": "Some components expect arrays, not objects with data property",
                "separate_pagination": "Test pagination metadata separately from data",
                "controller_structure": "Controllers should return consistent data structures",
                "frontend_compatibility": "Ensure data structure matches frontend component props"
            }
        },
        "benefits": [
            "Proper guest user handling with redirects instead of 403 errors",
            "Consistent admin route protection across the application",
            "Better user experience with proper authentication flow",
            "Easier testing with predictable behavior patterns"
        ]
    },
    "frontend_test_expectations": {
        "description": "Frontend test expectation patterns for router.post calls and data structures",
        "router_post_expectations": {
            "core_principles": {
                "use_object_containing": "Always use expect.objectContaining() for router.post calls",
                "never_exact_matching": "Never use exact object matching as implementation includes callbacks",
                "match_preserve_state": "Some routes use preserveState: true, others don't include it",
                "verify_preserve_scroll": "Most routes use preserveScroll: true"
            },
            "implementation_patterns": {
                "callback_functions": "Router.post calls include onError/onSuccess callback functions",
                "preserve_state_behavior": "Different routes have different preserveState behavior",
                "preserve_scroll_consistency": "preserveScroll: true is used consistently",
                "test_expectation_updates": "Update test expectations when implementation changes"
            },
            "testing_patterns": {
                "object_containing_usage": "Use expect.objectContaining() to match partial objects",
                "preserve_state_testing": "Test preserveState behavior based on actual implementation",
                "callback_function_handling": "Account for onError/onSuccess callbacks in test expectations",
                "implementation_verification": "Verify actual router.post call parameters"
            }
        },
        "data_structure_testing": {
            "description": "Testing data structures returned by backend controllers",
            "core_principles": {
                "test_exact_structure": "Frontend expects specific data structure from backend",
                "verify_pagination_separately": "Test pagination metadata separately from data",
                "test_flattened_arrays": "Some components expect arrays, not objects with data property",
                "update_assertions": "Update test assertions when changing data structures"
            },
            "common_patterns": {
                "array_vs_object": "Distinguish between arrays and objects with data property",
                "pagination_metadata": "Test pagination metadata structure separately",
                "controller_response_format": "Ensure controller returns expected format",
                "frontend_component_compatibility": "Match data structure to component prop expectations"
            }
        },
        "benefits": [
            "More reliable frontend tests that match actual implementation",
            "Better understanding of router.post call parameters",
            "Consistent test expectations across the application",
            "Easier debugging when tests fail"
        ]
    },
    "multi_tenant_architecture": {
        "description": "Multi-tenant architecture implementation with business_id scoping and automatic data isolation",
        "core_architecture": {
            "tenant_resolution": {
                "pattern": "User-based tenant resolution using authenticated user's business_id",
                "mechanism": "Global scope (BusinessScope) automatically filters all queries by user's business_id",
                "implementation": "app/Models/Scopes/BusinessScope.php applies WHERE clause to tenant tables",
                "benefits": "Automatic data isolation, secure by default, cannot be bypassed without explicit calls"
            },
            "database_schema": {
                "business_id_columns": "Added to users, stamp_cards, rewards, stamp_card_configurations, teams, stamp_cards_rewards, personal_access_tokens",
                "foreign_keys": "All business_id columns reference businesses.id with onDelete('cascade')",
                "indexes": "All business_id columns indexed for query performance",
                "unique_constraints": "Updated to include business_id for multi-tenant support"
            },
            "global_scope_implementation": {
                "file": "app/Models/Scopes/BusinessScope.php",
                "models_applied": [
                    "StampCard",
                    "Reward",
                    "Team",
                    "StampCardConfiguration",
                    "StampCardReward"
                ],
                "models_excluded": ["User", "Business"],
                "table_qualification": "CRITICAL: Uses {$table}.business_id to avoid ambiguous column errors in joins",
                "resolveBusinessId": "Gets business_id from auth()->user()->business_id"
            }
        },
        "access_patterns": {
            "controllers": "Set business_id from auth()->user()->business_id when creating records",
            "services": "Include business_id in pivot table attachments and record creation",
            "tests": "Use CreatesBusinessData trait for consistent test data with shared Business instance",
            "factories": "Include business_id in default factory state using Business::factory()"
        },
        "test_infrastructure": {
            "creates_business_data_trait": "tests/Traits/CreatesBusinessData.php provides reusable test helpers",
            "methods": [
                "setUpBusiness() - Create or reuse single Business instance",
                "createUser() - Create user with business_id",
                "createAdminUser() - Create admin user with business_id",
                "createReward() - Create reward with business_id",
                "createStampCard() - Create stamp card with business_id",
                "createStampCardConfiguration() - Create configuration with business_id"
            ],
            "benefits": [
                "Consistent test data across all tests",
                "Automatic business_id assignment",
                "Single source of truth for test setup",
                "Prevents business_id mismatches in tests"
            ]
        },
        "security_patterns": {
            "never_accept_from_input": "NEVER accept business_id from user input - always use auth()->user()->business_id",
            "always_set_from_auth": "ALWAYS set business_id from authenticated user when creating records",
            "secure_by_default": "Global scope enforces isolation - cannot be bypassed without explicit withoutGlobalScope() calls",
            "cascade_deletes": "All related data deleted when business is deleted via foreign key constraints"
        },
        "common_issues": {
            "sql_ambiguous_column": {
                "error": "Column 'business_id' in where clause is ambiguous",
                "cause": "Multiple tables in join have business_id column",
                "fix": "Use table-qualified column names in BusinessScope: where('{$table}.business_id', $businessId)"
            },
            "unique_constraint_violation": {
                "error": "Cannot drop index: needed in a foreign key constraint",
                "cause": "Trying to drop unique index before dropping foreign keys",
                "fix": "Drop foreign keys first, then drop unique constraint, then add business_id"
            },
            "test_business_mismatch": {
                "error": "Expected response status code 200 but received 404",
                "cause": "Multiple Business instances created in tests, causing business_id mismatches",
                "fix": "Use CreatesBusinessData trait to share single Business instance"
            },
            "missing_is_active": {
                "error": "Expected response status code 200 but received 404",
                "cause": "StampCardConfiguration not marked as active",
                "fix": "Always set is_active => true when creating configurations in tests"
            }
        },
        "migration_patterns": {
            "data_population": {
                "approach": "Populate existing records with business_id = 1 for 'Default Business'",
                "migration_order": [
                    "Add nullable business_id columns",
                    "Populate existing data with default business_id",
                    "Update models with global scope",
                    "Update controllers to set business_id",
                    "Update services and factories",
                    "Create test infrastructure"
                ]
            },
            "backward_compatibility": {
                "existing_data": "All existing records assigned to 'Default Business' (ID = 1)",
                "data_loss": "No data loss during migration",
                "transition": "Smooth transition from singleton to multi-tenant"
            }
        },
        "best_practices": {
            "global_scope": [
                "Always use table qualification to prevent ambiguous column errors",
                "Resolve business_id from authenticated user",
                "Apply to all tenant models for automatic filtering"
            ],
            "controllers": [
                "Always set business_id from authenticated user on record creation",
                "Don't trust user input - never accept business_id from request data",
                "Use auth()->user()->business_id as source of truth"
            ],
            "testing": [
                "Use CreatesBusinessData trait for single source of test data",
                "Use shared Business instance across all tests in a class",
                "Explicitly set is_active for configurations in tests",
                "Avoid factory defaults for business_id",
                "Always use APP_ENV=testing for database isolation"
            ]
        },
        "key_lessons": [
            "Always use table-qualified column names in global scopes to avoid ambiguous column errors",
            "Drop foreign key constraints before dropping unique indexes in migrations",
            "Start with nullable columns, populate data, then make required",
            "Create test helpers (traits) to enforce consistent business_id across tests",
            "Global scopes are powerful but require careful implementation with table qualification",
            "Always set business_id from authenticated user, never from request",
            "Use single shared Business instance in tests to avoid business_id mismatches",
            "Explicitly set is_active flags in test configurations",
            "Factories should include business_id relationships by default",
            "User-based tenant resolution is simple and effective for single-business users",
            "Use Model::query() when leveraging global scopes - they apply automatically to filter by business_id",
            "Multi-tenant authentication must require business_id when multiple users exist with same email",
            "Password reset must also require business_id when multiple users exist with same email"
        ],
        "multi_tenant_authentication": {
            "description": "Authentication and password reset patterns for multi-tenant applications where users can have same email across businesses",
            "problem": "When multiple users exist with the same email across different businesses, authentication without business_id logs into the first user found (wrong business)",
            "solution": {
                "authentication_logic": "Require business_id when multiple users exist with the same email",
                "password_reset_logic": "Require business_id when multiple users exist with the same email",
                "validation_error": "Show clear error: 'Multiple accounts found with this email. Please select a business.'",
                "implementation": "Check user count before querying, throw ValidationException if count > 1 and business_id is null"
            },
            "frontend_requirements": {
                "form_initialization": "Include business_id: null in initial useForm() definition",
                "business_selection": "User must select business from dropdown before login",
                "form_submission": "form.post() will include business_id when it's in initial form definition"
            },
            "backend_requirements": {
                "findUserByEmailOrPhone": "Check user count, require business_id if multiple users exist",
                "password_reset_controller": "Check user count, require business_id if multiple users exist",
                "error_messages": "Clear validation errors guiding user to select business"
            },
            "backward_compatibility": {
                "single_user": "When only one user exists with email, business_id is optional (backward compatible)",
                "multiple_users": "When multiple users exist, business_id is REQUIRED"
            },
            "test_patterns": {
                "test_selected_business": "Test that user logs into selected business when business_id provided",
                "test_validation_error": "Test that validation error shown when business_id missing and multiple users exist",
                "test_single_user": "Test that single user can login without business_id (backward compatible)"
            },
            "key_lessons": [
                "Always include business_id in initial form definition, even if null",
                "Check user count before querying - require business_id if multiple users exist",
                "Apply same logic to both authentication and password reset",
                "Show clear validation errors guiding users to select business",
                "Maintain backward compatibility for single-user scenarios"
            ]
        },
        "related_docs": [
            "docs/MULTI_TENANT_ARCHITECTURE.md",
            "docs/LESSONS_LEARNED_UPGRADING_TO_MULTI_TENANT.json",
            "app/Models/Scopes/BusinessScope.php",
            "tests/Traits/CreatesBusinessData.php"
        ]
    },
    "frontend_test_component_mocking": {
        "link_component_requirement": {
            "description": "CRITICAL: All Inertia test mocks must include Link component when components use it",
            "problem": "Components using Link from @inertiajs/vue3 fail with 'No Link export is defined' error",
            "solution": {
                "include_in_all_mocks": "Always include Link component in ALL Inertia mocks, even if component doesn't currently use it",
                "mock_structure": "Link: { name: 'Link', props: ['href'], template: '<a :href=\"href\"><slot /></a>' }",
                "affected_files": "All test files that use components importing Link from @inertiajs/vue3"
            },
            "prevention": {
                "default_mock_template": "Include Link in all Inertia mocks by default as a best practice",
                "test_file_updates": "When adding Link to components, immediately update all related test mocks"
            },
            "benefits": [
                "Prevents test failures due to missing Link export",
                "Consistent mock structure across all test files",
                "Future-proofs tests when components start using Link"
            ]
        },
        "url_parameter_expectations": {
            "description": "Update test expectations when routes add query parameters",
            "problem": "Tests fail when routes add query parameters but test expectations don't include them",
            "solution": {
                "update_expectations": "Update test expectations to match actual URL format with query parameters",
                "example": "RewardIcon.test.js: Expect '/users/123/loyalty-cards?activecards=true' instead of '/users/123/loyalty-cards'",
                "route_changes": "When modifying routes to include query parameters, update all related test expectations"
            },
            "prevention": {
                "review_route_changes": "Review route changes and identify all affected test files",
                "update_systematically": "Update all related test expectations when routes change"
            }
        }
    },
    "session_storage_patterns": {
        "completed_card_visibility": {
            "description": "Session-based visibility for completed stamp cards",
            "core_principles": {
                "session_storage": "Store completed card IDs in session (completed_card_ids array) for temporary visibility",
                "multiple_completion_paths": "Add cards to session when completed via BOTH increment routes (current_stamps = total_stamps) AND redemption routes (all rewards redeemed)",
                "filter_logic": "Completed cards in session should be shown regardless of has_redeemable_rewards status, as long as they're not expired",
                "session_expiry": "Completed cards remain visible only for current session, cleared on logout or session expiry"
            },
            "implementation_patterns": {
                "increment_completion": {
                    "when": "When current_stamps reaches total_stamps via increment route",
                    "action": "Store card ID in session before creating new card",
                    "location": "app/Services/StampCardService.php incrementStampWithAutoCreation() method"
                },
                "redemption_completion": {
                    "when": "When all rewards are redeemed via redemption route",
                    "action": "Store card ID in session after marking as completed",
                    "location": "routes/web.php stamp-cards.redeem-reward route"
                },
                "filter_display": {
                    "logic": "Show completed cards from session if they're not expired, regardless of has_redeemable_rewards",
                    "location": "app/Services/StampCardService.php filterStampCardsForDisplay() method"
                }
            },
            "testing_patterns": {
                "session_visibility": "Test that completed cards are visible in current session even after all rewards redeemed",
                "session_expiry": "Test that completed cards are filtered out after session clears",
                "multiple_cards": "Test that both completed card and new card are visible in session",
                "filter_logic": "Test that completed cards in session are shown regardless of has_redeemable_rewards"
            },
            "benefits": [
                "Better user experience - users see completed cards in current session",
                "Automatic cleanup - completed cards filtered out after session expires",
                "Consistent behavior - cards visible regardless of redemption status during session"
            ]
        }
    },
    "flash_message_behavior": {
        "completion_only_messages": {
            "description": "Flash messages should only be shown when stamp cards are completed",
            "core_principles": {
                "conditional_messages": "Only show flash messages when current_stamps equals total_stamps (card completed)",
                "no_incremental_messages": "Do NOT show 'Stamp added successfully!' for every increment",
                "completion_messages": "Show 'Congratulations! Your loyalty card is complete!' only when card is completed",
                "service_method_returns": "incrementStampWithAutoCreation() returns null for message/style when card is not completed"
            },
            "implementation_patterns": {
                "service_method": {
                    "location": "app/Services/StampCardService.php incrementStampWithAutoCreation()",
                    "behavior": "Returns message/style only when isNowFull && !wasFullBefore",
                    "returns_null": "Returns null for message/style when card is not completed"
                },
                "route_handling": {
                    "location": "routes/web.php stamp-cards.increment and users.stamps.increment routes",
                    "behavior": "Only set flash message if result['message'] is not null",
                    "condition": "if ($result['message']) { return back()->with('flash.banner', ...) }"
                }
            },
            "testing_patterns": {
                "incremental_tests": "Update tests to expect missing flash messages when cards are not completed",
                "completion_tests": "Test that completion messages appear only when cards are completed",
                "assertion_updates": "Change from assertSessionHas() to assertSessionMissing() for non-completion increments"
            },
            "test_updates": {
                "stamp_card_management": "test_admin_can_increment_stamp_card_stamps() expects missing flash message",
                "stamp_management_api": "test_increment_stamp_success() expects missing flash message",
                "completion_tests": "Test completion messages separately from incremental operations"
            },
            "benefits": [
                "Less UI clutter - no unnecessary success messages",
                "Better user experience - messages only when meaningful",
                "Clearer feedback - completion messages stand out more"
            ]
        }
    },
    "has_redeemable_reward_logic": {
        "correct_qualification_criteria": {
            "description": "RewardIcon should ONLY show when there's an unredeemed reward at an earned position",
            "core_principles": {
                "qualification_criteria": "User has redeemable reward if ANY unexpired card has: has_redeemable_rewards = true (which checks reward_position <= current_stamps AND is_redeemed = false)",
                "no_stamp_threshold": "Users with 0 stamps should NOT show the reward icon - they haven't earned any reward positions yet",
                "earned_position_requirement": "Icon should ONLY show for unredeemed rewards at positions that have been earned (reward_position <= current_stamps)",
                "multiple_configurations": "Logic works correctly across multiple cards with different configurations"
            },
            "implementation_patterns": {
                "controller_logic": {
                    "location": "app/Http/Controllers/UserController.php index() method",
                    "calculation": "hasRedeemableReward = $unexpiredCards->contains(function ($card) { return $card->has_redeemable_rewards; })",
                    "explanation": "Only check has_redeemable_rewards - this already verifies reward_position <= current_stamps AND is_redeemed = false",
                    "previous_bug": "Previous logic incorrectly checked current_stamps > 0 && current_stamps < total_stamps, which showed icon for users with 0 stamps",
                    "expiration_check": "Only considers cards where expires_at is null or expires_at->isFuture()"
                },
                "has_redeemable_rewards_calculation": {
                    "location": "app/Models/StampCard.php calculateHasRedeemableRewards() method",
                    "logic": "Returns true if: card not expired AND any reward exists where reward_position <= current_stamps AND is_redeemed = false"
                },
                "test_updates": {
                    "zero_stamps": "Test expects has_redeemable_reward = false for users with 0 stamps",
                    "below_threshold": "Test expects has_redeemable_reward = false for users below reward threshold",
                    "earned_rewards": "Test expects has_redeemable_reward = true for users with earned, unredeemed rewards",
                    "multiple_configurations": "Test that logic works correctly with multiple cards across different configurations"
                }
            },
            "testing_patterns": {
                "zero_stamps_users": "Test that users with 0 stamps do NOT show reward icon",
                "below_threshold_cards": "Test that cards below reward threshold do NOT show reward icon",
                "earned_rewards": "Test that users with earned, unredeemed rewards DO show reward icon",
                "multiple_cards_different_configs": "Test that logic correctly handles multiple cards with different configurations",
                "redeemed_rewards": "Test that users with only redeemed rewards do NOT show reward icon"
            },
            "benefits": [
                "Accurate representation - icon only shows when rewards can actually be redeemed",
                "Better user experience - no false positives for users who haven't earned anything",
                "Clear logic - relies on has_redeemable_rewards which already contains the correct business logic"
            ],
            "bug_fixes": {
                "session_35": {
                    "issue": "RewardIcon was showing for newly created users with 0 stamps",
                    "root_cause": "Logic checked current_stamps < total_stamps without requiring current_stamps > 0",
                    "fix": "Changed to only check has_redeemable_rewards, which requires earned positions (reward_position <= current_stamps)",
                    "impact": "Users with 0 stamps no longer incorrectly show reward icon"
                }
            }
        }
    },
    "configuration_activation_patterns": {
        "preserve_fields_on_update": {
            "description": "When editing configurations, preserve both is_active and reward_positions if not explicitly provided",
            "core_principles": {
                "is_active_preservation": "When editing configuration, preserve existing is_active value if not provided in update request",
                "reward_positions_preservation": "Preserve reward_positions if not in validatedData or if empty array is sent when existing has data",
                "explicit_updates": "Both fields can be changed when explicitly provided, but should be preserved when not provided",
                "no_side_effects": "Editing configuration should not accidentally change activation state or reward positions"
            },
            "implementation_patterns": {
                "controller_logic": {
                    "location": "app/Http/Controllers/StampCardConfigurationController.php update() method",
                    "is_active_preservation": "if (! array_key_exists('is_active', $validatedData)) { $validatedData['is_active'] = $stampCardConfiguration->is_active; }",
                    "reward_positions_preservation": "if (! array_key_exists('reward_positions', $validatedData) || (is_array($validatedData['reward_positions']) && empty($validatedData['reward_positions']) && ! empty($stampCardConfiguration->reward_positions))) { $validatedData['reward_positions'] = $stampCardConfiguration->reward_positions; }",
                    "previous_bug": "Previous logic defaulted is_active to false when not provided, causing active configurations to become inactive when edited"
                },
                "versioning_logic": {
                    "rule": "Versioning logic should NOT create new configuration when activating/deactivating",
                    "behavior": "When is_active changes, always update existing configuration in place (no versioning)",
                    "location": "app/Http/Controllers/StampCardConfigurationController.php"
                },
                "database_verification": {
                    "description": "Always verify data is actually saved to database, not just in memory",
                    "testing_pattern": "Use both Eloquent queries and raw database queries to verify persistence",
                    "example": "Query directly from database using DB::table() and json_decode() to verify JSON columns"
                }
            },
            "testing_patterns": {
                "is_active_preservation": "Test that is_active is preserved when editing configuration without providing is_active",
                "reward_positions_preservation": "Test that reward_positions are preserved when not provided or when empty array is sent",
                "both_preserved": "Test that both is_active and reward_positions are preserved when neither is provided",
                "explicit_changes": "Test that both fields can still be changed when explicitly provided",
                "database_assertions": "Assert both fields exist in database before AND after update using both Eloquent and raw queries",
                "empty_array_handling": "Test that empty arrays from frontend don't overwrite existing reward_positions"
            },
            "benefits": [
                "Prevents accidental data loss during configuration editing",
                "Ensures is_active and reward_positions are preserved when only editing other fields",
                "Better user experience - no unexpected state changes when editing",
                "Clearer separation of concerns - editing doesn't accidentally change activation state"
            ],
            "bug_fixes": {
                "session_35": {
                    "issue": "Editing configuration was setting is_active to false even when not provided",
                    "root_cause": "Logic defaulted is_active to false when not in validatedData",
                    "fix": "Preserve existing is_active value when not provided: if (! array_key_exists('is_active', $validatedData)) { $validatedData['is_active'] = $stampCardConfiguration->is_active; }",
                    "impact": "Active configurations remain active when edited, inactive configurations remain inactive"
                }
            }
        },
        "configuration_deletion": {
            "description": "Configuration deletion patterns and authorization",
            "core_principles": {
                "active_configurations": "Both active and inactive configurations can be deleted",
                "authorization": "Only admin users can delete configurations",
                "foreign_key_handling": "configuration_id foreign key uses SET NULL, so deletion sets related stamp cards' configuration_id to null"
            },
            "implementation_patterns": {
                "controller_logic": {
                    "location": "app/Http/Controllers/StampCardConfigurationController.php destroy() method",
                    "authorization": "Check admin authorization before allowing deletion",
                    "no_active_check": "No restriction on deleting active configurations - removed previous limitation",
                    "error_handling": "Frontend should handle errors gracefully with onError callback"
                },
                "frontend_handling": {
                    "location": "resources/js/Components/StampCardConfigurationDeleteModal.vue",
                    "error_handling": "Add onError callback to handle deletion failures",
                    "form_submission": "Use form.delete() with proper route and error handling"
                }
            },
            "testing_patterns": {
                "authorization": "Test that only admin users can delete configurations",
                "active_deletion": "Test that active configurations can be deleted",
                "inactive_deletion": "Test that inactive configurations can be deleted",
                "error_handling": "Test error handling when deletion fails"
            },
            "benefits": [
                "Flexible configuration management - can delete any configuration",
                "Proper authorization ensures security",
                "Graceful error handling provides better user experience"
            ]
        }
    },
    "service_layer_separation": {
        "stampcard_service_readonly": {
            "description": "StampCardService should be read-only with respect to StampCardConfiguration - it should only read configurations, never update them",
            "core_principles": {
                "service_responsibility": "StampCardService handles stamp card operations (create, update, increment, decrement)",
                "configuration_access": "StampCardService reads configurations using getActiveConfigurationForBusiness()",
                "no_configuration_updates": "StampCardService should NEVER update StampCardConfiguration models"
            },
            "implementation_patterns": {
                "configuration_queries": {
                    "method": "getActiveConfigurationForBusiness() - gets most recent active configuration by id desc",
                    "rule": "Always use orderBy('id', 'desc') to get most recent configuration",
                    "location": "app/Services/StampCardService.php"
                },
                "removed_methods": {
                    "ensureSingleActiveConfiguration": "Removed - service should not manage configuration activation state",
                    "update_stamp_card_configuration": "Service should not have methods that update configurations"
                },
                "activation_flow": {
                    "controller_responsibility": "StampCardConfigurationController handles all configuration updates",
                    "service_responsibility": "StampCardService uses updated configuration after controller saves it",
                    "activation_method": "activateStampCardsForBusiness() uses StampCardService methods to create/update stamp cards"
                }
            },
            "testing_patterns": {
                "service_readonly": "Verify StampCardService never calls update() or save() on StampCardConfiguration",
                "configuration_access": "Test that service correctly retrieves most recent active configuration",
                "activation_integration": "Test that activation creates stamp cards using correct configuration data"
            },
            "benefits": [
                "Clear separation of concerns - services handle their domain, controllers handle updates",
                "Prevents accidental configuration modifications during stamp card operations",
                "Easier to debug - configuration changes only happen in controllers"
            ]
        },
        "configuration_management": {
            "controller_responsibility": {
                "description": "StampCardConfigurationController is responsible for all configuration updates",
                "methods": [
                    "update()",
                    "store()",
                    "destroy()",
                    "activateStampCardsForBusiness()"
                ],
                "activation_logic": "When activating, controller updates configuration, then uses StampCardService to create/update stamp cards"
            },
            "service_usage": {
                "description": "StampCardService is used by controller to create/update stamp cards after configuration changes",
                "methods": [
                    "createStampCardForUser()",
                    "updateStampCardsWithActiveConfiguration()"
                ],
                "pattern": "Controller updates configuration \u2192 Service reads updated configuration \u2192 Service creates/updates stamp cards"
            }
        }
    },
    "global_scope_query_patterns": {
        "description": "Best practices for using global scopes in multi-tenant queries",
        "core_pattern": {
            "favored_approach": {
                "description": "Use Model::query() to leverage global scopes for automatic business_id filtering",
                "implementation": "Model::query()->orderBy('id', 'desc')->get()",
                "benefits": [
                    "Automatic filtering by business_id from authenticated user",
                    "Security built-in - no risk of data leakage",
                    "Cleaner code - no manual business_id where clauses needed",
                    "Consistent with multi-tenant architecture patterns"
                ],
                "example": "StampCardConfiguration::query()->orderBy('id', 'desc')->get()"
            },
            "when_to_use_withoutGlobalScopes": {
                "description": "Use withoutGlobalScopes() when explicitly filtering by business_id manually",
                "implementation": "Model::withoutGlobalScopes()->where('business_id', $businessId)->get()",
                "reasons": [
                    "Double filtering could cause issues (global scope + manual where)",
                    "Explicit control over query behavior",
                    "Avoiding redundant business_id filtering",
                    "Clear intent when bypassing global scope"
                ],
                "example": "StampCardConfiguration::withoutGlobalScopes()->where('business_id', $businessId)->orderBy('id', 'desc')->get()"
            }
        },
        "anti_patterns": {
            "manual_business_id_with_global_scope": {
                "description": "Don't manually filter by business_id when using global scope",
                "incorrect": "Model::query()->where('business_id', Auth::user()->business_id)->get()",
                "why_wrong": "Global scope already filters by business_id - redundant filtering",
                "correct": "Model::query()->get()"
            },
            "withoutGlobalScopes_when_not_needed": {
                "description": "Don't bypass global scope unless absolutely necessary",
                "incorrect": "Model::withoutGlobalScopes()->where('business_id', $id)->get()",
                "why_wrong": "Bypasses the security benefits of global scopes unnecessarily",
                "correct": "Model::query()->get()"
            }
        },
        "common_scenarios": {
            "listing_all_records_for_business": {
                "pattern": "Use Model::query() to get all records for current business",
                "code": "StampCardConfiguration::query()->orderBy('id', 'desc')->get()",
                "why": "Global scope automatically filters by authenticated user's business_id"
            },
            "explicit_business_filtering": {
                "pattern": "Use withoutGlobalScopes() when explicitly filtering by business_id",
                "code": "StampCardConfiguration::withoutGlobalScopes()->where('business_id', $businessId)->get()",
                "why": "Avoid double filtering when manually specifying business_id"
            },
            "active_record_queries": {
                "pattern": "Apply additional filters after Model::query()",
                "code": "StampCardConfiguration::query()->where('is_active', true)->first()",
                "why": "Global scope applies first, then additional filters are added"
            }
        },
        "key_lessons": [
            "Favor Model::query() over withoutGlobalScopes() when leveraging global scopes",
            "Global scopes automatically filter by authenticated user's business_id",
            "Don't manually add business_id where clauses when using global scope",
            "Use withoutGlobalScopes() only when explicitly controlling business_id filtering",
            "Global scopes provide security by default - leverage this benefit",
            "Keep queries simple - let global scopes do the work",
            "Document when bypassing global scopes for clarity",
            "Trust BusinessScope by default in application code; remove unnecessary withoutGlobalScopes() and redundant business_id filters on scoped models",
            "Explicit exceptions: User and Business are not tenant-scoped; keep explicit business_id filters where appropriate",
            "Maintenance/export operations should prefer scoped queries; only bypass scopes for intentional cross-tenant introspection",
            "When using DB::table() for freshness by id derived from a scoped model, extra business_id filter is unnecessary"
        ],
        "related_files": [
            "app/Models/Scopes/BusinessScope.php",
            "routes/web.php (setup route)",
            "app/Http/Controllers/StampCardConfigurationController.php"
        ]
    },
    "package_source_code_study": {
        "description": "Always study package source code when encountering deprecation warnings or using new package APIs",
        "context": "When working with third-party packages, especially when encountering deprecation warnings from IDEs or linters, it's critical to study the actual source code rather than relying solely on documentation",
        "date_learned": "2025-01-19",
        "trigger": "League CSV 9.27 deprecation warnings for createFromPath() and createFromStream() methods",
        "lesson": {
            "always_study_source_code": {
                "description": "Study actual package source code in vendor/ directory",
                "why": "Source code is the source of truth - documentation may be outdated or incomplete",
                "approach": "Read vendor/{package-name}/src/ files directly to understand current API",
                "example": "vendor/league/csv/src/AbstractCsv.php contains from() method as replacement for deprecated createFromPath()"
            },
            "check_deprecation_attributes": {
                "description": "Look for #[Deprecated] attributes and deprecation comments",
                "why": "Modern PHP packages use attributes to mark deprecated methods with clear replacement guidance",
                "pattern": "Check for #[Deprecated(message:'...', since:'...')] attributes",
                "example": "AbstractCsv::createFromPath() marked with #[Deprecated(message:'use League\\Csv\\AbstractCsv::from() instead', since:'league/csv:9.27.0')]"
            },
            "find_current_methods": {
                "description": "Review main package classes to identify current non-deprecated methods",
                "why": "Deprecated methods often have direct replacements in the same class or parent class",
                "approach": "Study AbstractCsv, Writer, Reader, or main package classes",
                "example": "League CSV 9.27 - AbstractCsv::from() replaces createFromPath(), createFromString(), and createFromStream()"
            },
            "verify_method_signatures": {
                "description": "Check actual method signatures, parameters, and return types from source code",
                "why": "Understanding exact signatures prevents runtime errors and ensures correct usage",
                "approach": "Read method definitions directly from source files",
                "example": "Writer::from($filename, string $mode = 'r+', $context = null): static - creates Writer directly from file path"
            }
        },
        "practical_example": {
            "issue": "League CSV deprecation warnings for createFromPath() in BusinessController",
            "investigation": "Studied vendor/league/csv/src/AbstractCsv.php and vendor/league/csv/src/Writer.php",
            "findings": [
                "createFromPath() deprecated since 9.27.0 \u2192 use from() instead",
                "createFromString() deprecated since 9.27.0 \u2192 use fromString() instead",
                "createFromStream() deprecated since 9.27.0 \u2192 use from() instead",
                "from() method available in AbstractCsv class - non-deprecated"
            ],
            "solution": "Updated all CSV export methods to use Writer::from($filePath, 'w+') instead of createFromPath()",
            "files_updated": [
                "app/Http/Controllers/BusinessController.php - exportUsersCsv()",
                "app/Http/Controllers/BusinessController.php - exportStampCardsCsv()",
                "app/Http/Controllers/BusinessController.php - exportRewardsCsv()",
                "app/Http/Controllers/BusinessController.php - exportStampCardRewardsCsv()"
            ]
        },
        "best_practices": {
            "source_code_over_documentation": {
                "description": "Prioritize source code over external documentation",
                "why": "Documentation can lag behind code changes, especially for minor versions",
                "when": "Always when encountering deprecation warnings or version-specific issues"
            },
            "check_deprecation_attributes": {
                "description": "Look for PHP 8 attributes marking deprecations",
                "why": "Modern packages use attributes for clear deprecation messages with replacement guidance",
                "pattern": "#[Deprecated(message:'...', since:'...')]"
            },
            "study_parent_classes": {
                "description": "Check parent classes when methods aren't in current class",
                "why": "Many packages use inheritance - deprecated methods may point to parent class methods",
                "example": "Writer extends AbstractCsv - from() method is in AbstractCsv"
            },
            "verify_before_implementing": {
                "description": "Always verify replacement methods exist and work as expected",
                "why": "Prevents breaking changes and ensures correct implementation",
                "approach": "Check method exists, verify parameters match, test in codebase"
            }
        },
        "anti_patterns": {
            "relying_on_documentation_only": {
                "description": "Don't rely solely on external documentation",
                "incorrect": "Using web search or outdated documentation without checking source",
                "why_wrong": "Documentation may be outdated or incomplete for specific versions",
                "correct": "Study vendor/{package-name}/src/ source files directly"
            },
            "guessing_replacement_methods": {
                "description": "Don't guess deprecated method replacements",
                "incorrect": "Assuming createFromPath() replacement without checking source",
                "why_wrong": "Multiple methods may exist - need to verify correct replacement",
                "correct": "Study source code to find exact replacement method with correct signature"
            },
            "ignoring_deprecation_warnings": {
                "description": "Don't ignore IDE/linter deprecation warnings",
                "incorrect": "Ignoring Intelephense or IDE warnings about deprecated methods",
                "why_wrong": "Deprecated methods may be removed in future versions, causing breaking changes",
                "correct": "Always address deprecation warnings by finding and using current methods"
            }
        },
        "key_lessons": [
            "Always study package source code when encountering deprecation warnings",
            "Source code is the source of truth - documentation may lag behind",
            "Look for #[Deprecated] attributes for clear deprecation guidance",
            "Check parent classes when methods aren't in current class",
            "Verify method signatures from source code before implementing",
            "Don't guess replacement methods - always verify from source",
            "Modern PHP packages use attributes to mark deprecations clearly",
            "Vendor directory contains complete source code for all packages"
        ],
        "related_files": [
            "vendor/league/csv/src/AbstractCsv.php",
            "vendor/league/csv/src/Writer.php",
            "app/Http/Controllers/BusinessController.php"
        ]
    },
    "foreign_key_constraints": {
        "description": "Foreign key constraint management for multi-tenant database design - ensuring data integrity while allowing proper cascade deletion only for business relationships",
        "restrict_vs_set_null_vs_cascade": {
            "restrict": {
                "description": "Prevents deletion of parent row if child rows exist - DELETE fails with error",
                "use_case": "When child records must exist with parent (e.g., prevent user deletion if stamp_cards exist)",
                "laravel_syntax": "->restrictOnDelete()",
                "example": "stamp_cards.user_id \u2192 RESTRICT prevents user deletion when stamp_cards exist (if NOT NULL)"
            },
            "set_null": {
                "description": "Allows deletion of parent row - automatically sets foreign key column in child rows to NULL",
                "use_case": "When you want to allow deletion but preserve child records",
                "requirement": "Foreign key column must be nullable",
                "laravel_syntax": "->nullOnDelete() or ->onDelete('set null')",
                "migration_pattern": "Make column nullable first: DB::statement('ALTER TABLE table_name MODIFY column_name BIGINT UNSIGNED NULL')",
                "example": "stamp_cards.user_id \u2192 SET NULL allows user deletion, sets user_id to null on stamp_cards"
            },
            "cascade": {
                "description": "Allows deletion of parent row - automatically DELETES all child rows that reference it",
                "use_case": "When child records should not exist without parent",
                "laravel_syntax": "->cascadeOnDelete()",
                "restriction": "ONLY use for business_id foreign keys - all other foreign keys should be RESTRICT or SET NULL",
                "example": "stamp_cards.business_id \u2192 CASCADE deletes all stamp_cards when business is deleted"
            }
        },
        "business_id_constraints": {
            "not_null_requirement": "All business_id columns must be NOT NULL in tenant tables",
            "tables_required": [
                "users",
                "rewards",
                "stamp_card_configurations",
                "stamp_cards",
                "stamp_cards_rewards"
            ],
            "cascade_only": "Only business_id foreign keys should have CASCADE - all others should be RESTRICT or SET NULL",
            "migration_pattern": "DB::statement('ALTER TABLE table_name MODIFY business_id BIGINT UNSIGNED NOT NULL')"
        },
        "current_constraint_configuration": {
            "stamp_cards": {
                "user_id": "SET NULL (allows user deletion, sets user_id to null)",
                "configuration_id": "SET NULL (allows configuration deletion, sets configuration_id to null)",
                "business_id": "CASCADE (deletes stamp_cards when business is deleted)"
            },
            "stamp_cards_rewards": {
                "stamp_card_id": "SET NULL (allows stamp_card deletion, sets stamp_card_id to null)",
                "reward_id": "SET NULL (allows reward deletion, sets reward_id to null)",
                "business_id": "CASCADE (deletes stamp_cards_rewards when business is deleted)"
            }
        },
        "migration_patterns": {
            "update_foreign_key_constraint": {
                "description": "How to update existing foreign key constraints",
                "steps": [
                    "Drop existing foreign key by constraint name using DB::statement('ALTER TABLE table_name DROP FOREIGN KEY constraint_name')",
                    "Make column nullable if needed: DB::statement('ALTER TABLE table_name MODIFY column_name BIGINT UNSIGNED NULL')",
                    "Recreate foreign key with new delete action: $table->foreign('column')->references('id')->on('table')->nullOnDelete()"
                ],
                "example_file": "database/migrations/2025_11_02_065423_update_foreign_keys_remove_cascade_deletes.php",
                "why_use_raw_sql": "Laravel's dropForeign(['column']) may not work if constraint name doesn't match Laravel's convention"
            },
            "drop_foreign_key_by_name": {
                "description": "Use DB::statement() with try-catch for dropping foreign keys by constraint name",
                "why": "Laravel's dropForeign(['column']) may not work if constraint name doesn't match Laravel's convention",
                "pattern": "try { DB::statement('ALTER TABLE table_name DROP FOREIGN KEY constraint_name'); } catch (\\Throwable $e) { /* ignore */ }"
            }
        },
        "unique_constraint_design": {
            "avoid_business_id_in_constraints": "When a column already scopes to a business (e.g., stamp_card_id belongs to a business), unique constraint doesn't need business_id",
            "cascade_delete_ordering_issues": "Unique constraints with business_id can cause MySQL cascade delete ordering issues",
            "example": "stamp_cards_rewards unique constraint should be (stamp_card_id, reward_id, reward_position) not (business_id, stamp_card_id, reward_id, reward_position) because stamp_card_id already belongs to a specific business",
            "migration_example": "See database/migrations/2025_10_28_161433_add_business_id_to_stamp_cards_rewards_table.php line 29",
            "reasoning": "Since stamp_card_id belongs to a specific business (via stamp_cards.business_id), the unique constraint without business_id still ensures per-business uniqueness while avoiding cascade delete conflicts"
        },
        "practical_example": {
            "session_context": "Updated foreign key constraints to remove CASCADE deletions except for business_id",
            "requirements": [
                "Only business_id foreign keys should cascade delete",
                "All other foreign keys should be SET NULL (for nullable) or RESTRICT",
                "business_id must be NOT NULL in all tenant tables",
                "Unique constraints should avoid business_id when columns already scope to business"
            ],
            "changes_made": [
                "stamp_cards.user_id: CASCADE \u2192 SET NULL (make nullable, use nullOnDelete())",
                "stamp_cards.configuration_id: CASCADE \u2192 SET NULL (already nullable)",
                "stamp_cards_rewards.stamp_card_id: CASCADE \u2192 SET NULL (make nullable, use nullOnDelete())",
                "stamp_cards_rewards.reward_id: CASCADE \u2192 SET NULL (make nullable, use nullOnDelete())",
                "All business_id columns: Made NOT NULL",
                "stamp_cards_rewards unique constraint: Removed business_id from constraint"
            ],
            "files_updated": [
                "database/migrations/2025_11_02_065423_update_foreign_keys_remove_cascade_deletes.php",
                "database/migrations/2025_10_28_161433_add_business_id_to_stamp_cards_rewards_table.php",
                "tests/Feature/ForeignKeyCascadeDeleteTest.php"
            ],
            "lessons_learned": [
                "RESTRICT prevents deletion when child records exist",
                "SET NULL allows deletion but preserves child records (column must be nullable)",
                "CASCADE should only be used for business_id relationships",
                "Unique constraints with business_id can cause cascade delete ordering issues",
                "Laravel helper methods (nullOnDelete(), restrictOnDelete()) are preferred over onDelete('set null')",
                "Must make columns nullable before setting foreign key to SET NULL"
            ]
        },
        "best_practices": {
            "only_business_cascade": "ONLY use CASCADE for business_id foreign keys - all others should be RESTRICT or SET NULL",
            "business_id_not_null": "ALWAYS make business_id NOT NULL in tenant tables",
            "unique_constraint_design": "Avoid business_id in unique constraints when columns already scope to business",
            "laravel_helper_methods": "Use Laravel helper methods (nullOnDelete(), restrictOnDelete(), cascadeOnDelete()) instead of onDelete('string')",
            "migration_order": "Drop foreign keys, modify columns, recreate foreign keys in that order"
        },
        "anti_patterns": {
            "cascade_on_non_business": "Don't use CASCADE on non-business_id foreign keys",
            "business_id_nullable": "Don't make business_id nullable in tenant tables",
            "business_id_in_unique_constraints": "Don't include business_id in unique constraints when columns already scope to business",
            "onDelete_string_syntax": "Don't use onDelete('set null') - use nullOnDelete() instead"
        },
        "key_lessons": [
            "RESTRICT prevents deletion when child records exist - use when child must have parent",
            "SET NULL allows deletion but preserves child records - requires nullable column",
            "CASCADE should only be used for business_id foreign keys",
            "business_id must be NOT NULL in all tenant tables",
            "Unique constraints without business_id avoid cascade delete ordering issues",
            "Use Laravel helper methods for foreign key constraints",
            "Must make columns nullable before setting foreign key to SET NULL",
            "Drop foreign keys by constraint name using DB::statement() when Laravel conventions don't match"
        ],
        "related_files": [
            "database/migrations/2025_11_02_065423_update_foreign_keys_remove_cascade_deletes.php",
            "database/migrations/2025_10_28_161433_add_business_id_to_stamp_cards_rewards_table.php",
            "database/migrations/2025_11_02_073424_update_stamp_cards_rewards_unique_constraint_remove_business_id.php",
            "tests/Feature/ForeignKeyCascadeDeleteTest.php"
        ]
    },
    "production_migration_management": {
        "description": "Managing database migrations for production databases when existing migrations need updates",
        "never_modify_existing_migrations": {
            "description": "NEVER modify migrations that already ran in production",
            "why": "Production databases have already executed the original migration - modifying it won't update existing databases",
            "solution": "Create a NEW migration to update the database state from the old state to the new state",
            "example": "If migration 2025_10_28_161433 already ran in production with business_id in unique constraint, create new migration 2025_11_02_073424 to update constraint"
        },
        "check_current_database_state": {
            "description": "Always check current database state before modifying constraints/indexes",
            "why": "Need to determine if database is in old state (needs update) or new state (already correct)",
            "approach": "Use information_schema queries to check constraint/index structure",
            "example_query": "SELECT COUNT(*) FROM information_schema.STATISTICS WHERE INDEX_NAME = 'scr_unique' AND COLUMN_NAME = 'business_id' AND SEQ_IN_INDEX = 1"
        },
        "handle_both_scenarios": {
            "description": "Migrations should work for both production (old state) and fresh installs (new state)",
            "why": "Production databases have old state, new installs have new state from updated migration",
            "approach": "Check current state, skip update if already correct, update if needs change",
            "pattern": "if (needsUpdate) { updateConstraint(); } else { return; // Already correct }"
        },
        "preserve_foreign_key_actions": {
            "description": "When dropping/recreating foreign keys to update constraints, preserve their current delete actions",
            "why": "Foreign key delete actions may have been set by previous migrations - don't lose them",
            "approach": "Query information_schema.REFERENTIAL_CONSTRAINTS to get current DELETE_RULE before dropping, then recreate with same action",
            "example": "Get DELETE_RULE for each foreign key before dropping, recreate with ->cascadeOnDelete(), ->nullOnDelete(), or ->restrictOnDelete() based on original value"
        },
        "foreign_keys_prevent_index_drops": {
            "description": "MySQL may prevent dropping unique indexes if foreign keys reference columns in the index",
            "why": "MySQL enforces referential integrity - can't drop index if foreign keys depend on it",
            "solution": "Drop foreign keys first, then update constraint/index, then recreate foreign keys",
            "order": "1. Get current foreign key delete actions, 2. Drop foreign keys, 3. Drop and recreate constraint, 4. Recreate foreign keys with preserved actions"
        },
        "information_schema_query_patterns": {
            "check_constraint_state": {
                "description": "Query information_schema.STATISTICS to check which columns are in indexes/constraints",
                "example": "SELECT COUNT(*) FROM information_schema.STATISTICS WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'table_name' AND INDEX_NAME = 'index_name' AND COLUMN_NAME = 'business_id' AND SEQ_IN_INDEX = 1",
                "purpose": "Check if constraint already has desired structure (e.g., business_id removed)"
            },
            "get_foreign_key_actions": {
                "description": "Join KEY_COLUMN_USAGE with REFERENTIAL_CONSTRAINTS to get current DELETE_RULE",
                "example": "SELECT k.COLUMN_NAME as column_name, r.DELETE_RULE as delete_rule FROM information_schema.KEY_COLUMN_USAGE k JOIN information_schema.REFERENTIAL_CONSTRAINTS r ON k.CONSTRAINT_NAME = r.CONSTRAINT_NAME WHERE k.TABLE_NAME = 'table_name'",
                "fix_ambiguity": "Use aliases (k.COLUMN_NAME as column_name) when joining tables to avoid ambiguous column errors"
            },
            "fix_sql_ambiguity": {
                "description": "Use aliases when joining information_schema tables to avoid ambiguous column errors",
                "problem": "Both KEY_COLUMN_USAGE and REFERENTIAL_CONSTRAINTS have CONSTRAINT_NAME column",
                "solution": "Use table aliases and column aliases: SELECT k.CONSTRAINT_NAME as constraint_name, r.DELETE_RULE as delete_rule FROM ... k JOIN ... r ON k.CONSTRAINT_NAME = r.CONSTRAINT_NAME"
            }
        },
        "practical_example": {
            "session_context": "Created new migration to update unique constraint on stamp_cards_rewards for production databases",
            "problem": "Original migration (2025_10_28_161433) already ran in production with business_id in unique constraint, but we updated it to create constraint without business_id for fresh installs",
            "solution": "Created new migration (2025_11_02_073424) that checks current state and updates constraint for production while skipping for fresh installs",
            "implementation_steps": [
                "Check if business_id is in unique constraint using information_schema.STATISTICS query",
                "If needs update: Get current foreign key delete actions using information_schema join",
                "Drop foreign keys that reference columns in the unique constraint",
                "Drop and recreate unique constraint without business_id",
                "Recreate foreign keys with preserved delete actions (SET NULL for stamp_card_id/reward_id, CASCADE for business_id)"
            ],
            "files_created": [
                "database/migrations/2025_11_02_073424_update_stamp_cards_rewards_unique_constraint_remove_business_id.php"
            ],
            "lessons_learned": [
                "Never modify migrations that already ran in production - create new ones instead",
                "Check current database state before modifying constraints",
                "Foreign keys can prevent dropping unique indexes - drop them first",
                "Preserve foreign key delete actions when dropping/recreating them",
                "Handle both production (old state) and fresh install (new state) scenarios",
                "Use information_schema queries to check constraint/index state",
                "Fix SQL query ambiguity with aliases when joining information_schema tables"
            ]
        },
        "best_practices": {
            "create_new_migrations": "ALWAYS create new migrations when updating database state that already exists in production",
            "check_before_modifying": "ALWAYS check current database state using information_schema before modifying constraints/indexes",
            "preserve_foreign_key_state": "ALWAYS preserve foreign key delete actions when dropping/recreating them",
            "handle_both_states": "ALWAYS handle both production (old state) and fresh install (new state) in same migration",
            "drop_foreign_keys_first": "ALWAYS drop foreign keys before modifying constraints/indexes they reference"
        },
        "anti_patterns": {
            "modifying_existing_migrations": "Don't modify migrations that already ran in production",
            "assuming_fresh_state": "Don't assume database is in fresh install state - check current state first",
            "losing_foreign_key_actions": "Don't drop foreign keys without preserving their delete actions",
            "ignoring_foreign_key_dependencies": "Don't try to drop indexes/constraints while foreign keys reference them"
        },
        "key_lessons": [
            "Never modify migrations that already ran in production - create new ones instead",
            "Check current database state using information_schema queries before modifying",
            "Foreign keys can prevent dropping unique indexes - drop them first, then update constraint, then recreate them",
            "Preserve foreign key delete actions when dropping/recreating them - query DELETE_RULE first",
            "Handle both production (old state) and fresh install (new state) in same migration",
            "Use information_schema.STATISTICS to check constraint/index structure",
            "Use information_schema join to get foreign key delete actions before dropping them",
            "Fix SQL query ambiguity with aliases when joining information_schema tables"
        ],
        "related_files": [
            "database/migrations/2025_11_02_073424_update_stamp_cards_rewards_unique_constraint_remove_business_id.php"
        ]
    },
    "historical_pricing_data": {
        "description": "Store historical pricing data in pivot tables to preserve price at redemption time, ensuring stats calculations use historical prices even when reward prices change",
        "session_context": "Added selling_price and cost_price columns to stamp_cards_rewards table to store prices at redemption time",
        "problem": "Stats calculations were using current reward prices from rewards table, causing incorrect stats when reward prices changed after redemption",
        "solution": "Store selling_price and cost_price in stamp_cards_rewards table at redemption time, update all stats calculations to use historical prices from pivot table",
        "implementation_steps": [
            "Create migration to add selling_price and cost_price columns to stamp_cards_rewards table (nullable)",
            "Populate existing records with prices from rewards table using UPDATE with JOIN",
            "Update RedemptionController to store prices when redeeming via QR code",
            "Update admin redemption route to store prices when redeeming",
            "Update all stats calculations (Dashboard admin, Dashboard user, /users/{user}/stamp-cards) to use prices from stamp_cards_rewards instead of rewards table",
            "Update StampCardReward model to include new fields in fillable and casts",
            "Update Reward and StampCard models to include prices in withPivot()",
            "Create comprehensive tests to verify stats don't change when reward prices change"
        ],
        "database_schema": {
            "stamp_cards_rewards_table": {
                "columns": {
                    "selling_price": "decimal(10,2) nullable - stored at redemption time",
                    "cost_price": "decimal(10,2) nullable - stored at redemption time"
                },
                "migration_population": "UPDATE stamp_cards_rewards INNER JOIN rewards ON stamp_cards_rewards.reward_id = rewards.id SET stamp_cards_rewards.selling_price = rewards.selling_price, stamp_cards_rewards.cost_price = rewards.cost_price"
            }
        },
        "redemption_patterns": {
            "store_prices_at_redemption": {
                "description": "Always store selling_price and cost_price when redeeming rewards",
                "locations": [
                    "RedemptionController::process() - QR code redemption",
                    "routes/web.php stamp-cards.redeem-reward - Admin redemption route"
                ],
                "implementation": "Get reward object before redemption, store both selling_price and cost_price in stamp_cards_rewards update/attach"
            },
            "stats_calculation": {
                "dashboard_admin_stats": {
                    "description": "Dashboard admin redemption stats use cost_price from stamp_cards_rewards table",
                    "implementation": "Sum cost_price from StampCardReward records where is_redeemed = true, grouped by reward_id",
                    "location": "routes/web.php Dashboard route - redemptionStats calculation"
                },
                "dashboard_user_stats": {
                    "description": "Dashboard user redemption stats use selling_price from stamp_cards_rewards table",
                    "implementation": "Sum selling_price from StampCardReward records for user's stamp cards where is_redeemed = true",
                    "location": "routes/web.php Dashboard route - userRedemptionStats calculation"
                },
                "user_stamp_cards_stats": {
                    "description": "User stamp cards page stats use selling_price from stamp_cards_rewards table",
                    "implementation": "Sum selling_price from StampCardReward records for user where is_redeemed = true",
                    "location": "routes/web.php /users/{user}/stamp-cards route"
                }
            }
        },
        "migration_patterns": {
            "populate_existing_records": {
                "description": "When adding new columns to existing table, populate existing records with data from related table",
                "pattern": "Use UPDATE with INNER JOIN to populate existing records",
                "example": "UPDATE stamp_cards_rewards INNER JOIN rewards ON stamp_cards_rewards.reward_id = rewards.id SET stamp_cards_rewards.selling_price = rewards.selling_price, stamp_cards_rewards.cost_price = rewards.cost_price",
                "best_practice": "Always populate existing records in migration up() method, use DB::statement() for complex SQL"
            }
        },
        "testing_patterns": {
            "historical_data_verification": {
                "description": "Test that stats don't change when reward prices change after redemption",
                "test_structure": [
                    "Create reward with initial prices",
                    "Redeem reward (stores prices in stamp_cards_rewards)",
                    "Verify initial stats",
                    "Change reward prices",
                    "Verify stats haven't changed (still use historical prices)"
                ],
                "test_file": "tests/Feature/RedemptionStatsPriceChangeTest.php"
            },
            "include_prices_in_tests": {
                "description": "When creating StampCardReward records in tests, always include selling_price and cost_price",
                "pattern": "StampCardReward::create([..., 'selling_price' => $reward->selling_price, 'cost_price' => $reward->cost_price, ...])",
                "affected_tests": [
                    "UserRedemptionStatsTest",
                    "AdminDashboardRedemptionStatsTest",
                    "Any test that creates redeemed StampCardReward records"
                ]
            }
        },
        "model_updates": {
            "StampCardReward": {
                "fillable": "Added selling_price and cost_price to fillable array",
                "casts": "Added selling_price: 'decimal:2', cost_price: 'decimal:2' to casts() method"
            },
            "Reward": {
                "withPivot": "Updated stampCards() relationship to include selling_price and cost_price in withPivot()"
            },
            "StampCard": {
                "withPivot": "Updated rewards() relationship to include selling_price and cost_price in withPivot()"
            }
        },
        "key_lessons": [
            "ALWAYS store historical pricing data in pivot tables at redemption time",
            "ALWAYS use historical prices from pivot table for stats calculations, never current reward prices",
            "ALWAYS populate existing records in migrations when adding new columns with related data",
            "ALWAYS include selling_price and cost_price when creating StampCardReward records in tests",
            "ALWAYS test that stats don't change when reward prices change after redemption",
            "Use UPDATE with INNER JOIN in migrations to populate existing records from related tables",
            "Stats calculations should sum prices directly from stamp_cards_rewards table, not from rewards table via relationships"
        ],
        "best_practices": {
            "historical_data_storage": "Store pricing data in pivot tables at the time of redemption to preserve historical accuracy",
            "stats_calculation": "Always calculate stats using historical data from pivot tables, never current values from related tables",
            "migration_population": "Always populate existing records when adding historical data columns in migrations",
            "test_verification": "Always test that historical data persistence works - stats shouldn't change when source data changes"
        },
        "anti_patterns": {
            "using_current_prices": "Don't calculate stats using current reward prices from rewards table",
            "missing_prices_in_tests": "Don't create StampCardReward records in tests without selling_price and cost_price",
            "skipping_population": "Don't skip populating existing records in migrations when adding historical data columns"
        },
        "related_files": [
            "database/migrations/2025_11_02_082828_add_selling_price_and_cost_price_to_stamp_cards_rewards_table.php",
            "app/Models/StampCardReward.php",
            "app/Models/Reward.php",
            "app/Models/StampCard.php",
            "app/Http/Controllers/RedemptionController.php",
            "routes/web.php",
            "tests/Feature/RewardRedemptionPriceStorageTest.php",
            "tests/Feature/RedemptionStatsPriceChangeTest.php",
            "tests/Feature/UserRedemptionStatsTest.php",
            "tests/Feature/AdminDashboardRedemptionStatsTest.php"
        ],
        "qr_code_validity": {
            "description": "QR code validity period for reward redemption",
            "period": "5 minutes",
            "location": "resources/js/Components/RewardRedemptionModal.vue - generateQRCodeData() method",
            "implementation": "expiresAt.setMinutes(expiresAt.getMinutes() + 5)"
        },
        "disabled_reward_behavior": {
            "description": "Disabled rewards should remain visible on stamp cards that had them attached before being disabled",
            "behavior": {
                "configuration_removal": "When a reward is disabled, it's removed from reward_positions in all configurations",
                "stamp_card_preservation": "Disabled rewards remain in stamp_cards_rewards pivot table (database records preserved)",
                "display_data_inclusion": "Disabled rewards are included in stamp card display data if they were attached before being disabled",
                "new_cards_exclusion": "Disabled rewards won't appear on new stamp cards (removed from configurations)"
            },
            "implementation": {
                "getStampCardDisplayData": "Build rewards_at_positions from stamp card's attached rewards first (including disabled ones), then add active rewards from configuration that aren't already attached",
                "location": "app/Services/StampCardService.php - getStampCardDisplayData() method (lines 630-711)",
                "approach": "Get all rewards attached to stamp card grouped by position -> Build rewards_at_positions from attached rewards -> Add active rewards from configuration that aren't already attached"
            },
            "testing": {
                "test_file": "tests/Feature/DisabledRewardIncludedInStampCardDataTest.php",
                "test_cases": [
                    "Disabled rewards included in /dashboard route when attached before being disabled",
                    "Disabled rewards included in /users/{user}/loyalty-cards route when attached before being disabled",
                    "Disabled rewards included in multiple stamp cards scenario when attached before being disabled"
                ],
                "key_assertions": [
                    "Verify disabled rewards are included in rewards_at_position data",
                    "Verify both active and disabled rewards appear at same positions",
                    "Verify disabled rewards appear even after being removed from configuration"
                ]
            },
            "key_lessons": [
                "ALWAYS include disabled rewards in stamp card display data if they were attached before being disabled",
                "ALWAYS build stamp card rewards data from attached rewards first, then add active rewards from configuration",
                "NEVER exclude disabled rewards from stamp card display data if they were attached before being disabled",
                "NEVER build stamp card rewards data only from configuration - always check attached rewards first"
            ]
        },
        "reward_type_conditional_validation": {
            "description": "Rewards can be either 'fixed' price or 'percentage' discount with conditional validation",
            "implementation": {
                "fields": {
                    "type": "Required string field: 'fixed' or 'percentage'",
                    "percentage": "Required when type is 'percentage', nullable otherwise. Numeric, min:0, max:100",
                    "cost_price": "Required when type is 'fixed', nullable otherwise. Numeric, min:0, max:999999.99",
                    "selling_price": "Required when type is 'fixed', nullable otherwise. Numeric, min:0, max:999999.99"
                },
                "validation_rules": {
                    "store": "StoreRewardRequest uses required_if validation rules for conditional fields",
                    "update": "UpdateRewardRequest uses sometimes and required_if validation rules for conditional fields",
                    "conditional_rules": [
                        "percentage: required_if:type,percentage",
                        "cost_price: required_if:type,fixed",
                        "selling_price: required_if:type,fixed"
                    ]
                },
                "migration": {
                    "default_values": "When adding type field to existing rewards table, set existing records to 'fixed' type",
                    "example": "DB::table('rewards')->whereNull('type')->update(['type' => 'fixed'])",
                    "location": "database/migrations/2025_11_02_091747_add_type_and_percentage_to_rewards_table.php"
                }
            },
            "frontend": {
                "form_fields": {
                    "type_selection": "Radio buttons for 'Fixed Price' or 'Percentage Discount'",
                    "conditional_fields": "Cost/selling price fields shown when type is 'fixed', percentage field shown when type is 'percentage'",
                    "styling": "Radio buttons styled to match Push Notifications section from template"
                },
                "components": {
                    "RewardsConfiguration.vue": "Add reward form with type selection and conditional fields",
                    "RewardEditModal.vue": "Edit reward form with type selection and conditional fields, includes watcher to initialize form with existing reward type"
                }
            },
            "key_lessons": [
                "ALWAYS use conditional validation (required_if) for fields that depend on other fields",
                "ALWAYS set default values for existing records when adding new required fields in migrations",
                "ALWAYS include watcher in edit modals to initialize form with existing data when modal opens",
                "ALWAYS use v-if directives to show/hide fields based on selected type"
            ]
        },
        "localstorage_ui_state_persistence": {
            "description": "Using localStorage to persist UI state across page refreshes in Inertia/Vue applications",
            "use_cases": [
                "Selected configuration/item state",
                "User preferences and settings",
                "Form field values (non-sensitive data)",
                "UI state like expanded/collapsed sections",
                "Tab selections and navigation state"
            ],
            "implementation_patterns": {
                "storage_key_naming": {
                    "business_specific": "Use business-specific keys when storing state that's business-specific: `selected_configuration_${businessId}`",
                    "user_specific": "Use user-specific keys when storing state that's user-specific: `user_preference_${userId}`",
                    "global_state": "Use descriptive keys for global state: `app_setting_name`",
                    "key_format": "Use lowercase with underscores: `selected_configuration_123` not `selectedConfiguration-123`"
                },
                "state_verification": {
                    "verify_exists": "Always verify stored values still exist in data before using them",
                    "fallback_logic": "Fall back to default (first item, default value) if stored value doesn't exist",
                    "defensive_programming": "Check for null/undefined before accessing stored values",
                    "parse_safely": "Use parseInt/parseFloat with radix parameter for safe number parsing"
                },
                "component_coordination": {
                    "parent_child_sync": "Both parent and child components may need to check localStorage independently",
                    "emit_after_restore": "Emit events to parent after restoring state from localStorage",
                    "onMounted_hook": "Use onMounted hook to restore state when component initializes",
                    "watch_changes": "Watch for data changes and restore selection if no current selection exists"
                },
                "state_updates": {
                    "immediate_storage": "Store state immediately when user makes a selection",
                    "on_change_handler": "Update localStorage in change/selection handlers",
                    "coordinated_updates": "Update both component state and localStorage in same handler"
                },
                "code_examples": {
                    "get_storage_key": "function getStorageKey() { const businessId = props.business?.id || page.props.business?.id || 'default'; return `selected_configuration_${businessId}`; }",
                    "restore_from_storage": "onMounted(() => { if (items.value && items.value.length > 0) { const storedId = localStorage.getItem(getStorageKey()); if (storedId) { const storedItemId = parseInt(storedId, 10); const itemExists = items.value.some(item => item.id === storedItemId); if (itemExists) { selectedId.value = storedItemId; emit('item-selected', storedItemId); return; } } } // Fallback to default selectedId.value = items.value[0].id; localStorage.setItem(getStorageKey(), items.value[0].id.toString()); });",
                    "update_storage": "const handleSelection = (item) => { selectedId.value = item.id; localStorage.setItem(getStorageKey(), item.id.toString()); emit('item-selected', item.id); };"
                }
            },
            "best_practices": [
                "ALWAYS use business-specific or user-specific keys for multi-tenant applications",
                "ALWAYS verify stored values exist in current data before using them",
                "ALWAYS provide fallback to sensible defaults if stored value doesn't exist",
                "ALWAYS store state immediately when user makes a selection",
                "ALWAYS coordinate between parent and child components when restoring state",
                "NEVER store sensitive data (passwords, tokens) in localStorage",
                "NEVER rely solely on localStorage without server-side validation",
                "NEVER use localStorage for data that changes frequently on server"
            ],
            "common_pitfalls": [
                "Forgetting to verify stored value exists in current data",
                "Not using business-specific keys in multi-tenant apps (data leakage)",
                "Not providing fallback when stored value doesn't exist",
                "Not coordinating parent/child component state restoration",
                "Storing sensitive data in localStorage",
                "Not updating localStorage immediately when selection changes"
            ],
            "testing_considerations": [
                "Mock localStorage in tests: global.localStorage = { getItem: vi.fn(), setItem: vi.fn(), removeItem: vi.fn() }",
                "Test state restoration from localStorage",
                "Test fallback behavior when stored value doesn't exist",
                "Test business-specific key isolation",
                "Test component coordination during state restoration"
            ]
        },
        "redemption_validation_configuration_independence": {
            "description": "Redemption validation should be independent of configuration active status - rewards should be redeemable as long as they're attached to the stamp card, regardless of whether the configuration that created them is still active",
            "problem_statement": {
                "original_issue": "Redemption failed after configuration changes because validation checked active configuration instead of stamp card's attached rewards",
                "bug_scenario": "When a new configuration is activated, it deactivates the previous configuration. Cards created with the old configuration can no longer have their rewards redeemed because validation checks the active configuration",
                "affected_routes": [
                    "/stamp-cards/{stampCard}/redeem-reward (frontend uses this route)",
                    "redemption.process (RedemptionController - used by QR code flow)"
                ]
            },
            "solution": {
                "validation_approach": "Check if rewards are attached to the stamp card at the specified position, not whether the configuration is active",
                "validation_steps": [
                    "Check if user has earned enough stamps (position <= current_stamps)",
                    "Check if reward is attached to stamp card at specified position",
                    "If reward is attached at different position, reject (wrong position)",
                    "If reward is attached at this position and already redeemed, reject",
                    "If reward is attached at this position and not redeemed, allow redemption",
                    "If reward is not attached, check stamp card's configuration (not requiring active) for position validation, then allow fallback creation"
                ],
                "implementation_locations": {
                    "routes_web_php": "Route handler for /stamp-cards/{stampCard}/redeem-reward - lines ~775-890",
                    "redemption_controller": "RedemptionController::process() method needs similar fix"
                }
            },
            "validation_patterns": {
                "check_attached_rewards": {
                    "code": "$attachedRewardAtPosition = $stampCard->rewards()->where('reward_id', $rewardId)->wherePivot('reward_position', $position)->first();",
                    "purpose": "Check if reward is attached to stamp card at specified position"
                },
                "check_other_positions": {
                    "code": "$attachedRewardAtOtherPosition = $stampCard->rewards()->where('reward_id', $rewardId)->wherePivot('reward_position', '!=', $position)->first();",
                    "purpose": "Detect attempts to redeem reward at wrong position"
                },
                "check_card_configuration": {
                    "code": "if (!$attachedRewardAtPosition && !$attachedRewardAtOtherPosition && $stampCard->configuration_id) { $cardConfiguration = StampCardConfiguration::withoutGlobalScopes()->find($stampCard->configuration_id); }",
                    "purpose": "Validate position against card's own configuration (not requiring active) for unattached rewards",
                    "note": "Only used as fallback validation - primary check is attached rewards"
                },
                "check_all_redeemed": {
                    "code": "$unredeemedRewards = $stampCard->rewards()->wherePivot('reward_position', '<=', $stampCard->current_stamps)->wherePivot('is_redeemed', false)->exists();",
                    "purpose": "Check if all rewards are redeemed using attached rewards, not active configuration"
                }
            },
            "key_lessons": [
                "NEVER validate redemption based on active configuration status",
                "ALWAYS check if rewards are attached to the stamp card at the specified position",
                "ALWAYS allow redemption if reward is attached and not redeemed, regardless of configuration active status",
                "ALWAYS check stamp card's own configuration (if exists) for position validation when reward is not attached, but don't require configuration to be active",
                "ALWAYS validate position correctness by checking if reward is attached at a different position",
                "ALWAYS update both routes that handle redemption (/stamp-cards/{stampCard}/redeem-reward and redemption.process)"
            ],
            "testing_patterns": {
                "test_setup": "Tests must include configuration_id on stamp cards for position validation to work correctly",
                "test_scenarios": [
                    "Test redemption succeeds when configuration is deactivated",
                    "Test redemption fails when reward is already redeemed",
                    "Test redemption fails when reward is at wrong position",
                    "Test redemption fails when user hasn't earned enough stamps"
                ],
                "example": "this->createStampCard(['configuration_id' => $configuration->id, ...])"
            },
            "common_pitfalls": [
                "Validating against active configuration instead of attached rewards",
                "Forgetting to update both redemption routes",
                "Not checking for wrong position attempts",
                "Not including configuration_id in test stamp card setup",
                "Requiring configuration to be active for position validation"
            ],
            "related_patterns": {
                "historical_data": "Redemption stores historical pricing data (selling_price, cost_price) in pivot table",
                "stats_calculation": "Stats should use historical prices from pivot table, not current reward prices",
                "service_layer": "StampCardService handles reward attachment when creating cards based on configuration"
            }
        }
    },
    "complex_component_testing": {
        "session_39": {
            "session_date": "2025-11-05",
            "session_number": 39,
            "topic": "Complex Component Testing - SystemActivation.vue",
            "lessons": [
                {
                    "lesson": "useForm Mock Must Handle Initial Values from Props",
                    "description": "When mocking useForm for components that initialize forms with prop values, the mock must merge initial values into the shared mockForm object",
                    "pattern": "useForm: vi.fn((initial = {}) => { Object.assign(mockForm, initial); return mockForm; })",
                    "why": "Components call useForm({ property: props.value ?? defaultValue }), so the mock needs to handle the initial parameter and merge it into the shared form object",
                    "example": "Component: useForm({ loyalty_program_active: props.business?.loyalty_program_active ?? false }), Mock must merge this into mockForm so component can read it",
                    "benefits": [
                        "Component can read initial form values",
                        "Component can update form properties",
                        "Tests can verify form state changes"
                    ]
                },
                {
                    "lesson": "Direct Method Calls More Reliable Than Event Triggers",
                    "description": "For complex components with conditional logic, directly calling component methods is more reliable than triggering DOM events",
                    "pattern": "wrapper.vm.methodName() instead of wrapper.find('[data-testid=\"button\"]').trigger('click')",
                    "why": "Event triggers might not work correctly if component has conditional logic preventing event handling, or if event propagation is blocked",
                    "example": "wrapper.vm.toggleActiveStatus() is more reliable than toggle.trigger('change')",
                    "benefits": [
                        "More reliable test execution",
                        "Easier to debug",
                        "Can verify internal state directly"
                    ]
                },
                {
                    "lesson": "Dialog Testing Requires Both State and Rendering Checks",
                    "description": "Test both the internal reactive state (wrapper.vm.showDialog) and the rendered component existence",
                    "pattern": "expect(wrapper.vm.showDialog).toBe(true) AND expect(wrapper.find('[data-testid=\"dialog\"]').exists()).toBe(true)",
                    "why": "Dialogs are conditionally rendered with v-if based on reactive state, so both state and rendering must be verified",
                    "example": "Test error dialog by checking wrapper.vm.showErrorDialog AND wrapper.find('[data-testid=\"error-dialog\"]').exists()",
                    "benefits": [
                        "Comprehensive testing",
                        "Catches both logic and rendering issues"
                    ]
                },
                {
                    "lesson": "Computed Property Testing Requires Proper Prop Setup",
                    "description": "Testing computed properties that depend on complex prop structures requires careful prop configuration",
                    "pattern": "Mount component with props that trigger different computed outcomes, verify computed property values",
                    "why": "Computed properties reactively depend on props, so different prop configurations produce different computed values",
                    "example": "Test hasBothConfigurationTypes with arrays containing different active/inactive configurations",
                    "benefits": [
                        "Thorough coverage",
                        "Tests all computed property branches"
                    ]
                },
                {
                    "lesson": "Form Mock Must Be Shared Object for State Updates",
                    "description": "The form mock object must be a shared reference that both the component and tests can read and update",
                    "pattern": "const mockForm = { property: value, errors: {}, put: vi.fn() }; useForm returns this object",
                    "why": "Components update form properties directly (form.property = value), so the mock must be the same object reference",
                    "example": "Component updates form.loyalty_program_active = true, test verifies mockForm.loyalty_program_active === true",
                    "benefits": [
                        "Component updates visible in tests",
                        "Can verify form state changes",
                        "Consistent form behavior"
                    ]
                }
            ]
        }
    },
    "stamp_card_configuration_types": {
        "session_40": {
            "session_date": "2025-01-XX",
            "session_number": 40,
            "topic": "Stamp Card Configuration Types - Both Types Required",
            "lessons": [
                {
                    "lesson": "Both Configuration Types Must Be Active",
                    "description": "StampCardService::createStampCardForUser() requires BOTH first_card_only and all_subsequent_cards configuration types to be active",
                    "system_activation": "The system is only considered active when both configuration types are active for the business",
                    "test_requirement": "All tests that use createStampCardForUser() or related service methods must create both configuration types",
                    "helper_method": "Use createBothConfigurationTypes() helper from CreatesBusinessData trait in tests to reduce duplication",
                    "pattern": {
                        "correct": "$configs = $this->createBothConfigurationTypes(['is_active' => true]); $configuration = $configs['all_subsequent_cards'];",
                        "incorrect": "$configuration = StampCardConfiguration::factory()->create(['is_active' => true]); // Missing second type"
                    },
                    "why": "getActiveConfigurationForBusiness() returns null unless both types are active",
                    "configuration_types": {
                        "first_card_only": "Used for creating the first stamp card for a user who has no existing cards",
                        "all_subsequent_cards": "Used for creating stamp cards for users who already have at least one card"
                    }
                },
                {
                    "lesson": "Business Loyalty Program Activation Separate from Configuration",
                    "description": "business.loyalty_program_active must be true for dashboard routes to show stamp cards and stats",
                    "separation": "Configuration activation and business program activation are separate concerns",
                    "test_requirement": "Tests checking dashboard routes must activate business.loyalty_program_active = true",
                    "pattern": {
                        "correct": "$business->loyalty_program_active = true; $business->save(); $configs = $this->createBothConfigurationTypes(['is_active' => true]);",
                        "incorrect": "Only activating configurations without activating business program"
                    }
                },
                {
                    "lesson": "Deactivate Old Configs Before Creating New Ones",
                    "description": "When switching configurations in tests, deactivate old ones before creating new ones",
                    "why": "Prevents conflicts and ensures getActiveConfiguration() returns the correct configuration",
                    "pattern": {
                        "correct": "StampCardConfiguration::where('business_id', $business->id)->update(['is_active' => false]); $configs = $this->createBothConfigurationTypes(['is_active' => true]);",
                        "incorrect": "Creating new configs without deactivating old ones"
                    }
                },
                {
                    "lesson": "Reward Creation Must Include Type and Pricing Fields",
                    "description": "Rewards must have type field ('fixed' or 'percentage'), and fixed type must include cost_price and selling_price",
                    "test_requirement": "All reward creation in tests must include these fields",
                    "pattern": {
                        "fixed_type": "$reward = $this->createReward(['name' => 'Free Coffee', 'type' => 'fixed', 'cost_price' => 2.50, 'selling_price' => 4.99]);",
                        "percentage_type": "$reward = $this->createReward(['name' => '10% Off', 'type' => 'percentage', 'percentage' => 10]);",
                        "incorrect": "$reward = Reward::factory()->create(['name' => 'Free Coffee']); // Missing type and pricing"
                    }
                },
                {
                    "lesson": "Stamp Card Creation Must Include configuration_id",
                    "description": "When creating stamp cards in tests, include configuration_id to link to the correct configuration",
                    "pattern": {
                        "correct": "$stampCard = $this->createStampCard(['user_id' => $user->id, 'configuration_id' => $configs['all_subsequent_cards']->id, ...]);",
                        "incorrect": "$stampCard = StampCard::factory()->create(['user_id' => $user->id]); // Missing configuration_id"
                    }
                },
                {
                    "lesson": "Pivot Table Attachments Must Include business_id and Pricing",
                    "description": "When attaching rewards to stamp cards, include business_id in pivot data, and include selling_price and cost_price for historical tracking",
                    "pattern": {
                        "correct": "$stampCard->rewards()->attach($rewardId, ['business_id' => $stampCard->business_id, 'reward_position' => $position, 'selling_price' => $reward->selling_price, 'cost_price' => $reward->cost_price, 'is_redeemed' => false]);",
                        "incorrect": "$stampCard->rewards()->attach($rewardId, ['reward_position' => $position]); // Missing business_id - will cause SQL error"
                    }
                },
                {
                    "lesson": "Configuration Update Requests Must Include Type Field",
                    "description": "When updating stamp card configurations via PUT requests, include type field in the payload",
                    "pattern": {
                        "correct": "$this->put('/stamp-card-configuration/'.$id, ['type' => 'all_subsequent_cards', 'stamps_per_card' => 10, ...]);",
                        "incorrect": "$this->put('/stamp-card-configuration/'.$id, ['stamps_per_card' => 10]); // Missing type field"
                    }
                }
            ],
            "common_test_fixes": [
                "Created both configuration types using createBothConfigurationTypes() helper",
                "Activated business.loyalty_program_active = true for dashboard route tests",
                "Added type, cost_price, selling_price (for fixed) or percentage (for percentage) to reward creation",
                "Added configuration_id to stamp card creation",
                "Added business_id to attach() calls for stamp_cards_rewards pivot table",
                "Deactivated old configurations before creating new ones when switching configs",
                "Added type field to PUT requests when updating stamp card configurations"
            ],
            "impact": "Fixed 36 failing tests by applying these patterns systematically",
            "related_patterns": [
                "Service Layer Separation",
                "Multi-Tenant Architecture",
                "Historical Pricing Data",
                "Test Setup Duplication"
            ]
        }
    },
    "email_validation_edit_scenarios": {
        "session_41": {
            "session_date": "2025-01-XX",
            "session_number": 41,
            "topic": "Email Validation in Edit Scenarios - Skip Validation When Unchanged",
            "lessons": [
                {
                    "lesson": "Skip Frontend Validation When Original Value Matches Current Value",
                    "description": "When editing entities (e.g., users), skip validation if the identifying field (email/phone) hasn't changed to prevent false 'already exists' errors",
                    "problem": "Editing a user's name while keeping the same email triggers validation that finds the email already exists, blocking the update",
                    "frontend_solution": {
                        "component": "EmailOrPhone.vue",
                        "props": [
                            "originalValue: Original value for edit scenarios - skip validation if unchanged",
                            "userId: User ID for edit scenarios - exclude from duplicate checks"
                        ],
                        "validation_logic": "Skip server validation if props.originalValue && emailOrPhone.trim() === props.originalValue.trim()",
                        "pattern": "if (props.originalValue && emailOrPhone.trim() === props.originalValue.trim()) { return; // Skip validation }"
                    },
                    "usage": {
                        "component": "UserEditModal.vue",
                        "pattern": "<EmailOrPhone :original-value=\"props.user?.email || ''\" :user-id=\"props.user?.id || null\" />"
                    },
                    "why": "Prevents false 'already exists' errors when only non-identifying fields (like name) are being updated",
                    "benefits": [
                        "Users can update their name without changing email",
                        "No unnecessary validation calls when email unchanged",
                        "Better user experience - no false errors"
                    ]
                },
                {
                    "lesson": "Backend Validation Must Exclude Current User from Duplicate Checks",
                    "description": "Backend validation endpoints should accept user_id parameter and exclude that user from duplicate checks during edit scenarios",
                    "backend_solution": {
                        "endpoint": "checkEmailOrPhoneExists",
                        "parameter": "user_id: User ID for edit scenarios - exclude from duplicate checks",
                        "validation_logic": "if ($user && (! $userId || $user->id != $userId)) { // Error: duplicate } else { // Success: available }"
                    },
                    "pattern": "if ($user && (!$userId || $user->id != $userId)) { return back()->with('flash.banner', 'Email already registered.'); }",
                    "why": "Allows editing user's email to a new unique email, but prevents false errors when email hasn't changed",
                    "benefits": [
                        "Backend validation works correctly for both create and edit scenarios",
                        "Prevents false 'already exists' errors",
                        "Allows same email if it belongs to the same user being edited"
                    ]
                }
            ]
        }
    },
    "multi_tenant_unique_constraint_validation": {
        "session_41": {
            "session_date": "2025-01-XX",
            "session_number": 41,
            "topic": "Multi-Tenant Unique Constraint Validation - Scope by business_id",
            "lessons": [
                {
                    "lesson": "Laravel Validation Must Scope by business_id for Composite Unique Constraints",
                    "description": "When database has composite unique constraint on (business_id, email), Laravel validation must scope by business_id to match the constraint",
                    "problem": "Using 'unique:users,email,$user->id' validation doesn't account for business_id scope, causing false 'already taken' errors in multi-tenant systems",
                    "database_constraint": "unique(['business_id', 'email'], 'users_business_email_unique')",
                    "incorrect_validation": "'unique:users,email,'.$user->id",
                    "correct_validation": {
                        "pattern": "Rule::unique('users', 'email')->ignore($user->id)->where('business_id', $businessId)",
                        "example": "Rule::unique('users', 'email')->ignore($user->id)->where('business_id', $user->business_id)"
                    },
                    "why": "The validation rule must match the database constraint structure - composite unique constraints require scoping",
                    "benefits": [
                        "Validation matches actual database constraint",
                        "Prevents false 'already taken' errors",
                        "Allows same email in different businesses (multi-tenant support)",
                        "Only prevents duplicate emails within the same business"
                    ],
                    "implementation": {
                        "controller": "UserController::update()",
                        "pattern": "$uniqueRule = Rule::unique('users', 'email')->ignore($user->id)->where('business_id', $user->business_id); $request->validate(['email' => ['required', 'string', 'max:255', $uniqueRule]]);"
                    }
                },
                {
                    "lesson": "Composite Unique Constraints Require Scoped Validation",
                    "description": "Any validation rule for columns with composite unique constraints must include all columns in the constraint",
                    "general_pattern": "If database has unique(['business_id', 'email']), validation must use Rule::unique()->where('business_id', $value)",
                    "applicable_to": [
                        "users.email (scoped by business_id)",
                        "Any other composite unique constraints with business_id"
                    ],
                    "why": "Laravel's unique validation rule checks globally by default, but composite constraints require scoping to match database behavior",
                    "common_mistake": "Using 'unique:table,column,id' without scoping by business_id for multi-tenant tables",
                    "correct_approach": "Always check database migrations for composite unique constraints and scope validation accordingly"
                }
            ]
        }
    },
    "business_selection_url_query_parameters": {
        "session_42": {
            "session_date": "2025-11-06",
            "session_number": 42,
            "topic": "Business Selection on Login/Register Pages with URL Query Parameters",
            "lessons": [
                {
                    "lesson": "Use redirect()->back() to Preserve Scroll State",
                    "description": "When redirecting with query parameters, use redirect()->back() approach instead of redirect()->route() to preserve scroll state and prevent janky frontend behavior",
                    "problem": "Using redirect()->route() causes page reload and scroll position reset, creating janky user experience",
                    "solution": {
                        "backend_pattern": "Get previous URL using url()->previous(), parse it, add query parameters, rebuild URL, and redirect to that URL",
                        "implementation": "Parse previous URL, extract query parameters, add new parameter, rebuild URL with http_build_query(), redirect to rebuilt URL"
                    },
                    "code_example": {
                        "controller": "AuthenticatedSessionController::selectBusiness()",
                        "pattern": "$previousUrl = url()->previous(); $url = parse_url($previousUrl); $query = []; if (isset($url['query'])) { parse_str($url['query'], $query); } $query['business'] = $businessSlug; $redirectUrl = ($url['scheme'] ?? 'http') . '://' . ($url['host'] ?? '') . ($url['path'] ?? '') . '?' . http_build_query($query); return redirect($redirectUrl);"
                    },
                    "why": "Preserves scroll state by redirecting to the same URL (with added query parameter) instead of generating a new route",
                    "benefits": [
                        "Smooth user experience without scroll position reset",
                        "Preserves user's current position on page",
                        "No janky page reload behavior",
                        "Better UX for authentication flows"
                    ]
                },
                {
                    "lesson": "Watch for Business Selection Changes in Vue Components",
                    "description": "Use Vue watch() to detect business selection changes and automatically submit to backend when valid business is selected",
                    "problem": "Manual form submission for business selection creates unnecessary user interaction",
                    "frontend_solution": {
                        "component": "Login.vue and Register.vue",
                        "pattern": "Watch form.business_id for changes, extract business ID (handle both object and number formats), submit to backend via router.post() when valid business selected",
                        "implementation": "const businessId = typeof newBusinessId === 'object' && newBusinessId?.id ? newBusinessId.id : typeof newBusinessId === 'number' ? newBusinessId : null; if (businessId && !props.business && newBusinessId !== oldBusinessId) { router.post(route('select-business'), { business_id: businessId, redirect_to: 'login' }); }"
                    },
                    "why": "Automatic submission provides seamless user experience - business selection immediately updates page with business branding",
                    "benefits": [
                        "Seamless user experience without manual submission",
                        "Immediate page update with business branding",
                        "Handles both object and number business_id formats",
                        "Only triggers when business actually changes"
                    ]
                },
                {
                    "lesson": "Conditionally Hide UI Elements Based on State",
                    "description": "Hide BusinessSelector, dividers, and action buttons when registration form is shown to prevent UI clutter",
                    "problem": "Showing all UI elements simultaneously creates confusing interface",
                    "frontend_solution": {
                        "component": "Register.vue",
                        "pattern": "Use v-if with multiple conditions: v-if=\"!business && !showRegistrationForm\" to hide BusinessSelector, 'or' divider, and 'Register New Business' button when showRegistrationForm is true",
                        "implementation": "<div v-if=\"!business && !showRegistrationForm\"><BusinessSelector ... /></div>"
                    },
                    "why": "Cleaner UI by hiding selection elements when user has already chosen to register new business",
                    "benefits": [
                        "Cleaner, less cluttered interface",
                        "Clear user flow progression",
                        "Prevents confusion about available options",
                        "Better UX for registration flow"
                    ]
                },
                {
                    "lesson": "Backend Route for Business Selection",
                    "description": "Create dedicated route for business selection that validates business_id and redirects back with query parameter",
                    "backend_solution": {
                        "route": "POST /select-business in routes/auth.php (guest middleware)",
                        "controller": "AuthenticatedSessionController::selectBusiness()",
                        "validation": "business_id: required|integer|exists:businesses,id, redirect_to: nullable|string|in:login,register",
                        "pattern": "Validate business_id, find business, generate slug from business name, redirect back with ?business={slug} query parameter"
                    },
                    "why": "Dedicated route provides clean separation of concerns and allows for future enhancements",
                    "benefits": [
                        "Clean separation of concerns",
                        "Reusable for both login and register pages",
                        "Easy to extend with additional functionality",
                        "Proper validation and error handling"
                    ]
                },
                {
                    "lesson": "Two-Step Registration with Business Creation",
                    "description": "Split registration into start selector (/register) and form page (/register/new). When no business is selected, require business_name and create the Business first, then the User under that business.",
                    "frontend": {
                        "pages": [
                            "Auth/RegisterStart.vue",
                            "Auth/Register.vue"
                        ],
                        "autofocus": "Business Name field auto-focused when no business is selected",
                        "behavior": "Selection redirects with ?business=slug; Register New Business redirects without param"
                    },
                    "backend": {
                        "controller": "Auth/RegisteredUserController::store",
                        "validation": "business_name required iff business_id is null",
                        "creation_order": "Create Business first, then User with business_id"
                    }
                },
                {
                    "lesson": "Scoped Uniqueness for Email/Phone",
                    "description": "Duplicate checks must be scoped by business. For new business flow (no business selected), only check against users with business_id IS NULL.",
                    "implementation": {
                        "live_validation": "Auth/SmsVerificationController::checkEmailOrPhoneExists uses findUserByEmailOrPhone scoped by business or null",
                        "submission_rule": "App\\\\Rules\\\\EmailOrPhone scopes uniqueness by business_id or whereNull(business_id)"
                    }
                },
                {
                    "lesson": "Post-Registration Redirect Should Be Deterministic",
                    "description": "Always redirect directly to /dashboard after registration to reduce edge cases and simplify tests.",
                    "tests": "All registration tests updated to expect dashboard"
                },
                {
                    "lesson": "Dashboard Business Setup Requires Logo",
                    "description": "Business Setup is Complete only when business exists AND a logo is uploaded (logo_url or logo_path).",
                    "location": "resources/js/Components/DashboardContent.vue"
                },
                {
                    "lesson": "Help Content Cache Busting",
                    "description": "Disable caching for /HELP.md to ensure always-fresh Help content.",
                    "headers": [
                        "Cache-Control: no-store, no-cache, must-revalidate, max-age=0",
                        "Pragma: no-cache",
                        "Expires: 0"
                    ],
                    "location": "routes/web.php /HELP.md route"
                },
                {
                    "lesson": "Guarded NOT NULL Migration for users.business_id",
                    "description": "Only enforce NOT NULL when no existing rows have business_id NULL; otherwise skip and backfill first.",
                    "file": "database/migrations/2025_11_06_000001_make_users_business_id_not_nullable.php"
                }
            ]
        }
    },
    "modal_scroll_locking_mobile_ux": {
        "session_43": {
            "session_date": "2025-11-06",
            "session_number": 43,
            "topic": "Modal Scroll Locking & Mobile UX, Client-Side Image Compression",
            "lessons": [
                {
                    "lesson": "Lock Background Scroll When Modals Are Open",
                    "description": "Prevent background page scrolling and touch movement when modals are open, especially critical on mobile devices where typing in modals can cause the underlying page to move",
                    "problem": "When scrolling Help modal or typing in Edit modals on mobile, the page underneath scrolls/moves, creating poor UX",
                    "solution": {
                        "composable": "resources/js/composables/useBodyScrollLock.js",
                        "pattern": "Create reusable composable that locks body scroll, prevents touchmove events, and restores scroll position when modal closes",
                        "implementation": "Lock body with fixed positioning, save scroll position, prevent touchmove on document (except modal content), restore on close"
                    },
                    "code_example": {
                        "composable": "useBodyScrollLock(isOpen) - accepts ref or getter function",
                        "lock_scroll": "document.body.style.overflow = 'hidden'; document.body.style.position = 'fixed'; document.body.style.top = `-${scrollPosition}px`;",
                        "prevent_touchmove": "document.addEventListener('touchmove', preventTouchMove, { passive: false });",
                        "allow_modal_scroll": "Check e.target.closest('[data-modal-content]') to allow scrolling inside modal"
                    },
                    "applied_to": [
                        "HelpIcon.vue (Help modal on Setup page)",
                        "UserEditModal.vue",
                        "RewardEditModal.vue",
                        "StampCardConfigurationEditModal.vue",
                        "UserAddModal.vue"
                    ],
                    "why": "Mobile devices have different scroll behavior - touch events can cause background scrolling even when modal is open",
                    "benefits": [
                        "Prevents background scrolling when modal is open",
                        "Blocks touch movement on mobile devices",
                        "Allows scrolling inside modal content",
                        "Restores scroll position when modal closes",
                        "Reusable composable pattern for all modals"
                    ],
                    "mobile_specific": "iOS Safari and Android Chrome require touchmove prevention in addition to overflow hidden"
                },
                {
                    "lesson": "Use data-modal-content Attribute for Scrollable Areas",
                    "description": "Mark modal content areas with data-modal-content attribute so scroll lock allows scrolling inside modal while preventing background scroll",
                    "pattern": "Add data-modal-content attribute to scrollable containers inside modals (e.g., form elements, content divs)",
                    "implementation": {
                        "help_modal": "<div class='max-h-96 overflow-y-auto' data-modal-content>",
                        "edit_modals": "<form data-modal-content> or <div data-modal-content>"
                    },
                    "why": "Touchmove prevention needs to distinguish between modal content (allow scroll) and background (prevent scroll)",
                    "benefits": [
                        "Users can scroll modal content normally",
                        "Background remains locked",
                        "Clear separation between modal and background"
                    ]
                },
                {
                    "lesson": "Client-Side Image Compression Before Upload",
                    "description": "Compress images in browser before uploading to reduce file size, improve loading times, and reduce bandwidth usage",
                    "problem": "Reward images are heavy and take time to load, especially on mobile devices",
                    "solution": {
                        "library": "browser-image-compression",
                        "installation": "npm install browser-image-compression",
                        "pattern": "Compress images in file input change and drag/drop handlers before setting form.image"
                    },
                    "code_example": {
                        "import": "import imageCompression from 'browser-image-compression';",
                        "compression_options": {
                            "maxSizeMB": 1,
                            "maxWidthOrHeight": 800,
                            "useWebWorker": true,
                            "initialQuality": 0.8
                        },
                        "usage": "const compressed = await imageCompression(file, options); form.image = compressed;"
                    },
                    "applied_to": [
                        "RewardsConfiguration.vue (add reward flow)",
                        "RewardEditModal.vue (edit reward flow)"
                    ],
                    "error_handling": "Fallback to original file if compression fails: try { compressed } catch { form.image = file }",
                    "why": "Client-side compression reduces upload size, improves page load times, and reduces storage costs",
                    "benefits": [
                        "60-80% file size reduction typical",
                        "Faster upload times",
                        "Faster page load times",
                        "Reduced bandwidth usage",
                        "Better mobile experience",
                        "No backend changes required"
                    ],
                    "settings": {
                        "max_size": "1MB (down from 2MB validation limit)",
                        "max_dimensions": "800px (sufficient for reward images)",
                        "quality": "0.8 (80% quality - good balance)",
                        "web_worker": "true (non-blocking compression)"
                    }
                },
                {
                    "lesson": "Handle Compression in Both File Input and Drag/Drop",
                    "description": "Apply image compression to both file input change events and drag/drop handlers for consistent behavior",
                    "pattern": "Make both handleFileChange and handleDrop async functions, compress image in both handlers",
                    "implementation": {
                        "file_input": "handleFileChange = async (event) => { const compressed = await imageCompression(file, options); }",
                        "drag_drop": "handleDrop = async (event) => { const compressed = await imageCompression(file, options); }"
                    },
                    "why": "Users can upload images via both methods, both should benefit from compression",
                    "benefits": [
                        "Consistent file size reduction regardless of upload method",
                        "Better UX for all upload paths"
                    ]
                },
                {
                    "lesson": "Composable Pattern for Reusable UX Features",
                    "description": "Create reusable composables for common UX patterns like scroll locking that can be applied to multiple components",
                    "pattern": "Create composables in resources/js/composables/ directory, export functions that handle specific UX concerns",
                    "implementation": {
                        "location": "resources/js/composables/useBodyScrollLock.js",
                        "usage": "useBodyScrollLock(showModal) or useBodyScrollLock(() => props.show)",
                        "flexibility": "Accepts both refs and getter functions for different component patterns"
                    },
                    "why": "Reusable patterns reduce code duplication and ensure consistent behavior across components",
                    "benefits": [
                        "DRY principle - write once, use everywhere",
                        "Consistent behavior across all modals",
                        "Easy to maintain and update",
                        "Clear separation of concerns"
                    ]
                }
            ]
        }
    },
    "modal_ui_patterns": {
        "session_44": {
            "session_date": "2025-11-07",
            "session_number": 44,
            "topic": "Modal Alignment, Full-Width Styling, Font Consistency, and Redirect Patterns",
            "lessons": [
                {
                    "lesson": "Modal Icon and Text Alignment on Desktop",
                    "description": "Keep modal icon and title text aligned horizontally on desktop by using consistent flex layout (sm:flex sm:items-start) instead of md:block which breaks alignment",
                    "problem": "Restore Reward modal icon was not aligned with text on desktop due to md:block overriding flex layout",
                    "solution": {
                        "pattern": "Use sm:flex sm:items-start consistently for both Redeem and Restore modals to maintain horizontal alignment on desktop",
                        "implementation": "<div class=\"sm:flex sm:items-start\"> with icon and text containers side-by-side"
                    },
                    "code_example": {
                        "correct": "<div class=\"sm:flex sm:items-start\"><div class=\"icon-container\">...</div><div class=\"text-container\">...</div></div>",
                        "incorrect": "<div class=\"md:block sm:flex sm:items-start\"> - md:block breaks alignment on desktop"
                    },
                    "why": "Consistent flex layout ensures icon and text remain aligned horizontally on desktop while maintaining proper mobile layout",
                    "benefits": [
                        "Consistent alignment across all modals",
                        "Professional appearance on desktop",
                        "Maintains mobile responsiveness"
                    ]
                },
                {
                    "lesson": "Full-Width Background Styling for Modal Content (Desktop Only)",
                    "description": "Extend gray background of reward items to full width of modal on desktop using negative margins, but keep normal spacing on mobile",
                    "problem": "Reward backgrounds in modals didn't extend to full width on desktop, creating visual inconsistency",
                    "solution": {
                        "pattern": "Use negative margins (sm:-mx-6) on container and positive margins (sm:mx-6) on items to extend background beyond DialogPanel padding on desktop only",
                        "implementation": "Container: sm:-mx-6, Items: sm:mx-6 (only on sm and above, not mobile)"
                    },
                    "code_example": {
                        "container": "<div class=\"mt-3 space-y-3 sm:-mx-6\">",
                        "items": "<div class=\"w-full p-3 bg-gray-50 dark:bg-gray-700 rounded-lg sm:mx-6\">"
                    },
                    "why": "Negative margins extend beyond parent padding on desktop, while mobile keeps normal spacing for better readability",
                    "benefits": [
                        "Full-width background on desktop for visual consistency",
                        "Normal spacing on mobile for better readability",
                        "Responsive design that adapts to screen size"
                    ],
                    "applied_to": [
                        "Redeem Reward modal (unredeemed rewards)",
                        "Restore Reward modal (redeemed rewards)"
                    ]
                },
                {
                    "lesson": "Mobile Modal Centering",
                    "description": "Center modals on mobile devices by using items-center instead of items-end in flex container",
                    "problem": "Restore Reward modal was aligned to bottom on mobile instead of centered",
                    "solution": {
                        "pattern": "Use items-center consistently for modal container flex layout to center modals on all screen sizes",
                        "implementation": "<div class=\"flex min-h-full items-center justify-center p-4 text-center sm:p-0\">"
                    },
                    "code_example": {
                        "correct": "items-center (centers modal on all screen sizes)",
                        "incorrect": "items-end (aligns to bottom on mobile)"
                    },
                    "why": "Centered modals provide better visual balance and user experience on mobile devices",
                    "benefits": [
                        "Better visual balance on mobile",
                        "Consistent modal positioning across screen sizes",
                        "Improved user experience"
                    ]
                },
                {
                    "lesson": "Font Size Consistency on Redemption Page",
                    "description": "Ensure all text elements (reward name, position, stamps used) use consistent font size for visual harmony",
                    "problem": "Reward name appeared larger than position and stamps used text, creating visual inconsistency",
                    "solution": {
                        "pattern": "Use text-base for all value text (reward name, position value, stamps value) to maintain consistency",
                        "implementation": "All value spans use text-base, labels use text-sm font-medium"
                    },
                    "code_example": {
                        "reward_name": "<h5 class=\"text-base font-medium\">{{ reward.name }}</h5>",
                        "position_value": "<span class=\"ml-2 text-base\">Position {{ position }}</span>",
                        "stamps_value": "<span class=\"ml-2 text-base\">{{ current_stamps }} / {{ total_stamps }} stamps</span>"
                    },
                    "why": "Consistent font sizes create visual harmony and make information easier to scan",
                    "benefits": [
                        "Visual consistency across all text elements",
                        "Better readability and scanning",
                        "Professional appearance"
                    ]
                },
                {
                    "lesson": "Redirect to Specific Route Instead of Back for Redemption",
                    "description": "After processing redemption on /users/{user}/redemption page, redirect to /users/{user}/loyalty-cards instead of redirect()->back() for predictable navigation",
                    "problem": "Using redirect()->back() after redemption could redirect to unexpected pages depending on referrer",
                    "solution": {
                        "pattern": "Use redirect()->route('users.loyalty-cards', $user->id) instead of redirect()->back() for consistent navigation",
                        "implementation": "return redirect()->route('users.loyalty-cards', $user->id)->with('flash.banner', '...');"
                    },
                    "code_example": {
                        "controller": "RedemptionController::process()",
                        "pattern": "return redirect()->route('users.loyalty-cards', $user->id)->with('flash.banner', 'Reward redeemed successfully!');"
                    },
                    "why": "Specific route redirects provide predictable navigation and better user experience - users always end up on the loyalty cards page after redemption",
                    "benefits": [
                        "Predictable navigation flow",
                        "Consistent user experience",
                        "Users always see updated stamp cards after redemption",
                        "Better UX than potentially redirecting to unexpected pages"
                    ],
                    "applied_to": [
                        "RedemptionController::process() - all success redirects"
                    ]
                },
                {
                    "lesson": "Business Data Should Always Come from Page Props",
                    "description": "Controllers should NOT pass business information to pages - always use page.props.business from HandleInertiaRequests for all business-related data",
                    "problem": "Some controllers were passing business data as props, overriding shared business data and causing currency_symbol and other fields to be missing",
                    "solution": {
                        "pattern": "Remove business prop from controller Inertia::render() calls, update frontend components to exclusively use page.props.business",
                        "implementation": "Frontend: const currentBusiness = computed(() => page.props.business); Backend: Remove 'business' from Inertia::render() array"
                    },
                    "code_example": {
                        "frontend": "const currencySymbol = computed(() => page.props.business?.currency_symbol || '$');",
                        "backend": "return Inertia::render('Page', ['other' => 'data']); // No 'business' prop"
                    },
                    "why": "Centralized business data in HandleInertiaRequests ensures consistency, prevents duplication, and ensures all business fields (including currency_symbol) are always available",
                    "benefits": [
                        "Single source of truth for business data",
                        "No data duplication or missing fields",
                        "Consistent business data across all pages",
                        "Easier maintenance and updates"
                    ],
                    "applied_to": [
                        "DashboardController - removed business prop",
                        "SetupService - removed business prop",
                        "StampCardConfigurationController - removed business prop",
                        "UserStampCardsController - already correct (no business prop)",
                        "Dashboard.vue - uses page.props.business",
                        "Setup.vue - uses page.props.business",
                        "BusinessInformation.vue - uses page.props.business",
                        "DashboardContent.vue - uses page.props.business?.currency_symbol"
                    ],
                    "critical_rule": "NEVER pass business data from controllers - always use page.props.business from HandleInertiaRequests"
                }
            ]
        },
        "session_80": {
            "session_date": "2026-01-02",
            "session_number": 80,
            "topic": "Clickable Metrics with Modal Details, Route Model Binding Bypass, JSON API Endpoints, and Scrollable Modal Patterns",
            "lessons": [
                {
                    "lesson": "Clickable Metrics Pattern for Detailed Information",
                    "description": "Make specific metrics clickable to display detailed information in modals, improving UX by allowing users to drill down into data",
                    "problem": "Users needed to see detailed breakdown of benefactor's outstanding balance (list of beneficiaries with individual amounts)",
                    "solution": {
                        "pattern": "Add cursor-pointer and hover:opacity-80 classes to metric cards, use @click handler to open modal with detailed data",
                        "implementation": "Conditional classes based on metric name, click handler calls function to fetch and display modal data"
                    },
                    "code_example": {
                        "template": "<div :class=\"{ 'cursor-pointer hover:opacity-80': metric.name === 'benefactor_outstanding_balance' }\" @click=\"metric.name === 'benefactor_outstanding_balance' ? openBeneficiariesModal(benefactor.benefactor_id) : null\">",
                        "handler": "const openBeneficiariesModal = async (benefactorId) => { /* fetch data and open modal */ }"
                    },
                    "why": "Clickable metrics provide intuitive way to access detailed information without cluttering the main view",
                    "benefits": [
                        "Better user experience with drill-down capability",
                        "Clean main view with details available on demand",
                        "Intuitive interaction pattern",
                        "Reusable pattern for other metrics"
                    ],
                    "applied_to": [
                        "Users/Index.vue - Benefactor's Outstanding Balance metric"
                    ]
                },
                {
                    "lesson": "Route Model Binding Bypass for Explicit Authorization",
                    "description": "When Laravel's automatic policy checks via route model binding interfere with explicit authorization logic, use integer parameters and manually resolve models",
                    "problem": "Using User $benefactor in route caused automatic policy check during route model binding, resulting in 403 errors even with explicit authorization checks",
                    "solution": {
                        "pattern": "Change method signature from User $benefactor to int $user, manually resolve model with explicit business_id filter inside method",
                        "implementation": "Route: {user} (integer), Controller: public function getBeneficiaries(Request $request, int $user), Manual resolution: User::where('business_id', $businessId)->where('id', $user)->firstOrFail()"
                    },
                    "code_example": {
                        "route": "Route::get('users/{user}/beneficiaries', [UserController::class, 'getBeneficiaries'])",
                        "controller": "public function getBeneficiaries(Request $request, int $user) { $benefactor = User::where('business_id', $businessId)->where('id', $user)->firstOrFail(); /* explicit checks */ }",
                        "incorrect": "public function getBeneficiaries(Request $request, User $benefactor) { /* automatic policy check happens before method executes */ }"
                    },
                    "why": "Manual model resolution bypasses automatic policy checks, allowing explicit authorization logic to take full control",
                    "benefits": [
                        "Full control over authorization logic",
                        "No interference from automatic policy checks",
                        "Explicit business_id filtering",
                        "Better error messages with custom abort() calls"
                    ],
                    "critical_rule": "NEVER use route model binding when explicit authorization logic is needed - use integer parameters and manual resolution",
                    "applied_to": [
                        "UserController::getBeneficiaries() - admin-only JSON endpoint"
                    ]
                },
                {
                    "lesson": "JSON API Endpoints for Modal Data",
                    "description": "Use JSON responses with fetch() for endpoints specifically designed to provide data for modals, instead of full Inertia responses",
                    "problem": "Modal data endpoints don't need full Inertia page rendering - they just need JSON data",
                    "solution": {
                        "pattern": "Create JSON endpoints that return response()->json(), use fetch() in frontend with CSRF token in headers",
                        "implementation": "Backend: return response()->json(['data' => ...]), Frontend: fetch(url, { headers: { 'X-CSRF-TOKEN': csrfToken } })"
                    },
                    "code_example": {
                        "backend": "return response()->json(['benefactor' => [...], 'beneficiaries' => [...], 'currency_code' => $currencyCode]);",
                        "frontend": "const response = await fetch(route('users.beneficiaries', benefactorId), { headers: { 'X-CSRF-TOKEN': document.querySelector('meta[name=\"csrf-token\"]')?.content || '' } }); const data = await response.json();"
                    },
                    "why": "JSON endpoints are lighter weight for modal data, don't require full page rendering, and provide better separation of concerns",
                    "benefits": [
                        "Lighter weight responses",
                        "No unnecessary Inertia overhead",
                        "Better separation of concerns",
                        "Easier error handling with try/catch"
                    ],
                    "applied_to": [
                        "UserController::getBeneficiaries() - returns JSON for BeneficiariesModal"
                    ]
                },
                {
                    "lesson": "Reusable Modal Components for Entity Lists",
                    "description": "Create reusable modal components for displaying lists of related entities with financial data, following consistent patterns",
                    "problem": "Need to display list of beneficiaries with their outstanding balances in a modal",
                    "solution": {
                        "pattern": "Create dedicated modal component (BeneficiariesModal.vue) with Dialog components, loading states, empty states, and table display",
                        "implementation": "Component accepts props: isOpen, benefactorId, benefactorName, beneficiaries, currencyCode, loading. Uses shadcn/ui Dialog components"
                    },
                    "code_example": {
                        "component": "<Dialog :open=\"isOpen\" @update:open=\"handleOpenChange\"><DialogContent><DialogHeader><DialogTitle>{{ t('beneficiaries_modal_title', { name: benefactorName }) }}</DialogTitle></DialogHeader><table>...</table></DialogContent></Dialog>",
                        "usage": "<BeneficiariesModal v-model:isOpen=\"showModal\" :benefactor-id=\"selectedId\" :beneficiaries=\"beneficiaries\" :currency-code=\"currencyCode\" />"
                    },
                    "why": "Reusable modal components provide consistent UI patterns, easier maintenance, and better code organization",
                    "benefits": [
                        "Consistent modal UI across application",
                        "Reusable component pattern",
                        "Easier maintenance and updates",
                        "Better code organization"
                    ],
                    "applied_to": [
                        "BeneficiariesModal.vue - displays beneficiaries list with outstanding balances"
                    ]
                },
                {
                    "lesson": "Authorization for Admin-Only JSON Endpoints",
                    "description": "For admin-only JSON endpoints, check isAdmin() first, then verify business_id match, then check other conditions (role, trashed status)",
                    "problem": "Need proper authorization for admin-only JSON endpoints with clear error messages",
                    "solution": {
                        "pattern": "Check isAdmin() first, then business_id match, then trashed() status, then role verification, with descriptive abort() messages",
                        "implementation": "if (! $authenticatedUser->isAdmin()) { abort(403, 'Only administrators can view beneficiaries.'); } if ($benefactor->business_id !== $businessId) { abort(403, 'Benefactor does not belong to your business.'); } if ($benefactor->trashed()) { abort(404, 'Benefactor not found.'); } if ($benefactor->role !== UserRole::BENEFACTOR) { abort(404, 'User is not a benefactor.'); }"
                    },
                    "code_example": {
                        "correct": "if (! $authenticatedUser->isAdmin()) { abort(403, 'Only administrators can view beneficiaries.'); } $benefactor = User::where('business_id', $businessId)->where('id', $user)->firstOrFail(); if ($benefactor->trashed()) { abort(404, 'Benefactor not found.'); }",
                        "incorrect": "$this->authorize('view', $benefactor); // Automatic policy check may interfere"
                    },
                    "why": "Explicit authorization checks provide better control, clearer error messages, and avoid interference from automatic policy checks",
                    "benefits": [
                        "Clear authorization flow",
                        "Descriptive error messages",
                        "No interference from automatic checks",
                        "Easier debugging"
                    ],
                    "applied_to": [
                        "UserController::getBeneficiaries() - admin-only JSON endpoint"
                    ]
                },
                {
                    "lesson": "Scrollable Modals with Fixed Heights for Long Lists",
                    "description": "Use fixed pixel heights (max-h-[500px]) instead of viewport heights (max-h-[60vh]) for table scrolling to prevent row compression and ensure proper scrolling behavior",
                    "problem": "Modal with max-h-[60vh] was compressing all table rows to fit in viewport, preventing proper scrolling and making it impossible to see approximately 10 records before scrolling",
                    "solution": {
                        "pattern": "Use fixed pixel height (max-h-[500px]) on table container, move loading/empty states outside scrollable container, ensure table rows maintain their height (py-4 padding)",
                        "implementation": "Container: max-h-[500px] overflow-y-auto, Loading/Empty states: outside scrollable container, Table: inside scrollable container with sticky header"
                    },
                    "code_example": {
                        "correct": "<div class=\"mt-4 max-h-[500px] overflow-y-auto\" data-modal-content><table>...</table></div>",
                        "incorrect": "<div class=\"mt-4 max-h-[60vh] overflow-y-auto\"><div class=\"space-y-4\"><table>...</table></div></div>",
                        "calculation": "Each row with py-4 is ~50px tall, so max-h-[500px] shows approximately 10 rows before scrolling"
                    },
                    "why": "Fixed pixel heights provide predictable scrolling behavior and prevent CSS from compressing rows to fit viewport, ensuring users can see a consistent number of records before scrolling",
                    "benefits": [
                        "Predictable number of visible records (approximately 10 rows)",
                        "Proper scrolling behavior without row compression",
                        "Better mobile experience with consistent row heights",
                        "Sticky header remains visible while scrolling"
                    ],
                    "key_points": [
                        "Use max-h-[500px] for approximately 10 rows (each row ~50px with py-4)",
                        "Move loading and empty states outside scrollable container",
                        "Keep table directly inside scrollable container (no extra wrapper divs)",
                        "Use sticky top-0 z-10 on thead for visible headers while scrolling",
                        "Add data-modal-content attribute for scroll lock compatibility"
                    ],
                    "applied_to": [
                        "BeneficiariesModal.vue - scrollable beneficiaries list"
                    ]
                },
                {
                    "lesson": "Clickable Metric Styling with Blue and Underline",
                    "description": "Make clickable metrics visually obvious by adding blue text color and underline styling in addition to cursor-pointer and hover effects",
                    "problem": "Users didn't recognize that metrics were clickable even with cursor-pointer and hover:opacity-80 classes",
                    "solution": {
                        "pattern": "Add blue text color (text-blue-600 dark:text-blue-400) and underline class conditionally for clickable metrics",
                        "implementation": "Conditional classes: 'text-blue-600 dark:text-blue-400 underline' when metric.name === 'benefactor_outstanding_balance', ensure other blue metrics don't get underline"
                    },
                    "code_example": {
                        "template": "<span :class=\"{ 'text-blue-600 dark:text-blue-400 underline': metric.name === 'benefactor_outstanding_balance', 'text-blue-600 dark:text-blue-400': metric.color === 'blue' && metric.name !== 'benefactor_outstanding_balance' }\">{{ formatMetricValue(metric.value) }}</span>",
                        "container": "<div :class=\"{ 'cursor-pointer hover:opacity-80 transition-opacity': metric.name === 'benefactor_outstanding_balance' }\">"
                    },
                    "why": "Blue color and underline are universal indicators of clickable links, making it immediately obvious to users that the metric is interactive",
                    "benefits": [
                        "Clear visual indication of clickability",
                        "Familiar link styling pattern",
                        "Better user experience with obvious interactive elements",
                        "Consistent with web standards for clickable elements"
                    ],
                    "applied_to": [
                        "Users/Index.vue - Benefactor's Outstanding Balance metric styling"
                    ]
                }
            ]
        }
    },
    "reward_default_imagery": {
        "session_50": {
            "session_date": "2025-11-10",
            "session_number": 50,
            "topic": "Configuration-Aware Reward Default Imagery",
            "lessons": [
                {
                    "lesson": "Persist Selected Configuration on Reward Creation",
                    "description": "Setup now forwards the chosen configuration id into reward creation so default imagery matches the selected theme even when multiple configurations exist.",
                    "implementation": {
                        "frontend": "Setup.vue passes selectedConfigurationId to RewardsConfiguration; the form watches props and updates form.configuration_id before submission.",
                        "backend": "RewardController@store validates configuration_id belongs to the current business before persisting."
                    },
                    "benefits": [
                        "Prevents cross-configuration imagery leaks when multiple configurations are active.",
                        "Ensures rewards created from Setup inherit the intended theme immediately."
                    ]
                },
                {
                    "lesson": "Resolve Default Imagery Using Configuration-First Order",
                    "description": "Reward.php resolves placeholder art using configuration_id before falling back to the latest active configuration for the business.",
                    "implementation": {
                        "resolution_order": "reward_placeholder/{theme}.png  stamps_rewarded/{theme}.png  stamps_rewarded/default.png  stamps_reward/default.png",
                        "caching": "Caches theme lookups per configuration_id and business_id to avoid redundant queries."
                    },
                    "benefits": [
                        "Keeps reward placeholders consistent with the selected theme.",
                        "Avoids regressions when new themes are introduced."
                    ]
                },
                {
                    "lesson": "Extend Test Coverage for Configuration-Aware Rewards",
                    "description": "Feature and unit tests now assert configuration_id is persisted and that fallback imagery references the selected theme.",
                    "implementation": {
                        "phpunit": "RewardImageUploadTest posts configuration_id and expects reward_placeholder/<theme>.png; RewardTest includes configuration_id in fillable/casts assertions.",
                        "vitest": "Setup.test.js verifies selectedConfigurationId propagates and updates form.configuration_id when the selection changes."
                    },
                    "benefits": [
                        "Guards against regressions where rewards default to the newest configuration.",
                        "Documents expected imagery behavior for future contributors."
                    ]
                }
            ]
        }
    },
    "advertising_consent_script_injection": {
        "session_48": {
            "session_date": "2025-11-09",
            "session_number": 48,
            "topic": "Reliable Propeller Ads Injection After Cookie Consent",
            "lessons": [
                {
                    "lesson": "Inject Propeller Inline Script After Consent",
                    "description": "Insert the provided inline script directly after the <head> tag once an admin has accepted cookies and has not paid to disable ads.",
                    "implementation": {
                        "function": "ensureUsersAdScript() in resources/js/Pages/Users.vue",
                        "pattern": "Remove existing <script id=\"users-page-propeller-ads-inline\"> then append a new inline tag to <head> using insertAdjacentElement('afterbegin', script);"
                    },
                    "safeguards": [
                        "Wrap injection in try/catch and log warnings if <head> is missing.",
                        "Always remove the previous inline script before reinjecting to avoid duplicates."
                    ],
                    "benefits": [
                        "Ensures ads load immediately after cookie consent.",
                        "Prevents duplicate scripts or DOM crashes when <head> is unavailable."
                    ]
                },
                {
                    "lesson": "Respect Paid Opt-Out Status",
                    "description": "Do not inject the Propeller script when advertising.optOut.hasPaid is true; remove the inline tag as soon as payment is confirmed.",
                    "implementation": "Watch hasPaidOptOut and call removeUsersAdScript() whenever the flag switches to true.",
                    "benefits": [
                        "Keeps the platform compliant with paid opt-out promises.",
                        "Ensures ads stay disabled without manual intervention."
                    ]
                },
                {
                    "lesson": "Maintain Advertising Props on Partial Reloads",
                    "description": "All Inertia reloads on the Users page must include advertising in the only array so consent state stays accurate.",
                    "implementation": {
                        "router_calls": "router.get / router.reload calls now pass only: ['users', 'pagination', 'filters', 'advertising']",
                        "reason": "Without advertising, bannerState.hasConsent resets to false and the script is never reinjected."
                    },
                    "benefits": [
                        "Ensures consent and paid status stay synchronized after search, pagination, or modal actions.",
                        "Prevents intermittent ad disappearance caused by missing props."
                    ]
                },
                {
                    "lesson": "Banner Component Emits Events Only",
                    "description": "Keep script management in Users.vue and let AdminUsersBanner emit consent-granted/dismiss-opt-out events without manipulating scripts itself.",
                    "implementation": {
                        "frontend": "AdminUsersBanner.vue no longer handles script insertion or removal.",
                        "users_page": "Users.vue watches bannerState.hasConsent and injects/removes the inline script."
                    },
                    "benefits": [
                        "Centralizes script logic in one place.",
                        "Prevents double loading or race conditions when the banner unmounts."
                    ]
                }
            ]
        },
        "session_49": {
            "session_date": "2025-11-10",
            "session_number": 49,
            "topic": "Vitest Fixtures for Advertising-Gated Admin Views",
            "lessons": [
                {
                    "lesson": "Provide Advertising Props in Users Page Tests",
                    "description": "The Users page hides the admin table unless advertising consent exists or the admin has paid to opt-out, so tests must replicate those props.",
                    "implementation": {
                        "vitest_helper": "Updated Users page suites now pass advertising, pagination, and filters props through a shared factory.",
                        "consent_state": "Set usersBanner.has_consent to true (or optOut.hasPaid to true) so admin tables render."
                    },
                    "benefits": [
                        "Prevents false negatives when asserting on table rows, toggle components, and reward icons.",
                        "Keeps test fixtures aligned with production gating logic."
                    ]
                },
                {
                    "lesson": "Mirror Inertia Paginator Shape in Tests",
                    "description": "Users.vue initializes local state from pagination props; missing metadata leaves localUsers empty during tests.",
                    "implementation": {
                        "pagination_stub": "Provide current_page, last_page, per_page, and total values in Vitest props.",
                        "filters_stub": "Pass filters.search (even an empty string) to avoid unexpected router reloads."
                    },
                    "benefits": [
                        "Ensures infinite-scroll logic has the data it expects without issuing router calls.",
                        "Stabilizes tests that query tbody text or reward icons after local state hydrates."
                    ]
                }
            ]
        },
        "session_50": {
            "session_date": "2025-11-11",
            "session_number": 50,
            "topic": "Propeller Ads Script Cleanup on Component Unmount",
            "lessons": [
                {
                    "lesson": "Always Clean Up Injected Scripts on Unmount",
                    "description": "Injected third-party scripts (like Propeller ads) must be removed when components unmount to prevent scripts from persisting when navigating away from the page.",
                    "implementation": {
                        "lifecycle_hook": "Use onUnmounted() lifecycle hook in Vue components to call cleanup functions.",
                        "cleanup_function": "Call removeUsersAdScript() in onUnmounted() to remove both the inline script and any dynamically injected payload scripts.",
                        "pattern": "onUnmounted(() => { removeUsersAdScript(); })"
                    },
                    "safeguards": [
                        "Remove both the inline script (by ID) and any dynamically injected scripts (by dataset attributes).",
                        "Clean up event listeners and observers in the same onUnmounted hook.",
                        "Ensure cleanup is idempotent - safe to call multiple times."
                    ],
                    "benefits": [
                        "Prevents scripts from persisting across page navigations.",
                        "Ensures clean state management and prevents memory leaks.",
                        "Maintains proper separation between page contexts."
                    ],
                    "related_patterns": [
                        "Also clean up IntersectionObserver instances in onUnmounted.",
                        "Remove scroll event listeners in onUnmounted.",
                        "Clean up any other DOM manipulations or global state changes."
                    ]
                }
            ]
        },
        "session_51": {
            "session_date": "2025-11-11",
            "session_number": 51,
            "topic": "Test Ordering Assumptions and Propeller Ads Payload Cleanup",
            "lessons": [
                {
                    "lesson": "Test Ordering Assumptions with DESC Collections",
                    "description": "When testing collections ordered by created_at DESC, the newest item is first in the collection, not the oldest. Tests that assume array position matches expected state will fail.",
                    "implementation": {
                        "problem": "Test assumed first card in DESC-ordered collection was completed, but newest card (first) should be incomplete.",
                        "solution": "Use firstWhere() or where() to find items by their properties (is_completed, current_stamps) rather than assuming array position.",
                        "pattern": "const incompleteCard = $stampCards->firstWhere('is_completed', false); const completedCard = $stampCards->firstWhere('is_completed', true);"
                    },
                    "benefits": [
                        "Tests are resilient to ordering changes.",
                        "Tests verify actual state rather than position assumptions.",
                        "More maintainable when collection ordering logic changes."
                    ],
                    "related_patterns": [
                        "Use firstWhere() for property-based lookups in tests.",
                        "Avoid index-based assertions unless order is explicitly deterministic.",
                        "When order matters, document the expected ordering clearly."
                    ]
                },
                {
                    "lesson": "Remove Propeller Ads Payload Scripts on Navigation",
                    "description": "The Propeller ads inline script creates payload scripts that append to document.body or document.documentElement. Cleanup must remove both the launcher script AND the payload scripts to prevent ads from persisting when navigating away from Users page.",
                    "implementation": {
                        "problem": "removeUsersAdScript() only removed the inline launcher script, leaving payload scripts active on other pages.",
                        "solution": "Enhanced removeUsersAdScript() to also query and remove scripts with data-zone attribute or the Propeller script src.",
                        "pattern": "Query document.querySelectorAll('script[data-zone=\"10165413\"]') and script[src=\"https://gizokraijaw.net/vignette.min.js\"] and remove them all."
                    },
                    "safeguards": [
                        "Remove both launcher script (by ID) and payload scripts (by data-zone or src).",
                        "Use Array.from() to convert NodeList to array for iteration.",
                        "Check parentNode exists before removing to avoid errors."
                    ],
                    "benefits": [
                        "Prevents ads from persisting on Setup, Dashboard, or other pages.",
                        "Ensures clean state when navigating between pages.",
                        "Maintains proper separation between page contexts in SPA."
                    ],
                    "related_patterns": [
                        "Always clean up dynamically injected scripts in onUnmounted().",
                        "Query for scripts by both ID and attributes to catch all variants.",
                        "Test navigation between pages to verify cleanup works."
                    ]
                }
            ]
        }
    },
    "stamp_card_expiry_notifications": {
        "session_49": {
            "session_date": "2025-11-10",
            "session_number": 49,
            "topic": "Opt-Out Aware Expiry Reminder Command Enhancements",
            "lessons": [
                {
                    "lesson": "Skip Users Who Opted Out of Expiry Reminders",
                    "description": "The SMS/email reminder command now respects the opt_out_expiry_reminders flag and logs a skip notice instead of dispatching messages.",
                    "implementation": {
                        "command": "app/Console/Commands/SendStampCardExpiryReminders.php short-circuits processing when payload['opted_out'] is true.",
                        "logging": "Adds info-level log lines so operations teams can confirm why a user was skipped."
                    },
                    "benefits": [
                        "Prevents unwanted messages for users who explicitly declined reminders.",
                        "Keeps execution metrics accurate by tracking skipped counts separately."
                    ]
                },
                {
                    "lesson": "Filter Out Cards Without Redeemable Rewards",
                    "description": "Reminders now only include stamp cards that actually have redeemable rewards, avoiding noise for partially completed or empty cards.",
                    "implementation": {
                        "query_filter": "fetchExpiringCards() applies where('has_redeemable_rewards', true) before grouping.",
                        "test_coverage": "New Vitest and PHPUnit tests assert no notifications are created when cards lack redeemable rewards."
                    },
                    "benefits": [
                        "Ensures customers only receive actionable reminders.",
                        "Reduces SMS/email volume for cards that cannot be redeemed yet."
                    ]
                }
            ]
        }
    },
    "email_queue_serialization": {
        "session_52": {
            "session_date": "2025-11-12",
            "session_number": 52,
            "topic": "Email Queue Serialization and PDF Attachments",
            "lessons": [
                {
                    "lesson": "Avoid Service Injection in Queued Mailables",
                    "description": "Services injected into mailable constructors cause serialization failures when emails are queued. Resolve services from container inside closures instead.",
                    "problem": "When a mailable implements ShouldQueue, Laravel serializes it to store in queue. Services injected as constructor parameters cannot be serialized properly.",
                    "incorrect_pattern": {
                        "constructor": "public function __construct(private readonly PolicyVersionService $service) {}",
                        "usage": "$this->service->generatePdf()",
                        "error": "Serialization fails when job is queued"
                    },
                    "correct_pattern": {
                        "constructor": "public function __construct(public User $user, public string $version) {}",
                        "usage": "fn () => app(PolicyVersionService::class)->generatePdf()",
                        "why": "Service is resolved fresh when job runs, not when queued"
                    },
                    "implementation": {
                        "location": "app/Mail/RegistrationConfirmationMail.php, app/Mail/PolicyVersionChangedMail.php",
                        "pattern": "Remove service from constructor, use app(Service::class) inside closures"
                    },
                    "benefits": [
                        "No serialization issues with queued emails",
                        "Service always resolves fresh with current state",
                        "Closures serialize properly"
                    ]
                },
                {
                    "lesson": "Use Closures for Email Attachments in Queued Emails",
                    "description": "Attachment::fromData() requires closures (not raw data) when emails are queued. Closures are serialized and executed when job runs.",
                    "problem": "Passing raw PDF data to Attachment::fromData() causes 'Argument #1 must be of type Closure' error for queued emails.",
                    "incorrect_pattern": {
                        "code": "$pdf = $service->generatePdf();\nAttachment::fromData($pdf, 'file.pdf')",
                        "error": "TypeError: Argument #1 must be of type Closure, string given"
                    },
                    "correct_pattern": {
                        "code": "Attachment::fromData(\n    fn () => app(PolicyVersionService::class)->generatePdf(),\n    'file.pdf'\n)",
                        "why": "Closure is serialized and executed when job runs, generating PDF on-demand"
                    },
                    "implementation": {
                        "location": "app/Mail/RegistrationConfirmationMail.php attachments() method",
                        "pattern": "Always use closures for Attachment::fromData() in queued mailables"
                    },
                    "benefits": [
                        "PDFs generated with latest data when job runs",
                        "No serialization issues with binary data",
                        "Proper queue compatibility"
                    ]
                },
                {
                    "lesson": "Avoid Laravel Mail Components in Custom Templates",
                    "description": "Laravel's @component('mail::button') syntax requires mail views to be published. Use plain HTML email templates with inline CSS instead.",
                    "problem": "Using @component('mail::button') in email templates causes 'No hint path defined for [mail]' error when mail views aren't published.",
                    "incorrect_pattern": {
                        "template": "@component('mail::button', ['url' => $url])\nView Policy\n@endcomponent",
                        "error": "No hint path defined for [mail]"
                    },
                    "correct_pattern": {
                        "template": "<a href=\"{{ $url }}\" class=\"button\" style=\"...\">View Policy</a>",
                        "why": "Plain HTML works without requiring published Laravel mail views"
                    },
                    "implementation": {
                        "location": "resources/views/emails/registration_confirmation.blade.php, resources/views/emails/policy_version_changed.blade.php",
                        "pattern": "Use plain HTML with inline CSS for email client compatibility"
                    },
                    "benefits": [
                        "No dependency on Laravel mail component system",
                        "Better email client compatibility",
                        "Full control over styling"
                    ]
                },
                {
                    "lesson": "Policy Version Tracking System",
                    "description": "Track policy versions per user, notify users when versions change, and attach PDFs of policies in emails.",
                    "implementation": {
                        "database": "Add privacy_policy_version and terms_version columns to users table",
                        "migration": "Populate existing users with current policy versions",
                        "service": "PolicyVersionService extracts versions from Blade files and generates PDFs",
                        "registration": "Store policy versions when users register",
                        "notification": "Console command checks for version changes and notifies users",
                        "email": "Attach PDFs of changed policies to notification emails"
                    },
                    "patterns": {
                        "version_extraction": "Use regex to extract version numbers from Blade file content",
                        "pdf_generation": "Use barryvdh/laravel-dompdf to generate PDFs from Blade views",
                        "version_comparison": "Compare stored user versions with current file versions",
                        "update_after_notification": "Only update user versions after successful email delivery"
                    },
                    "benefits": [
                        "Users have record of which policy versions they accepted",
                        "Automatic notifications when policies change",
                        "PDF attachments provide permanent record"
                    ]
                }
            ]
        }
    },
    "session_52": {
        "session_date": "2025-11-11",
        "session_number": 52,
        "topic": "Signed Dashboard Links in Expiry Reminder Emails",
        "lessons": [
            {
                "lesson": "Use Signed Auto-Login URLs",
                "description": "Expiry reminder emails now include a signed auto-login link that drops members on /dashboard without prompting for credentials.",
                "implementation": {
                    "backend": "StampCardExpiryReminderMail generates URL::temporarySignedRoute('auto-login', now()->addDays(7), ['user' => $user->id]).",
                    "frontend": "Email template renders a 'View Stamp Cards' button that links to the signed URL when present.",
                    "routes": "routes/auth.php registers GET auto-login/{user} with signed middleware, handled by AuthenticatedSessionController@autoLogin."
                },
                "benefits": [
                    "Removes friction by skipping the login screen for time-sensitive redemption prompts.",
                    "Keeps security intact by expiring links in seven days and requiring valid signatures.",
                    "Provides a deterministic redirect target (/dashboard)."
                ],
                "risks": [
                    "Links must be generated over HTTPS to avoid mixed-content warnings.",
                    "Login is only possible while signature remains valid."
                ]
            }
        ]
    },
    "session_53": {
        "session_date": "2025-11-12",
        "session_number": 53,
        "topic": "CID Embedding for Expiry Reminder Logos",
        "lessons": [
            {
                "lesson": "Embed Business Logos Using CID with URL Fallback",
                "description": "Expiry reminder emails now embed the tenant's logo using a Content-ID image so the artwork renders even when mail clients block remote assets.",
                "implementation": {
                    "mailable": "StampCardExpiryReminderMail uses attachData() with file contents, then withSymfonyMessage() to set inline disposition and Content-ID. Logo is attached AFTER markdown() is called to ensure proper MIME structure.",
                    "remote_storage": "When the logo is stored on R2/S3, use Storage::disk($disk)->get() to read file contents, store in Mailable properties (logoFileContents, logoMimeType), then attach. Check disk driver, not disk name, to determine storage type.",
                    "app_logo_fallback": "When business has no logo (logo_path is null), use app logo from public/logo.png as fallback. App logo is always in public directory (local filesystem), not in storage.",
                    "view_fallback": "The Blade template prefers cid:{{ $logoCid }} but falls back to the absolute URL from Business::getLogoUrlForEmail() when embedding fails."
                },
                "laravel_cloud_compatibility": {
                    "issue": "Laravel Cloud uses LARAVEL_CLOUD_DISK_CONFIG to auto-configure disks. A disk named 'public' may actually use S3 driver (R2 storage).",
                    "solution": "Always check disk driver, not disk name: config('filesystems.disks.{disk}.driver'). Use driver === 'local' for local storage, driver === 's3' for remote storage.",
                    "pattern": "Check $diskConfig['driver'] to determine if storage is local or remote, not the disk name itself."
                },
                "mailable_properties": {
                    "storage": "Store logoFileContents and logoMimeType as private properties to ensure data persists through serialization for queued emails.",
                    "attachment_timing": "Call markdown() first to build email structure, then attach logo using attachData() and withSymfonyMessage() to set inline disposition and Content-ID."
                },
                "benefits": [
                    "Guarantees the logo displays in clients that block external image loads by default (e.g., Outlook, Gmail).",
                    "Maintains compatibility across storage backends without duplicating upload logic.",
                    "Provides a graceful degradation path by keeping the absolute URL available.",
                    "Works correctly with Laravel Cloud's automatic disk configuration.",
                    "All emails display a logo (business logo or app logo fallback)."
                ],
                "constraints": [
                    "Keep logo assets under 200 KB to avoid large inline attachments showing as downloadable files.",
                    "Ensure Business::getLogoUrlForEmail() always returns a fully qualified URL for the fallback path.",
                    "Always check disk driver, not disk name, when determining storage type.",
                    "Store logo data in Mailable properties for queued emails to persist through serialization."
                ]
            }
        ]
    },
    "session_54": {
        "session_date": "2025-11-12",
        "session_number": 54,
        "topic": "Email Deduplication for Policy Notifications",
        "lessons": [
            {
                "lesson": "Deduplicate Email Notifications by Email Address",
                "description": "When sending notifications to users, group by email address to avoid sending multiple emails to users who have multiple accounts with the same email address across different businesses.",
                "problem": {
                    "issue": "Users with multiple accounts (same email, different businesses) received duplicate notifications when policy versions changed",
                    "example": "User with email 'john@example.com' has accounts in Business A and Business B, received 2 separate emails for the same policy change"
                },
                "solution": {
                    "pattern": "Group users by email address before sending notifications",
                    "implementation": "Use Collection::groupBy('email') to group users, then iterate over unique emails",
                    "check_logic": "Check if privacy/terms changed for ANY account with that email (not just one account)",
                    "update_all": "Update all user accounts with the same email address when sending notification"
                },
                "implementation": {
                    "location": "app/Console/Commands/NotifyPolicyVersionChanges.php",
                    "code_pattern": "$usersByEmail = $usersToNotify->groupBy('email');\nforeach ($usersByEmail as $email => $usersWithEmail) {\n    $privacyChanged = $usersWithEmail->contains(function ($user) use ($currentPrivacyVersion) {\n        return $user->privacy_policy_version !== $currentPrivacyVersion;\n    });\n    // Send one email per unique email address\n    // Update all accounts with that email\n}",
                    "output": "Command output shows both unique email count and total account count for visibility"
                },
                "benefits": [
                    "Users receive only one notification per email address regardless of account count",
                    "All user accounts are updated with latest policy versions",
                    "Better user experience - no duplicate emails",
                    "Command output provides visibility into deduplication process"
                ],
                "patterns": {
                    "grouping": "Always group by email address when sending notifications to users",
                    "change_detection": "Check if change occurred for ANY account with that email, not just one",
                    "bulk_update": "Update all related records when sending a single notification",
                    "representative_user": "Use first user account for email template display purposes"
                },
                "applicable_to": [
                    "Any notification system where users can have multiple accounts",
                    "Multi-tenant systems where same email can exist across businesses",
                    "Policy change notifications",
                    "System-wide announcements"
                ]
            }
        ]
    },
    "session_55": {
        "session_date": "2025-01-XX",
        "session_number": 55,
        "topic": "Email Logo Embedding & Laravel Cloud Disk Detection",
        "lessons": [
            {
                "lesson": "Laravel Cloud Disk Detection - Check Driver, Not Disk Name",
                "description": "Laravel Cloud uses LARAVEL_CLOUD_DISK_CONFIG to automatically configure disks. A disk named 'public' may actually use S3 driver (R2 storage), so always check the disk driver, not the disk name.",
                "problem": {
                    "issue": "Code checked disk name ('public', 'local') to determine storage type, which failed in Laravel Cloud where 'public' disk uses S3 driver",
                    "example": "if (in_array($disk, ['public', 'local'], true)) { $path = Storage::disk($disk)->path($logoPath); } // This fails in Laravel Cloud!"
                },
                "solution": {
                    "pattern": "Check disk driver, not disk name",
                    "implementation": "Use config('filesystems.disks.{disk}.driver') to determine storage type",
                    "code": "$diskConfig = config('filesystems.disks.{$disk}', []);\n$diskDriver = $diskConfig['driver'] ?? 'local';\nif ($diskDriver === 'local') { /* local storage */ } else { /* remote storage */ }"
                },
                "benefits": [
                    "Works correctly with Laravel Cloud's automatic disk configuration",
                    "Accurately detects storage type regardless of disk name",
                    "Prevents errors when disk name doesn't match storage type"
                ],
                "applicable_to": [
                    "Any code that needs to determine if storage is local or remote",
                    "Email logo embedding from storage",
                    "File upload/download operations",
                    "Image processing that requires local file paths"
                ]
            },
            {
                "lesson": "App Logo Fallback for Email When Business Has No Logo",
                "description": "When a business has no logo (logo_path is null), use the app logo from public/logo.png as fallback to ensure all emails display a logo.",
                "problem": {
                    "issue": "Emails sent to businesses without logos had no logo displayed, reducing brand consistency",
                    "example": "Business with logo_path = null sent expiry reminder email with no logo"
                },
                "solution": {
                    "pattern": "Use app logo as fallback when business logo_path is null",
                    "implementation": "Check if business has logo_path, if not set isAppLogo flag and use 'logo.png' from public directory",
                    "code": "if (! $logoPath) {\n    $logoPath = 'logo.png';\n    $isAppLogo = true;\n}\nif ($isAppLogo) {\n    $absolutePath = public_path($logoPath);\n    $this->logoFileContents = file_get_contents($absolutePath);\n}"
                },
                "benefits": [
                    "All emails display a logo (business logo or app logo fallback)",
                    "Improved brand consistency across all emails",
                    "Better user experience with consistent branding"
                ],
                "constraints": [
                    "App logo is always in public directory (local filesystem), not in storage",
                    "App logo bypasses storage disk configuration",
                    "Same file size validation and MIME type detection as business logos"
                ]
            },
            {
                "lesson": "Email Logo Attachment Timing - Attach After markdown()",
                "description": "Logo attachment must happen AFTER markdown() is called to ensure proper MIME structure. Store logo data in Mailable properties for queued emails.",
                "problem": {
                    "issue": "Logo attachment before markdown() caused emails to be multipart/alternative without attachments, logo appeared as placeholder in Gmail",
                    "example": "Email was multipart/alternative with no attachments, logo displayed as placeholder in Gmail"
                },
                "solution": {
                    "pattern": "Store logo data in properties, attach after markdown()",
                    "implementation": "Call markdown() first to build email structure, then attach logo using attachData() and withSymfonyMessage()",
                    "code": "// Prepare logo embedding first\n$logoCid = $this->prepareLogoEmbedding(); // Sets $this->logoFileContents and $this->logoMimeType\n\n// Build the mailable with markdown first\n$mailable = $this->subject('...')->markdown('emails.template', [...]);\n\n// Attach logo AFTER markdown is set up\nif ($logoCid && $this->logoFileContents && $this->logoMimeType) {\n    $this->attachLogoToMailable($logoCid);\n}"
                },
                "benefits": [
                    "Proper MIME structure with multipart/related for inline attachments",
                    "Logo displays correctly in email clients",
                    "Works with queued emails through property serialization"
                ],
                "constraints": [
                    "Store logoFileContents and logoMimeType as private properties",
                    "Attach logo after markdown() is called",
                    "Use attachData() with file contents, not file paths"
                ]
            }
        ]
    },
    "session_56": {
        "session_date": "2025-11-18",
        "session_number": 56,
        "topic": "Multi-Tenant Architecture & PHP Enum Objects Implementation",
        "lessons": [
            {
                "lesson": "Multi-Tenant Architecture Based on Business Model",
                "description": "Implemented comprehensive multi-tenant architecture using Business model as root tenant entity. All tenant-scoped tables have business_id (NOT NULL) with BusinessScope global scope for automatic data filtering.",
                "implementation": {
                    "root_model": "Business model serves as multi-tenant root entity",
                    "global_scope": "BusinessScope (app/Models/Scopes/BusinessScope.php) automatically filters queries by authenticated user's business_id",
                    "table_qualification": "Uses {$table}.business_id to avoid ambiguous column errors in joins",
                    "scoped_models": "Individual, CreditAccount, CreditTransaction, Repayment, Template, WhatsAppContact, WhatsAppMessage",
                    "excluded_models": "User (needs cross-business queries for admin), Business (root model)"
                },
                "database_schema": {
                    "business_id_not_null": "All business_id columns are NOT NULL for data integrity",
                    "foreign_keys": "All business_id columns reference businesses table with cascadeOnDelete()",
                    "indexes": "All business_id columns indexed for performance",
                    "unique_constraints": "Prefer constraints without business_id when columns already scope to business"
                },
                "security_patterns": {
                    "never_accept_from_input": "NEVER accept business_id from user input - always use auth()->user()->business_id",
                    "always_set_from_auth": "ALWAYS set business_id from authenticated user when creating records",
                    "secure_by_default": "Global scope enforces isolation - cannot bypass without explicit withoutGlobalScope() calls"
                },
                "benefits": [
                    "Automatic data isolation - no manual filtering needed",
                    "Prevents data leakage between businesses",
                    "Cleaner code - no redundant business_id filters",
                    "Type-safe with IDE autocomplete"
                ]
            },
            {
                "lesson": "PHP Enum Objects Instead of Database Enums",
                "description": "Replaced all database enum() fields with PHP enum objects (string-backed) for better maintainability, type safety, and reusability. Database uses string columns, models cast to enum objects.",
                "implementation": {
                    "enum_creation": "Create string-backed enums in app/Enums/ directory (e.g., enum UserRole: string)",
                    "migration_pattern": "Use string() columns instead of enum() in migrations",
                    "model_casting": "Cast enum fields in model casts() method (e.g., 'role' => UserRole::class)",
                    "ui_helpers": "Add label() and color() methods to enum classes for consistent UI display"
                },
                "enum_pattern": {
                    "structure": "enum EnumName: string { case VALUE = 'value'; }",
                    "label_method": "public function label(): string { return match ($this) { ... }; }",
                    "color_method": "public function color(): string { return match ($this) { ... }; }",
                    "validation": "Use Rule::enum(EnumClass::class) for validation"
                },
                "enums_created": [
                    "UserRole (admin, staff, individual)",
                    "UserStatus (active, inactive, suspended)",
                    "KycStatus (pending, submitted, verified, rejected)",
                    "BusinessStaffRole (owner, manager, cashier, collections)",
                    "BusinessIndividualLinkStatus (requested, authorized, rejected, blocked)",
                    "CreditAccountStatus (active, suspended, closed)",
                    "CreditTransactionType (debit, payment)",
                    "RepaymentMethod (UPI, card, bank, cash, other)",
                    "RepaymentStatus (pending, processing, completed, failed, refunded)",
                    "TemplateCategory (UTILITY, MARKETING)",
                    "TemplateStatus (pending, approved, rejected)",
                    "OptInStatus (opted_in, opted_out, unknown)",
                    "MessageDirection (inbound, outbound)",
                    "MessageStatus (queued, sent, delivered, read, failed)"
                ],
                "benefits": [
                    "Type safety with IDE autocomplete",
                    "Single source of truth - values defined once",
                    "Better maintainability - change values in one place",
                    "Reusable across validation, routes, and frontend",
                    "UI helpers built-in for consistent display"
                ],
                "migration_changes": "All 15 enum() fields converted to string() columns across all migrations"
            },
            {
                "lesson": "Enum Value Refactoring with Backward Compatibility",
                "description": "When refactoring enum backing values (e.g., changing CREDIT to PAYMENT), maintain backward compatibility during transition by temporarily keeping old enum case, creating migration to update database, and updating all code references. Handle enum casting errors gracefully during transition period.",
                "implementation": {
                    "enum_update": "Change enum case from CREDIT to PAYMENT (e.g., CreditTransactionType::CREDIT  CreditTransactionType::PAYMENT)",
                    "temporary_backward_compatibility": "Keep old enum case (CREDIT) temporarily to prevent casting errors with existing database records",
                    "enum_mapping": "Map old enum case to display same as new case in label() and color() methods",
                    "migration_creation": "Create migration to update all existing database records from old value to new value",
                    "code_updates": "Update all controller logic, query filters, and frontend code to use new enum value",
                    "translation_keys": "Update translation keys (e.g., 'total_credits'  'total_payments')"
                },
                "enum_pattern": {
                    "temporary_structure": "enum CreditTransactionType: string { case DEBIT = 'debit'; case PAYMENT = 'payment'; case CREDIT = 'credit'; // Legacy - will be removed after migration }",
                    "label_mapping": "public function label(): string { return match ($this) { self::CREDIT => 'Payment', // Map legacy to new label self::PAYMENT => 'Payment', ... }; }",
                    "color_mapping": "Map legacy enum case to same color as new case for consistent UI display"
                },
                "migration_pattern": {
                    "update_existing_records": "DB::table('table_name')->where('column', 'old_value')->update(['column' => 'new_value']);",
                    "rollback_support": "Include down() method to revert changes if needed"
                },
                "query_filtering": {
                    "problem": "Enum casting errors when database has old values but enum no longer includes old case",
                    "solution": "Use filter() with getRawOriginal() to check raw database values, handle both old and new values during transition",
                    "pattern": "$transactions->filter(function ($transaction) { try { $type = $transaction->type?->value ?? $transaction->getRawOriginal('type'); return $type === 'new_value' || $type === 'old_value'; } catch (\\ValueError $e) { $type = $transaction->getRawOriginal('type'); return $type === 'new_value' || $type === 'old_value'; } });"
                },
                "frontend_compatibility": {
                    "handle_both_values": "Frontend code should handle both old and new values during transition",
                    "format_functions": "Update formatTransactionType() to map old values to new display names",
                    "color_functions": "Update getTypeColor() to handle both old and new values with same color scheme"
                },
                "cleanup_steps": {
                    "after_migration": "After migration runs successfully, remove legacy enum case from enum definition",
                    "remove_filters": "Remove backward compatibility code (try-catch blocks, getRawOriginal() checks)",
                    "verify": "Ensure all database records use new value, all code uses new enum case"
                },
                "example": {
                    "scenario": "Changed CreditTransactionType::CREDIT to CreditTransactionType::PAYMENT",
                    "enum_before": "case CREDIT = 'credit';",
                    "enum_after": "case PAYMENT = 'payment'; case CREDIT = 'credit'; // Legacy",
                    "database_before": "type = 'credit'",
                    "database_after": "type = 'payment' (via migration)",
                    "code_before": "CreditTransactionType::CREDIT",
                    "code_after": "CreditTransactionType::PAYMENT"
                },
                "benefits": [
                    "Smooth transition without breaking existing code",
                    "No data loss during refactoring",
                    "Clear migration path for database updates",
                    "Graceful handling of enum casting errors"
                ],
                "important_notes": [
                    "Always create migration BEFORE removing old enum case",
                    "Keep old enum case until migration runs successfully",
                    "Update all code references (controllers, queries, frontend) simultaneously",
                    "Handle both values in filtering/display logic during transition",
                    "Remove legacy code after migration completes"
                ]
            },
            {
                "lesson": "GDPR Compliance with Nullable User Foreign Keys",
                "description": "Made user_id foreign keys nullable with nullOnDelete() to comply with GDPR and global privacy laws. User deletion preserves financial transaction history for audit/compliance purposes.",
                "implementation": {
                    "nullable_user_id": "User foreign keys use nullable() and nullOnDelete()",
                    "affected_tables": [
                        "individuals.user_id - nullable, preserves individual profile and financial history",
                        "businesses.owner_user_id - nullable, business continues to exist after owner deletion",
                        "business_staff.user_id - nullable, staff records preserved",
                        "whatsapp_contacts.user_id - already nullable"
                    ],
                    "financial_records_preserved": "Credit transactions, repayments, and accounts remain intact after user deletion"
                },
                "cascade_chain": {
                    "before": "User deleted  Individual deleted  CreditAccount deleted  Transactions/Repayments deleted (BAD for financial systems)",
                    "after": "User deleted  user_id becomes NULL  All financial records preserved (GOOD for compliance)"
                },
                "compliance_benefits": [
                    "GDPR compliant - users can be deleted",
                    "Financial audit trail preserved",
                    "Business continuity - businesses survive owner deletion",
                    "Regulatory compliance for financial systems"
                ],
                "important_notes": [
                    "Business ownership transfer needed if owner is being deleted",
                    "Active credit accounts may need to be closed or transferred",
                    "Pending transactions must be handled appropriately"
                ]
            },
            {
                "lesson": "Multi-Tenancy Should Be Implemented From Start",
                "description": "For financial systems, multi-tenancy should be implemented from the beginning rather than added later. The cost of adding it later is much higher than implementing it upfront.",
                "rationale": {
                    "financial_data_isolation": "Credit accounts, transactions, and repayments must be strictly isolated",
                    "security_compliance": "Security and compliance require strict data separation",
                    "retrofit_cost": "Adding multi-tenancy later requires data migration, refactoring all queries, and complex testing",
                    "upfront_cost": "Adding multi-tenancy upfront is relatively low - just add business_id columns, global scopes, and middleware"
                },
                "when_to_delay": [
                    "Only if building a proof-of-concept with no real data",
                    "If unsure about multi-tenant model",
                    "If need to validate core business logic first"
                ],
                "recommendation": "Always implement multi-tenancy from start for financial systems"
            },
            {
                "lesson": "Currency Storage in Smallest Unit with Bigint Unsigned",
                "description": "Store all currency values in the smallest currency unit (e.g., paisa for INR) as bigint unsigned, not decimal. This ensures precision, avoids floating-point errors, and simplifies calculations.",
                "implementation": {
                    "database_type": "Use BIGINT UNSIGNED for all currency columns (credit_limit, available_credit, outstanding_balance, amount, etc.)",
                    "model_casts": "Cast currency fields as 'integer' in model casts() method, not 'decimal:2'",
                    "conversion_service": "Create CurrencyService to convert main currency unit to smallest unit (e.g., 1000 INR  100000 paisa)",
                    "supported_currencies": {
                        "INR": "100 paisa per INR",
                        "USD": "100 cents per USD",
                        "EUR": "100 cents per EUR",
                        "GBP": "100 pence per GBP",
                        "JPY": "1 yen (no smaller unit)",
                        "KRW": "1 won (no smaller unit)"
                    }
                },
                "migration_pattern": "Use raw SQL to convert decimal columns: DB::statement('ALTER TABLE table_name MODIFY COLUMN amount BIGINT UNSIGNED NOT NULL')",
                "benefits": [
                    "No floating-point precision errors",
                    "Simpler calculations (integer arithmetic)",
                    "Better performance (integer operations are faster)",
                    "Consistent storage format across all currency values",
                    "Easier to handle multiple currencies"
                ],
                "example": {
                    "user_input": "1000 INR",
                    "stored_value": "100000 (paisa)",
                    "display": "Convert back to main unit when displaying (100000 / 100 = 1000 INR)"
                }
            },
            {
                "lesson": "Credit Limits Belong in Credit Accounts, Not Users",
                "description": "Credit limits are account-specific, not user-specific. Store credit_limit in credit_accounts table, not users table. Auto-create CreditAccount when creating a new user.",
                "implementation": {
                    "table_structure": "credit_accounts table contains credit_limit, available_credit, outstanding_balance, total_credit_used",
                    "user_creation_flow": "When creating a user, automatically create a CreditAccount with the specified credit_limit",
                    "currency_conversion": "Convert credit_limit from main currency unit to smallest unit before storing",
                    "initial_state": {
                        "credit_limit": "User-specified amount in smallest currency unit",
                        "available_credit": "Same as credit_limit for new accounts",
                        "outstanding_balance": "0 for new accounts",
                        "total_credit_used": "0 for new accounts",
                        "account_status": "active",
                        "last_payment_date": null,
                        "last_transaction_at": null
                    }
                },
                "controller_pattern": {
                    "user_creation": "Create User first, then create CreditAccount with business_id and user_id",
                    "currency_service": "Use CurrencyService to convert credit_limit to smallest unit based on business currency_code",
                    "default_currency": "Default to 'INR' if business currency_code is not set"
                },
                "form_validation": {
                    "credit_limit": "Required field (not optional)",
                    "validation_rules": "['required', 'integer', 'min:0']",
                    "frontend_validation": "Show green border when valid (3-255 chars for name, min:0 for credit_limit)"
                }
            },
            {
                "lesson": "Credit Account Creation During User Registration",
                "description": "Credit accounts must be created automatically when users register themselves (via CreateNewUser action), not just when admins create users. Early users (especially the first admin user) may not have credit accounts, causing 404 errors when trying to update credit limits.",
                "problem": {
                    "symptom": "404 error when trying to update credit limit on first admin user or early registered users",
                    "root_cause": "CreateNewUser action (Fortify) was not creating credit accounts during user registration, only UserController::store() was creating them for admin-created users",
                    "affected_users": "Users registered before this fix, especially the first admin user"
                },
                "implementation": {
                    "registration_flow": "Update CreateNewUser::create() to create CreditAccount after User creation",
                    "default_credit_limit": "New registrations get default credit limit of 0 (can be updated later by admins)",
                    "currency_conversion": "Use CurrencyService to convert default credit limit (0) to smallest currency unit",
                    "business_currency": "Get business currency_code (default to 'INR') when creating credit account",
                    "initial_state": {
                        "credit_limit": "0 (converted to smallest currency unit)",
                        "available_credit": "0 (same as credit_limit)",
                        "outstanding_balance": "0",
                        "total_credit_used": "0",
                        "account_status": "active",
                        "last_payment_date": null,
                        "last_transaction_at": null
                    }
                },
                "code_pattern": {
                    "create_new_user": "After User::create() and business->update(), create CreditAccount with default credit limit of 0",
                    "currency_service": "Use CurrencyService to convert 0 to smallest currency unit based on business currency_code",
                    "imports": "Add CreditAccount, CreditAccountStatus, CurrencyService imports to CreateNewUser action"
                },
                "data_fix_command": {
                    "command_name": "credit-accounts:create-missing",
                    "purpose": "Create credit accounts for existing users that don't have them",
                    "implementation": "Use leftJoin to find users without credit accounts, create CreditAccount with default credit limit of 0",
                    "usage": "Run `php artisan credit-accounts:create-missing` to fix existing users"
                },
                "important_notes": [
                    "Both registration flow (CreateNewUser) and admin creation flow (UserController::store()) must create credit accounts",
                    "Default credit limit of 0 is appropriate for new registrations (admins can update later)",
                    "Always use CurrencyService to convert credit limits to smallest currency unit",
                    "Create artisan commands to fix existing data issues (missing credit accounts)"
                ]
            },
            {
                "lesson": "Currency Code Support with CurrencyService",
                "description": "Add currency_code column to businesses table and create CurrencyService to handle currency conversions. Support multiple currencies with proper conversion factors.",
                "implementation": {
                    "database": "Add currency_code VARCHAR(3) column to businesses table with default 'INR'",
                    "service_class": "Create CurrencyService with toSmallestUnit() method",
                    "conversion_factors": {
                        "most_currencies": "100 (main unit to smallest unit)",
                        "exceptions": "JPY and KRW use 1 (no smaller unit)"
                    },
                    "business_model": "Add currency_code to Business model fillable array"
                },
                "usage_pattern": {
                    "get_currency": "$business->currency_code ?? 'INR'",
                    "convert": "$currencyService->toSmallestUnit($amount, $currencyCode)",
                    "store": "Store converted value in credit_accounts.credit_limit"
                },
                "extensibility": "Easy to add new currencies by adding conversion factors to CurrencyService"
            },
            {
                "lesson": "Refactor individual_id to user_id in Credit Accounts",
                "description": "Credit accounts should reference users directly, not individuals. Rename individual_id to user_id in credit_accounts table and update relationships.",
                "migration_pattern": {
                    "drop_foreign_key": "Drop existing foreign key using raw SQL: DB::statement('ALTER TABLE credit_accounts DROP FOREIGN KEY constraint_name')",
                    "drop_unique_index": "Drop unique index: DB::statement('ALTER TABLE credit_accounts DROP INDEX index_name')",
                    "rename_column": "Rename using raw SQL: DB::statement('ALTER TABLE credit_accounts CHANGE individual_id user_id BIGINT UNSIGNED NOT NULL')",
                    "recreate_constraints": "Recreate foreign key and unique index with new column name"
                },
                "model_updates": {
                    "fillable": "Change 'individual_id' to 'user_id' in CreditAccount model",
                    "relationship": "Change individual() to user() relationship: belongsTo(User::class)",
                    "remove_import": "Remove Individual model import if no longer needed"
                },
                "important_notes": [
                    "MySQL may require dropping foreign keys before dropping unique indexes",
                    "Use try-catch blocks when dropping constraints that might not exist",
                    "Preserve all existing data during migration"
                ]
            },
            {
                "lesson": "Email Uniqueness Per Business in Multi-Tenant Systems",
                "description": "Email addresses should be unique per business_id, not globally. Use composite unique constraint on (business_id, email) instead of global unique on email.",
                "implementation": {
                    "migration": "Drop global unique index on email, add composite unique on (business_id, email)",
                    "validation_rule": "Update EmailOrPhone validation rule to accept businessId parameter and scope uniqueness check by business_id",
                    "controller_usage": "Pass businessId to EmailOrPhone rule: new EmailOrPhone(mustBeUnique: true, businessId: $businessId)"
                },
                "benefits": [
                    "Different businesses can have users with same email",
                    "Maintains data isolation per business",
                    "Prevents accidental data leakage between businesses"
                ],
                "database_constraint": "UNIQUE KEY (business_id, email) on users table"
            },
            {
                "lesson": "Model Casts Must Match Database Column Types",
                "description": "When changing database column types (e.g., decimal to bigint unsigned), update model casts accordingly. Use 'integer' cast for bigint unsigned columns, not 'decimal:2'.",
                "affected_models": {
                    "CreditAccount": "credit_limit, available_credit, outstanding_balance, total_credit_used  'integer'",
                    "CreditTransaction": "amount  'integer'",
                    "Repayment": "amount  'integer'"
                },
                "cast_mapping": {
                    "bigint_unsigned": "'integer'",
                    "decimal_10_2": "'decimal:2' (deprecated for currency)",
                    "string": "'string'",
                    "json": "'array'"
                },
                "importance": "Mismatched casts can cause type errors, incorrect calculations, and data corruption"
            },
            {
                "lesson": "OTP Context Support for Login",
                "description": "Extend SMS verification to support 'login' context in addition to 'registration' and 'profile'. Update both frontend and backend validation.",
                "implementation": {
                    "frontend": "Update LoginPhoneOtp component Props interface to include 'login' as valid context type",
                    "backend": "Update SmsVerificationController validation rules to accept 'login' context: 'in:registration,profile,login'",
                    "usage": "Pass context='login' when using OTP for login flow"
                },
                "contexts": {
                    "registration": "New user registration",
                    "profile": "Profile phone number update",
                    "login": "Login with phone number"
                }
            },
            {
                "lesson": "Role Enum Refactoring (STAFF to REGULAR)",
                "description": "When refactoring enum values (e.g., STAFF to REGULAR), update all references throughout the codebase including enum definition, validation rules, form defaults, and database usage.",
                "implementation_steps": {
                    "enum_definition": "Change case STAFF to case REGULAR in UserRole enum",
                    "enum_methods": "Rename isStaff() to isRegular(), update label() and color() methods",
                    "validation_rules": "Update validation from 'in:admin,staff' to 'in:admin,regular'",
                    "form_defaults": "Change form default from 'staff' to 'regular'",
                    "radio_values": "Update radio button values from 'staff' to 'regular'",
                    "reset_values": "Update reset logic to use 'regular' instead of 'staff'"
                },
                "search_patterns": [
                    "Search for 'staff' and 'STAFF' across entire codebase",
                    "Update all occurrences systematically",
                    "Verify no references remain"
                ]
            }
        ]
    },
    "credit_management_ui": {
        "session_57": {
            "session_date": "2025-12-31",
            "session_number": 57,
            "topic": "Credit Management UI - Payment/Debit Modals, Status Toggle, and Table Improvements",
            "lessons": [
                {
                    "lesson": "Payment and Debit Modals with Credit Limit Validation",
                    "description": "Implemented separate Payment and Debit modals for credit management. Payment creates CREDIT transactions (increases available_credit, decreases outstanding_balance), Debit creates DEBIT transactions (decreases available_credit, increases outstanding_balance). Payment validation uses credit_limit as maximum, not outstanding_balance.",
                    "implementation": {
                        "payment_modal": "PaymentModal.vue - validates against credit_limit, creates CREDIT transactions",
                        "debit_modal": "DebitModal.vue - validates against available_credit, creates DEBIT transactions",
                        "validation_difference": "Payment: amount <= credit_limit, Debit: amount <= available_credit",
                        "transaction_types": "Payment = CREDIT type, Debit = DEBIT type",
                        "balance_updates": {
                            "payment": "available_credit += amount, outstanding_balance -= amount (min 0), total_credit_used unchanged",
                            "debit": "available_credit -= amount, outstanding_balance += amount, total_credit_used += amount"
                        }
                    },
                    "button_styling": {
                        "debit": "Blue color scheme (bg-blue-500), disabled when available_credit <= 0",
                        "payment": "Green color scheme (bg-green-500), disabled when outstanding_balance <= 0"
                    },
                    "prevent_negative_balance": "Use max(0, outstanding_balance - amount) to prevent negative outstanding_balance when payment exceeds current balance",
                    "benefits": [
                        "Clear separation between payment (adding credit) and debit (using credit)",
                        "Proper validation prevents invalid transactions",
                        "Historical tracking preserved (total_credit_used unchanged for payments)"
                    ]
                },
                {
                    "lesson": "Currency Symbol Formatting in Error Messages",
                    "description": "Error messages should use currency symbols (, $, ) instead of currency codes (INR, USD, EUR) for better UX. Format as 'CurrencySymbol + Amount' (e.g., '500.00') instead of 'Amount + CurrencyCode' (e.g., '500.00 INR').",
                    "implementation": {
                        "format_function": "formatCurrency() uses getCurrencySymbol() utility instead of currency code",
                        "pattern": "`${getCurrencySymbol(currencyCode)}${formatted}` instead of `${formatted} ${currencyCode}`",
                        "utility": "Use getCurrencySymbol() from @/lib/currencySymbols for consistent symbol mapping"
                    },
                    "benefits": [
                        "More intuitive user experience",
                        "Consistent with input field currency display",
                        "Better visual recognition"
                    ]
                },
                {
                    "lesson": "Status Toggle Implementation for User Management",
                    "description": "Replaced static status display with functional toggle that updates user status in database. Toggle switches between active/inactive (suspended users toggle to active). Uses Inertia router.post() for seamless updates without page reload.",
                    "implementation": {
                        "toggle_component": "Custom toggle using provided Tailwind CSS snippet with has-[:checked] pseudo-class",
                        "backend_method": "toggleStatus() in UserController - toggles between ACTIVE and INACTIVE, SUSPENDED  ACTIVE",
                        "route": "POST /users/{user}/toggle-status with auth middleware",
                        "state_management": "isStatusActive() helper checks if status === 'active'",
                        "aria_labels": "Use aria-label for accessibility when removing visible labels"
                    },
                    "toggle_styling": {
                        "inactive": "bg-gray-200 (default state)",
                        "active": "bg-indigo-600 (checked state)",
                        "transition": "Smooth color and transform transitions"
                    },
                    "benefits": [
                        "Quick status updates without modal",
                        "Visual feedback with toggle state",
                        "Seamless UX with Inertia partial reloads"
                    ]
                },
                {
                    "lesson": "Disable Debit Facilities for Inactive Users",
                    "description": "Debit functionality must be disabled for inactive users both on frontend (button disabled) and backend (validation prevents action). This prevents credit usage when user account is not active.",
                    "implementation": {
                        "frontend_check": "isCreditDisabled() checks user.status !== 'active' in addition to available_credit check",
                        "backend_validation": "dispenseCredit() validates user.status === UserStatus::ACTIVE before processing",
                        "error_message": "Returns 'Cannot debit credit for inactive users.' if validation fails"
                    },
                    "pattern": {
                        "frontend": "const isInactive = user.status?.toLowerCase() !== 'active'; return isInactive || available_credit <= 0;",
                        "backend": "if ($user->status !== UserStatus::ACTIVE) { return redirect()->back()->withErrors(['amount' => 'Cannot debit credit for inactive users.']); }"
                    },
                    "benefits": [
                        "Prevents unauthorized credit usage",
                        "Clear user feedback with disabled button",
                        "Backend validation prevents bypass attempts"
                    ]
                },
                {
                    "lesson": "Table UI Improvements - Truncate, Mobile Stacking, Color Coding",
                    "description": "Improved table UX with text truncation, mobile-responsive column stacking, and color-coded role/status badges. Role and Status stacked in separate column on mobile, proper casing and colors for better visual hierarchy.",
                    "implementation": {
                        "text_truncation": "Add 'min-w-0 truncate' classes to name field in flex container (min-w-0 required for truncation in flex)",
                        "mobile_stacking": "Role and Status in separate 'Role / Status' column on mobile (sm:hidden), separate columns on desktop",
                        "color_coding": {
                            "admin": "Red (bg-red-100 text-red-800)",
                            "active": "Green (bg-green-100 text-green-800)",
                            "regular": "Gray (bg-gray-100 text-gray-800)"
                        },
                        "proper_casing": "formatRoleStatus() capitalizes first letter: value.charAt(0).toUpperCase() + value.slice(1).toLowerCase()"
                    },
                    "helper_functions": {
                        "formatRoleStatus": "Formats role/status with proper casing",
                        "getRoleColor": "Returns color classes based on role value",
                        "getStatusColor": "Returns color classes based on status value"
                    },
                    "benefits": [
                        "Better mobile UX with stacked information",
                        "Visual hierarchy with color coding",
                        "Prevents text overflow issues",
                        "Professional appearance with proper casing"
                    ]
                },
                {
                    "lesson": "Backend Data Conversion for Frontend Display",
                    "description": "Backend must convert currency values from smallest unit (bigint) to main currency unit (float) for frontend display. Include all necessary fields (available_credit, outstanding_balance, credit_limit) in user data for modals and validation.",
                    "implementation": {
                        "currency_conversion": "Use CurrencyService::fromSmallestUnit() to convert before sending to frontend",
                        "data_inclusion": "Include available_credit, outstanding_balance, credit_limit, currency_code in users array",
                        "pattern": "$availableCredit = $currencyService->fromSmallestUnit($creditAccount->available_credit, $currencyCode);"
                    },
                    "benefits": [
                        "Frontend works with human-readable currency values",
                        "All necessary data available for validation and display",
                        "Consistent currency handling"
                    ]
                },
                {
                    "lesson": "Extracting Numeric Values from Formatted Stats for Edit Modals",
                    "description": "When adding edit functionality to stats (e.g., Credit Limit), extract numeric values from formatted display strings by removing formatting characters (commas, currency symbols, units) before populating form fields.",
                    "implementation": {
                        "extraction_pattern": "Remove commas, units, and whitespace: const numericValue = stat.value.replace(/,/g, '').replace(stat.unit || '', '').trim();",
                        "form_population": "Parse extracted string to float: creditLimitForm.credit_limit = parseFloat(numericValue) || 0;",
                        "example": "Credit Limit stat displays '1,000.00 INR'  extract '1000.00'  parse to 1000.00"
                    },
                    "benefits": [
                        "Form fields show clean numeric values",
                        "Users can edit without manual formatting",
                        "Consistent with backend storage format"
                    ]
                },
                {
                    "lesson": "User Edit Modal - Account Details with Role and Status",
                    "description": "Edit modals for user account details should use role radio buttons (admin/regular only, not individual) and status toggle switches (active/inactive only, not suspended). Reuse existing patterns from Users/Index.vue for consistency.",
                    "implementation": {
                        "role_field": {
                            "type": "Radio buttons (not dropdown)",
                            "options": ["admin", "regular"],
                            "exclude": "individual role option",
                            "pattern_reference": "Users/Index.vue add user modal (lines 702-733)",
                            "pattern": "<div class=\"flex gap-6\"><label class=\"flex cursor-pointer items-center gap-2\"><input type=\"radio\" v-model=\"form.role\" value=\"regular\" class=\"h-4 w-4 border-input text-primary focus:ring-primary\" /><span class=\"text-sm text-foreground\">{{ t('regular_user') }}</span></label><label class=\"flex cursor-pointer items-center gap-2\"><input type=\"radio\" v-model=\"form.role\" value=\"admin\" class=\"h-4 w-4 border-input text-primary focus:ring-primary\" /><span class=\"text-sm text-foreground\">{{ t('admin') }}</span></label></div>"
                        },
                        "status_field": {
                            "type": "Toggle switch (not dropdown)",
                            "options": ["active", "inactive"],
                            "exclude": "suspended status option",
                            "pattern_reference": "Users/Index.vue status toggle (lines 526-558 or 582-609)",
                            "pattern": "<div class=\"group relative inline-flex w-11 shrink-0 rounded-full bg-gray-200 p-0.5 ring-1 ring-gray-900/5 outline-offset-2 outline-indigo-600 transition-colors duration-200 ease-in-out ring-inset has-[:checked]:bg-indigo-600 has-[:focus-visible]:outline has-[:focus-visible]:outline-2\" :class=\"{ 'bg-indigo-600': form.status === 'active' }\"><span class=\"size-5 rounded-full bg-white shadow-sm ring-1 ring-gray-900/5 transition-transform duration-200 ease-in-out\" :class=\"{ 'translate-x-5': form.status === 'active' }\"></span><input type=\"checkbox\" :checked=\"form.status === 'active'\" @change=\"form.status = form.status === 'active' ? 'inactive' : 'active'\" class=\"absolute inset-0 size-full cursor-pointer appearance-none focus:outline-none\" /></div>"
                        },
                        "email_field": {
                            "type": "Text input (nullable)",
                            "validation": "EmailOrPhone rule with businessId and ignoreUserId",
                            "phone_detection": "If value starts with '+', treat as phone and update phone field accordingly",
                            "empty_handling": "Convert empty strings to null in prepareForValidation()"
                        },
                        "form_request": {
                            "validation_rules": {
                                "email": "nullable, string, max:255, EmailOrPhone rule with mustBeUnique: true, businessId, ignoreUserId",
                                "role": "required, string, in:admin,regular",
                                "status": "required, string, in:active,inactive"
                            },
                            "prepareForValidation": "Convert empty email strings to null"
                        },
                        "controller_update": {
                            "business_validation": "Verify user belongs to same business",
                            "soft_delete_check": "Prevent updating soft-deleted users",
                            "phone_detection": "If email starts with '+', set phone field and clear email field",
                            "enum_conversion": "Use UserRole::from() and UserStatus::from() for enum conversion"
                        },
                        "modal_structure": {
                            "pattern": "Follow existing credit limit modal pattern for consistency",
                            "form_submission": "Use Inertia form.put() with preserveScroll: true",
                            "initialization": "Initialize form with current user values when opening modal"
                        }
                    },
                    "translation_keys": [
                        "edit_account_details",
                        "update_user_information",
                        "email_or_phone",
                        "updating",
                        "active",
                        "inactive"
                    ],
                    "wayfinder_generation": "Run php artisan wayfinder:generate after adding new routes",
                    "benefits": [
                        "Consistent UI patterns across the application",
                        "Better UX with radio buttons for 2 options and toggle for binary state",
                        "Reuses proven patterns from existing components",
                        "Proper validation with business scoping and user exclusion"
                    ]
                },
                {
                    "lesson": "Comprehensive Dark Mode Styling for Tables",
                    "description": "Tables require comprehensive dark mode styling including backgrounds, text colors, dividers, and alternating row colors. All table elements need dark mode variants for proper contrast and readability.",
                    "implementation": {
                        "table_dividers": "Add dark:divide-gray-700 to table element: class='divide-y divide-gray-300 dark:divide-gray-700'",
                        "table_header": "Add bg-gray-50 dark:bg-gray-800 background and dark:text-gray-100 for text",
                        "table_body": "Add dark:bg-gray-900 background",
                        "alternating_rows": "Add dark:even:bg-gray-800/50 for even rows: class='even:bg-gray-50 dark:even:bg-gray-800/50'",
                        "text_colors": {
                            "headers": "dark:text-gray-100",
                            "primary_text": "dark:text-gray-100",
                            "secondary_text": "dark:text-gray-400"
                        },
                        "amount_colors": {
                            "debit": "dark:text-red-400",
                            "credit": "dark:text-green-400"
                        },
                        "links": "dark:text-indigo-400 dark:hover:text-indigo-300"
                    },
                    "pattern": {
                        "table": "<table class='divide-y divide-gray-300 dark:divide-gray-700'>",
                        "thead": "<thead class='bg-gray-50 dark:bg-gray-800'>",
                        "th": "<th class='text-gray-900 dark:text-gray-100'>",
                        "tbody": "<tbody class='bg-white dark:bg-gray-900'>",
                        "tr": "<tr class='even:bg-gray-50 dark:even:bg-gray-800/50'>",
                        "td": "<td class='text-gray-900 dark:text-gray-100'> or <td class='text-gray-500 dark:text-gray-400'>"
                    },
                    "benefits": [
                        "Consistent dark mode appearance across all tables",
                        "Proper contrast for readability",
                        "Professional appearance in both light and dark modes"
                    ]
                },
                {
                    "lesson": "Mobile Responsive Table Columns with Hidden Classes",
                    "description": "Hide table columns on mobile using hidden sm:table-cell pattern. This ensures only essential columns are visible on small screens while maintaining full table structure on larger screens.",
                    "implementation": {
                        "pattern": "class='hidden px-3 py-4 text-sm text-gray-500 sm:table-cell dark:text-gray-400'",
                        "mobile_columns": "Show only essential columns (Name, Role/Status) on mobile",
                        "desktop_columns": "Show all columns (Name, Email/Phone, Role, Status) on desktop",
                        "empty_state": "colspan should match total number of columns (including hidden ones)"
                    },
                    "example": {
                        "mobile": "Name column + Role/Status column (stacked)",
                        "desktop": "Name, Email/Phone, Role, Status columns"
                    },
                    "benefits": [
                        "Better mobile UX with focused information",
                        "Full data visibility on desktop",
                        "Responsive design without separate mobile views"
                    ]
                },
                {
                    "lesson": "Route Removal and Complete Cleanup",
                    "description": "When removing routes (e.g., Dashboard), update ALL references including breadcrumbs, navigation items, imports, and route helpers. Ensure no orphaned references remain.",
                    "implementation": {
                        "checklist": [
                            "Remove route definition from routes/web.php",
                            "Update breadcrumbs to remove route references",
                            "Update navigation items (sidebar, header)",
                            "Remove route imports from components",
                            "Update redirect logic (e.g., / route redirect)",
                            "Run wayfinder:generate to update route helpers"
                        ],
                        "breadcrumbs": "Remove Dashboard entry, start with Users or appropriate top-level page",
                        "navigation": "Replace dashboard() with usersIndex() in nav items",
                        "redirects": "Update / route to redirect to new default page when logged in"
                    },
                    "pattern": {
                        "route_removal": "Delete Route::get('dashboard', ...) from web.php",
                        "breadcrumb_update": "Remove { title: 'Dashboard', href: dashboard().url } from breadcrumbs array",
                        "nav_update": "Change { title: 'Dashboard', href: dashboard() } to { title: 'Users', href: usersIndex() }"
                    },
                    "benefits": [
                        "No broken links or references",
                        "Clean codebase without orphaned code",
                        "Consistent navigation structure"
                    ]
                },
                {
                    "lesson": "Help Page Creation Following Existing Patterns",
                    "description": "When creating new informational pages (e.g., Help), follow existing page patterns (like PrivacyPolicy.vue) for consistency in structure, styling, and layout.",
                    "implementation": {
                        "structure": "Match PrivacyPolicy.vue structure: Head component, header section, content sections, footer",
                        "styling": "Use same Tailwind classes: min-h-screen bg-gray-50, max-w-4xl container, prose sections",
                        "route_pattern": "Create route in web.php: Route::get('help', function () { return Inertia::render('Help'); })->name('help');",
                        "navigation": "Add to sidebar footerNavItems with appropriate icon (HelpCircle)",
                        "wayfinder": "Run php artisan wayfinder:generate to create route helper"
                    },
                    "pattern": {
                        "page_structure": "Head  Header  Content Sections  Footer",
                        "route": "Route::get('page-name', fn() => Inertia::render('PageName'))->name('page-name');",
                        "sidebar": "{ title: 'Help', href: help(), icon: HelpCircle }"
                    },
                    "benefits": [
                        "Consistent user experience across pages",
                        "Familiar structure for maintenance",
                        "Reusable patterns for future pages"
                    ]
                }
            ]
        }
    },
    "business_settings_and_currency_management": {
        "session_61": {
            "session_date": "2025-01-XX",
            "session_number": 61,
            "topic": "Business Settings, Currency Management, and URL Parameter Handling",
            "lessons": [
                {
                    "lesson": "Admin-Only Settings Pages Pattern",
                    "description": "Settings pages for admin-only features (e.g., Business settings) should follow the same pattern as other settings pages (Profile, Language, Appearance) but conditionally display in navigation based on user role.",
                    "implementation": {
                        "controller": "BusinessController with edit() and update() methods, admin authorization check",
                        "form_request": "BusinessUpdateRequest with authorize() method checking isAdmin()",
                        "route_pattern": "Route::get('settings/business', [BusinessController::class, 'edit'])->name('business.edit'); Route::patch('settings/business', [BusinessController::class, 'update'])->name('business.update');",
                        "navigation_conditional": "In SettingsLayout.vue, conditionally add business settings: if (user.value?.role === 'admin') { items.push({ title: t('business'), href: editBusiness() }); }",
                        "page_structure": "Follow same structure as other settings pages: AppLayout  SettingsLayout  HeadingSmall  Form with Input fields"
                    },
                    "authorization_pattern": {
                        "controller": "if ($user->role !== UserRole::ADMIN) { abort(403, 'Only administrators can change business.'); }",
                        "form_request": "public function authorize(): bool { return $this->user()->isAdmin(); }"
                    },
                    "benefits": [
                        "Consistent UX with other settings pages",
                        "Clear separation of admin vs user features",
                        "Easy to extend with additional admin settings"
                    ]
                },
                {
                    "lesson": "Currency Selector Component Pattern",
                    "description": "Currency selector component should follow the same pattern as LanguageSelector - using Headless UI Combobox with search functionality, displaying currency symbol, label, and code.",
                    "implementation": {
                        "component_structure": "CurrencySelector.vue with Combobox, ComboboxInput, ComboboxOptions, search filtering",
                        "currency_data": "Array of currency objects with code, label, symbol properties",
                        "supported_currencies": "INR, USD, EUR, GBP, SGD, JPY, KRW (must match CurrencyService conversion factors)",
                        "display_format": "${symbol} ${label} (${code}) - e.g., ' Indian Rupee (INR)'",
                        "form_integration": "Use v-model for two-way binding, hidden input for form submission: <input type=\"hidden\" name=\"currency_code\" :value=\"currencyCode\" />"
                    },
                    "validation_sync": {
                        "frontend": "CurrencySelector component displays available currencies",
                        "backend": "BusinessUpdateRequest validates currency_code with 'in:INR,USD,EUR,GBP,SGD,JPY,KRW'",
                        "service": "CurrencyService must have conversion factors for all supported currencies"
                    },
                    "pattern": {
                        "currencies_array": "const currencies: Currency[] = [{ code: 'INR', label: 'Indian Rupee', symbol: '' }, ...];",
                        "form_usage": "<CurrencySelector v-model=\"currencyCode\" /> <input type=\"hidden\" name=\"currency_code\" :value=\"currencyCode\" />"
                    },
                    "benefits": [
                        "Consistent UX with other selector components",
                        "Easy to add new currencies (update three places: component, validation, service)",
                        "Search functionality improves UX for many currencies"
                    ]
                },
                {
                    "lesson": "Currency Service Consistency Across Application",
                    "description": "When adding new currencies, update all three places: CurrencySelector component, BusinessUpdateRequest validation, and CurrencyService conversion factors. All must stay in sync.",
                    "implementation": {
                        "component": "Add currency to currencies array in CurrencySelector.vue",
                        "validation": "Add currency code to 'in:' rule in BusinessUpdateRequest",
                        "service": "Add conversion factor to both toSmallestUnit() and fromSmallestUnit() methods in CurrencyService"
                    },
                    "sync_checklist": [
                        "CurrencySelector.vue - currencies array",
                        "BusinessUpdateRequest.php - validation 'in:' rule",
                        "CurrencyService.php - toSmallestUnit() conversion factors",
                        "CurrencyService.php - fromSmallestUnit() conversion factors"
                    ],
                    "pattern": {
                        "adding_currency": "1. Add to CurrencySelector currencies array, 2. Add to validation 'in:' rule, 3. Add conversion factor to both CurrencyService methods"
                    },
                    "benefits": [
                        "Prevents validation errors",
                        "Ensures currency conversion works correctly",
                        "Maintains consistency across application"
                    ]
                },
                {
                    "lesson": "URL Parameter Handling with Sluggified Business Names",
                    "description": "When handling business selection via URL parameters (e.g., ?business=acme-corp), use sluggified name matching for better URL-friendliness. Support both ID (numeric) and sluggified name matching.",
                    "implementation": {
                        "slug_function": "slugify() function converts strings to URL-friendly slugs: lowercase, remove special chars, replace spaces with hyphens, trim hyphens",
                        "matching_logic": "1. Try ID match first (if parameter is numeric), 2. Try sluggified name match (compare slugified parameter with slugified business names)",
                        "url_parameter": "Read from URLSearchParams: const urlParams = new URLSearchParams(window.location.search); const businessParam = urlParams.get('business');",
                        "auto_selection": "Call autoSelectBusinessFromUrl() after businesses are loaded in onMounted()"
                    },
                    "slug_pattern": {
                        "function": "const slugify = (str: string): string => { return str.toLowerCase().trim().replace(/[^\\w\\s-]/g, '').replace(/[\\s_-]+/g, '-').replace(/^-+|-+$/g, ''); };",
                        "matching": "const businessParamSlug = slugify(businessParam); const matchedBusiness = businesses.value.find((b) => slugify(b.name) === businessParamSlug);"
                    },
                    "url_examples": {
                        "id": "/login?business=123  matches by business ID",
                        "slug": "/login?business=acme-corp  matches 'Acme Corp' by sluggified name",
                        "case_insensitive": "/login?business=ACME-CORP  matches 'Acme Corp' (slug is case-insensitive)"
                    },
                    "benefits": [
                        "URL-friendly business names in links",
                        "Easy to share login links with business context",
                        "Supports both ID and name matching for flexibility"
                    ]
                },
                {
                    "lesson": "Business Settings - Update Current Business Only",
                    "description": "Business settings should only allow updating the current user's business (name, currency), not switching between businesses. Use auth()->user()->business_id to get current business.",
                    "implementation": {
                        "controller": "$business = Business::findOrFail($user->business_id); // Get current user's business, not from request",
                        "update_logic": "$business->name = $validated['name']; $business->currency_code = $validated['currency_code']; $business->save();",
                        "form_fields": "Simple form with name input and currency selector - no business selector dropdown"
                    },
                    "security": {
                        "never_accept_business_id": "Never accept business_id from request - always use auth()->user()->business_id",
                        "admin_only": "Only admins can access business settings page",
                        "current_business_only": "Can only update the business the admin belongs to"
                    },
                    "pattern": {
                        "edit": "public function edit(Request $request): Response { $business = Business::findOrFail($request->user()->business_id); return Inertia::render('settings/Business', ['business' => ['id' => $business->id, 'name' => $business->name, 'currency_code' => $business->currency_code]]); }",
                        "update": "public function update(BusinessUpdateRequest $request): RedirectResponse { $business = Business::findOrFail($request->user()->business_id); $business->update($request->validated()); return back()->with('flash.banner', trans('messages.business_updated')); }"
                    },
                    "benefits": [
                        "Prevents unauthorized business switching",
                        "Simpler UX - no need to select business",
                        "Secure by default - uses authenticated user's business"
                    ]
                }
            ]
        }
    },
    "help_page_documentation_and_maintenance": {
        "session_62": {
            "session_date": "2025-01-XX",
            "session_number": 62,
            "topic": "Help Page Updates - Dark Mode, Settings Documentation, and Currency Additions",
            "lessons": [
                {
                    "lesson": "Adding New Currencies Requires Three-Place Updates",
                    "description": "When adding a new currency to the system, update all three places: CurrencySelector component, BusinessUpdateRequest validation, and CurrencyService conversion factors. All must stay in sync to prevent validation errors and ensure correct currency conversion.",
                    "implementation": {
                        "component": "Add currency to currencies array in CurrencySelector.vue with code, label, and symbol",
                        "validation": "Add currency code to 'in:' validation rule in BusinessUpdateRequest.php",
                        "service": "Add conversion factor to both toSmallestUnit() and fromSmallestUnit() methods in CurrencyService.php"
                    },
                    "sync_checklist": [
                        "CurrencySelector.vue - currencies array",
                        "BusinessUpdateRequest.php - validation 'in:' rule",
                        "CurrencyService.php - toSmallestUnit() conversion factors",
                        "CurrencyService.php - fromSmallestUnit() conversion factors"
                    ],
                    "pattern": {
                        "adding_sgd": "1. Add { code: 'SGD', label: 'Singapore Dollar', symbol: 'S$' } to CurrencySelector, 2. Add 'SGD' to validation 'in:INR,USD,EUR,GBP,SGD,JPY,KRW', 3. Add 'SGD' => 100 to both CurrencyService conversion factor arrays"
                    },
                    "benefits": [
                        "Prevents validation errors when users select new currency",
                        "Ensures currency conversion works correctly",
                        "Maintains consistency across application"
                    ],
                    "conversion_factors": {
                        "currencies_with_subunits": "INR, USD, EUR, GBP, SGD all use 100 (cents/paisa/pence)",
                        "currencies_without_subunits": "JPY, KRW use 1 (no smaller unit)",
                        "default": "Unknown currencies default to 100"
                    }
                },
                {
                    "lesson": "Help Page Dark Mode Support Pattern",
                    "description": "Help pages should include comprehensive dark mode support matching other informational pages (like PrivacyPolicy.vue) for consistent user experience across light and dark themes.",
                    "implementation": {
                        "background_colors": "Main container: bg-gray-50 dark:bg-gray-900, Cards: bg-white dark:bg-gray-800",
                        "text_colors": {
                            "headings": "text-gray-900 dark:text-gray-100",
                            "body": "text-gray-700 dark:text-gray-300",
                            "subtle": "text-gray-600 dark:text-gray-400",
                            "labels": "text-gray-500 dark:text-gray-400"
                        },
                        "borders": "border-gray-200 dark:border-gray-700",
                        "links": "text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100"
                    },
                    "pattern": {
                        "container": "<div class=\"min-h-screen bg-gray-50 dark:bg-gray-900\">",
                        "card": "<div class=\"rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-6\">",
                        "heading": "<h2 class=\"text-2xl font-semibold text-gray-900 dark:text-gray-100\">",
                        "body_text": "<p class=\"text-gray-700 dark:text-gray-300\">"
                    },
                    "benefits": [
                        "Consistent user experience across all pages",
                        "Professional appearance in both themes",
                        "Better readability in dark mode"
                    ]
                },
                {
                    "lesson": "Help Page Settings Documentation",
                    "description": "Help pages should document all settings features including how to access them and what they do. This includes Profile, Password, Appearance, Language, and Business settings (admin-only).",
                    "implementation": {
                        "settings_section": "Add Settings section to Help page documenting all settings pages",
                        "descriptions": "Each setting should include: what it does, how to access it (Settings > [Setting Name]), and important details",
                        "business_settings_special": "Business settings should note it's admin-only and mention supported currencies"
                    },
                    "translation_pattern": {
                        "naming": "Use descriptive translation keys: {setting}_settings_description for help page descriptions",
                        "example": "business_settings_help_description describes business settings functionality for help page",
                        "consistency": "Follow pattern: {feature}_description for feature descriptions, {feature}_help_description for help page specific descriptions"
                    },
                    "content_structure": {
                        "profile": "Update personal information (name, email)",
                        "password": "Change account password",
                        "appearance": "Customize theme (light/dark/system)",
                        "language": "Change interface language",
                        "business": "Update business name and currency (admin-only)"
                    },
                    "benefits": [
                        "Users can discover settings features",
                        "Clear instructions for accessing settings",
                        "Reduces support requests",
                        "Comprehensive feature documentation"
                    ]
                },
                {
                    "lesson": "Translation Keys for Help Page Documentation",
                    "description": "When adding help documentation for features, use descriptive translation keys that clearly indicate they're for help/documentation purposes. Use {feature}_help_description pattern for help-specific descriptions.",
                    "implementation": {
                        "naming_convention": "{feature}_help_description for help page specific descriptions",
                        "example": "business_settings_help_description vs business_settings_description (form description)",
                        "all_languages": "Add translations to all three language files (English, Hindi, Romanized Hindi)"
                    },
                    "pattern": {
                        "help_description": "'business_settings_help_description' => 'Administrators can update...'",
                        "form_description": "'business_settings_description' => 'Update your business name and currency'"
                    },
                    "separation": {
                        "help_page": "More detailed, includes navigation instructions and feature details",
                        "form_page": "Brief, action-oriented description for form headers"
                    },
                    "benefits": [
                        "Clear separation between form descriptions and help documentation",
                        "More detailed help content without cluttering form descriptions",
                        "Flexible content for different contexts"
                    ]
                },
                {
                    "lesson": "Wayfinder Form Submission Patterns",
                    "description": "Not all wayfinder routes provide a `.form()` method. When a route doesn't have `.form()`, use Inertia's `useForm()` hook directly and submit using `form.post(route.url())` instead of `v-bind=\"route.form()\"`.",
                    "implementation": {
                        "check_for_form_method": "Check if route has `.form()` method before using it",
                        "use_useform_directly": "Use `useForm({ ... })` from `@inertiajs/vue3` to create form object",
                        "submit_with_post": "Use `form.post(route.url())` for form submission",
                        "regular_form_element": "Use standard `<form>` element instead of `<Form>` component when route doesn't have `.form()`"
                    },
                    "pattern": {
                        "with_form_method": "const form = route.form(); <Form v-bind=\"route.form()\">",
                        "without_form_method": "const form = useForm({ email: '', password: '' }); <form @submit.prevent=\"form.post(route.url())\">"
                    },
                    "error_handling": {
                        "common_error": "TypeError: store.form is not a function",
                        "solution": "Replace `store.form()` with `useForm({ ... })` and use regular form element",
                        "error_references": "Update all `errors` and `processing` references to `form.errors` and `form.processing`"
                    },
                    "examples": {
                        "login_route": "Login route may not have `.form()` - use `useForm()` directly",
                        "register_route": "Register route may not have `.form()` - use `useForm()` directly",
                        "other_routes": "Some routes have `.form()`, others don't - check before using"
                    },
                    "benefits": [
                        "Works with all wayfinder routes regardless of `.form()` availability",
                        "Consistent form handling across all routes",
                        "Prevents runtime errors from missing `.form()` method"
                    ]
                },
                {
                    "lesson": "Multi-Tenant Email Validation Patterns",
                    "description": "When validating email/phone existence in multi-tenant systems, if `business_id` is null, don't filter by `whereNull('business_id')`. Instead, search across all businesses. In multi-tenant systems, all users have a `business_id`, so filtering by NULL will never find users.",
                    "implementation": {
                        "null_business_id": "When `business_id` is null, don't add any business_id filter - search across all businesses",
                        "provided_business_id": "When `business_id` is provided, filter by that specific business_id for security",
                        "both_controllers": "Apply this pattern in both `SmsVerificationController` and `FortifyServiceProvider`"
                    },
                    "pattern": {
                        "incorrect": "if ($businessId) { $query->where('business_id', $businessId); } else { $query->whereNull('business_id'); }",
                        "correct": "if ($businessId) { $query->where('business_id', $businessId); } // If null, search across all businesses"
                    },
                    "affected_methods": {
                        "sms_verification": "SmsVerificationController::findUserByEmailOrPhone()",
                        "fortify_authentication": "FortifyServiceProvider::findUserByEmailOrPhone()"
                    },
                    "behavior": {
                        "with_business_id": "Searches only within specified business (security maintained)",
                        "without_business_id": "Searches across all businesses (allows finding user regardless of business)"
                    },
                    "error_scenario": {
                        "symptom": "Email does not exist error when email actually exists in database",
                        "cause": "Filtering by `whereNull('business_id')` when all users have a business_id",
                        "fix": "Remove `whereNull('business_id')` filter when business_id is null"
                    },
                    "benefits": [
                        "Correctly finds users when business is not selected",
                        "Maintains security when business is selected",
                        "Works correctly in multi-tenant systems where all users have business_id"
                    ]
                },
                {
                    "lesson": "Form Error Display Patterns",
                    "description": "Validation errors should only appear below their respective fields, not at the top of forms. Remove any top-level error display sections that show all errors together.",
                    "implementation": {
                        "remove_top_errors": "Remove sections that display all form errors at the top of forms",
                        "field_level_errors": "Use `<InputError>` components below each field to show field-specific errors",
                        "error_references": "Reference errors via `form.errors?.fieldName` in field-level error components"
                    },
                    "pattern": {
                        "incorrect": "<div v-if=\"form.errors && Object.keys(form.errors).length > 0\"><InputError v-for=\"(error, key) in form.errors\" :message=\"error\" /></div>",
                        "correct": "<InputError :message=\"form.errors?.password\" /> (below password field)"
                    },
                    "user_experience": {
                        "top_errors": "Shows generic error messages at top (confusing, not helpful)",
                        "field_errors": "Shows specific error below each field (clear, actionable)"
                    },
                    "benefits": [
                        "Clearer error messages for users",
                        "Better user experience with field-specific errors",
                        "Follows standard form validation patterns"
                    ]
                },
                {
                    "lesson": "Password Field Synchronization Patterns",
                    "description": "When using `v-model` with refs (`passwordValue`) and also managing form state with `useForm`, sync both directions - from ref to form and from form to ref.",
                    "implementation": {
                        "ref_to_form": "Watch `passwordValue` ref and update `form.password` when it changes",
                        "form_to_ref": "Watch `form.password` and update `passwordValue` ref when it changes",
                        "bidirectional_sync": "Both watchers ensure form state and UI state stay in sync"
                    },
                    "pattern": {
                        "ref_to_form": "watch(passwordValue, (newValue) => { if (!isPhoneNumber.value) { form.password = newValue || ''; } });",
                        "form_to_ref": "watch(() => form.password, (newPassword) => { if (!isPhoneNumber.value) { passwordValue.value = newPassword || ''; } });"
                    },
                    "use_cases": {
                        "login_forms": "Login forms with password fields that use both refs and form state",
                        "registration_forms": "Registration forms with password confirmation fields",
                        "password_update_forms": "Password update forms with current/new/confirm password fields"
                    },
                    "benefits": [
                        "Form state and UI state stay synchronized",
                        "Prevents form submission with stale data",
                        "Works correctly with both ref-based and form-based state management"
                    ]
                }
            ]
        }
    },
    "password_reset_notification_customization": {
        "session_65": {
            "session_date": "2026-01-01",
            "session_number": 65,
            "topic": "Password Reset Notification Customization - Custom Notification Classes and Email Patterns",
            "lessons": [
                {
                    "lesson": "Custom Notification Classes vs toMailUsing() Closures",
                    "description": "Prefer creating custom notification classes that extend Laravel's built-in notifications over using toMailUsing() closures in AppServiceProvider. Custom notification classes provide better organization, testability, and maintainability.",
                    "implementation": {
                        "create_notification": "Create custom notification class extending Illuminate\\Auth\\Notifications\\ResetPassword (e.g., App\\Notifications\\ResetPasswordNotification)",
                        "override_tomail": "Override toMail() method in custom notification class to customize email content",
                        "override_in_user_model": "Override sendPasswordResetNotification() method in User model to use custom notification",
                        "remove_tomailusing": "Remove toMailUsing() customization from AppServiceProvider boot() method"
                    },
                    "pattern": {
                        "custom_notification": "class ResetPasswordNotification extends ResetPasswordNotification { public function toMail($notifiable): MailMessage { ... } }",
                        "user_model": "public function sendPasswordResetNotification($token): void { $this->notify(new ResetPasswordNotification($token)); }",
                        "app_service_provider": "Remove ResetPassword::toMailUsing() closure - notification customization moved to notification class"
                    },
                    "benefits": [
                        "Better code organization - notification logic in dedicated class",
                        "Easier to customize - override methods or add new ones",
                        "Better testability - can test notification class independently",
                        "Cleaner AppServiceProvider - removes large closure from service provider",
                        "Follows Laravel conventions - uses standard notification pattern"
                    ],
                    "migration_pattern": {
                        "from": "ResetPassword::toMailUsing(function ($notifiable, $token) { ... }) in AppServiceProvider",
                        "to": "Custom ResetPasswordNotification class with toMail() method + User model override"
                    }
                },
                {
                    "lesson": "Laravel MailMessage Only Supports One Action Button",
                    "description": "Laravel's MailMessage class only supports ONE action button per email. Multiple ->action() calls will override each other - only the last one will be displayed. For multiple clickable links, use markdown link syntax in ->line() calls.",
                    "implementation": {
                        "primary_action": "Use ->action() for the primary action button (most prominent)",
                        "secondary_links": "Use markdown link syntax in ->line() for secondary clickable links",
                        "markdown_syntax": "Use [Link Text](url) syntax in ->line() calls - Laravel converts markdown to clickable HTML links"
                    },
                    "pattern": {
                        "single_action_button": "->action('Reset Password', $actionUrl) // One primary button",
                        "markdown_link": "->line('Click [Forgot Password]('.$resetUrl.') to request a new link.') // Secondary link",
                        "incorrect_multiple_actions": "->action('Reset Password', $url1)->action('Forgot Password', $url2) // WRONG - only second button shows"
                    },
                    "email_structure": {
                        "primary_cta": "One prominent action button for main action (e.g., 'Reset Password')",
                        "secondary_links": "Text links in body for secondary actions (e.g., 'Forgot Password' link)"
                    },
                    "benefits": [
                        "Standard email pattern - one primary CTA button, secondary actions as links",
                        "Better email client compatibility",
                        "Clearer visual hierarchy",
                        "Professional email design"
                    ],
                    "common_mistake": {
                        "symptom": "Only one button appears in email despite multiple ->action() calls",
                        "cause": "Multiple ->action() calls - each overwrites the previous one",
                        "solution": "Use ->action() for primary button, ->line() with markdown for secondary links"
                    }
                },
                {
                    "lesson": "Business-Scoped Password Resets with Sluggified Names",
                    "description": "In multi-tenant applications, password reset links should include business context using sluggified business names (not IDs) in URL parameters. Store business_id in session/app container during request, retrieve in notification, convert to sluggified name for URLs.",
                    "implementation": {
                        "store_business_context": "Store business_id in session (HTTP requests) or app container (console commands) before sending reset link",
                        "retrieve_in_notification": "Retrieve business_id from session/app container in notification's toMail() method",
                        "slugify_business_name": "Convert business_id to sluggified business name using Str::slug()",
                        "include_in_urls": "Include sluggified business name as 'business' query parameter in reset URLs",
                        "frontend_matching": "Frontend components match business by both ID (numeric) and sluggified name"
                    },
                    "pattern": {
                        "controller": "session()->put('password_reset_business_id', $businessId); Password::broker()->sendResetLink(['email' => $user->email]);",
                        "console_command": "app()->instance('password_reset_business_id', $businessId); Password::broker()->sendResetLink(['email' => $user->email]);",
                        "notification": "$businessId = session()->get('password_reset_business_id') ?? app('password_reset_business_id'); $businessSlug = Str::slug($business->name); $resetParams['business'] = $businessSlug;",
                        "frontend": "Match by ID: parseInt(businessParam) or by slug: slugify(business.name) === slugify(businessParam)"
                    },
                    "url_structure": {
                        "reset_link": "/reset-password?token=xxx&email=user@example.com&business=acme-corp",
                        "forgot_password_link": "/forgot-password?business=acme-corp"
                    },
                    "benefits": [
                        "User-friendly URLs with readable business names instead of IDs",
                        "SEO-friendly if URLs are ever indexed",
                        "Better security - doesn't expose business IDs in URLs",
                        "Maintains business context throughout password reset flow"
                    ],
                    "constraints": [
                        "Business_id must be stored before sending notification (session/app container)",
                        "Business must be fetched and slugified in notification (not stored in notification properties)",
                        "Frontend must handle both ID and sluggified name matching"
                    ]
                },
                {
                    "lesson": "Password Reset Notification String Concatenation",
                    "description": "When concatenating markdown links within ->line() calls, use proper string concatenation operators. Don't close string quotes prematurely - markdown link syntax must be within a single concatenated string expression.",
                    "implementation": {
                        "proper_concatenation": "Use . operator to concatenate all parts: 'Text ['.Lang::get('Link Text').']('.$url.') more text'",
                        "single_string": "All parts (text, markdown syntax, variables) must be concatenated into one string"
                    },
                    "pattern": {
                        "correct": "->line('If the link has expired, then please click on ['.Lang::get('Forgot Password').']('.$resetUrl.') to request a new link.')",
                        "incorrect": "->line('Text '['.Lang::get('Text').']('.$url.')') // WRONG - quote closed prematurely"
                    },
                    "common_error": {
                        "symptom": "Syntax error: unexpected identifier, expecting ']'",
                        "cause": "String quote closed before markdown syntax, PHP tries to parse '[' as separate expression",
                        "solution": "Properly concatenate all parts with . operator in single string expression"
                    },
                    "benefits": [
                        "Clean, readable code",
                        "Proper markdown link rendering in emails",
                        "No syntax errors"
                    ]
                }
            ]
        }
    },
    "authentication_error_messages_and_logout_redirects": {
        "session_66": {
            "session_date": "2026-01-01",
            "session_number": 66,
            "topic": "Authentication Error Messages & Logout Redirects - Correct Error Field Selection and Business Context Preservation",
            "lessons": [
                {
                    "lesson": "Authentication Error Message Field Selection",
                    "description": "When authentication fails due to incorrect password (but user exists), the error should be on the 'password' field with message 'The provided password is incorrect.', not on the 'email' field with message 'Email does not exist.'. The user was found, so the email exists - only the password is wrong.",
                    "problem": "When user enters correct email but wrong password, system shows 'Email does not exist.' error on email field, which is confusing and incorrect.",
                    "implementation": {
                        "correct_error_field": "Throw ValidationException with 'password' field when Hash::check() fails",
                        "correct_error_message": "Use 'The provided password is incorrect.' message for password errors",
                        "incorrect_pattern": "Do NOT throw 'Email does not exist.' when password is wrong - user exists, password is wrong"
                    },
                    "pattern": {
                        "correct": "if (! Hash::check($password, $user->password)) { throw ValidationException::withMessages(['password' => 'The provided password is incorrect.']); }",
                        "incorrect": "if (! Hash::check($password, $user->password)) { throw ValidationException::withMessages(['email' => 'Email does not exist.']); } // WRONG - user exists!"
                    },
                    "scenario": {
                        "multi_tenant": "When email exists for both business 1 and business 2, user selects business 1 but enters password for business 2",
                        "expected_behavior": "Show password error, not email error",
                        "user_experience": "User knows password is wrong, not that email doesn't exist"
                    },
                    "testing": {
                        "test_pattern": "Create two users with same email in different businesses, try to login with wrong password, verify password error (not email error)",
                        "assertions": "assertSessionHasErrors('password'), assertSessionDoesntHaveErrors('email')"
                    },
                    "benefits": [
                        "Clear error messages for users",
                        "Correct field-level error display",
                        "Better user experience - users know what to fix"
                    ]
                },
                {
                    "lesson": "Logout Redirect with Business Context",
                    "description": "When users logout, they should be redirected to /login (not /) with the business slug as a query parameter. This preserves business context and allows users to return to the correct business login page after logout.",
                    "problem": "Default Fortify logout redirects to /, losing business context. Users with same email across businesses need to know which business they're logging out from.",
                    "implementation": {
                        "custom_logout_controller": "Create custom AuthenticatedSessionController that overrides Fortify's default logout",
                        "capture_business_slug": "Get business slug from user's business relationship BEFORE logout (user is null after logout)",
                        "store_in_session": "Store business slug in session before session invalidation",
                        "preserve_across_regeneration": "Retrieve business slug from session before invalidating, store again after regenerating token",
                        "custom_logout_response": "Create LogoutResponse implementation that retrieves business slug from session and builds redirect URL",
                        "override_route": "Override Fortify's logout route in routes/web.php to use custom controller"
                    },
                    "pattern": {
                        "controller": "public function destroy(Request $request): LogoutResponse { $businessSlug = $user->business ? Str::slug($user->business->name) : null; $request->session()->put('logout_business_slug', $businessSlug); $this->guard->logout(); $storedBusinessSlug = $request->session()->get('logout_business_slug'); $request->session()->invalidate(); $request->session()->regenerateToken(); if ($storedBusinessSlug) { $request->session()->put('logout_business_slug', $storedBusinessSlug); } return app(LogoutResponse::class); }",
                        "logout_response": "public function toResponse($request) { $businessSlug = $request->session()->get('logout_business_slug'); $loginUrl = route('login'); if ($businessSlug) { $loginUrl = route('login', ['business' => $businessSlug]); } $request->session()->forget('logout_business_slug'); return redirect($loginUrl); }",
                        "route_override": "Route::post('/logout', [AuthenticatedSessionController::class, 'destroy'])->middleware('auth')->name('logout');"
                    },
                    "critical_timing": {
                        "fortify_behavior": "Fortify logs out user BEFORE calling LogoutResponse, so $request->user() is null in LogoutResponse",
                        "solution": "Store business slug in session BEFORE logout, retrieve from session in LogoutResponse",
                        "session_invalidation": "Session invalidation clears all session data, so retrieve business slug BEFORE invalidating, store again AFTER regenerating token"
                    },
                    "testing": {
                        "test_pattern": "Create user with business, logout, verify redirect to /login?business={business-slug}",
                        "assertions": "$response->assertRedirect(route('login', ['business' => $businessSlug]));"
                    },
                    "benefits": [
                        "Preserves business context after logout",
                        "Users return to correct business login page",
                        "Better UX for multi-tenant applications",
                        "Maintains business selection in URL for easy re-login"
                    ]
                }
            ]
        }
    },
    "payment_stats_calculation": {
        "description": "Payment stats must be calculated from the same data source where payments are actually stored. Payments are recorded as CreditTransaction records with type PAYMENT, not as separate Repayment records.",
        "session_context": "Fixed bug where payment metrics (Total Repayments, Total Repayment Amount) were not updating on user show page because stats were calculated from Repayment table that was never populated",
        "problem": {
            "symptom": "Payment metrics showed 0 even after payments were made",
            "root_cause": "Payments were recorded as CreditTransaction records with type PAYMENT, but stats were calculated from Repayment table which was never populated",
            "data_mismatch": "Stats calculation used different data source than where payments were actually stored"
        },
        "solution": {
            "drop_unused_table": "Dropped repayments table since it was never used",
            "update_stats_calculation": "Updated UserController to calculate payment stats from CreditTransaction records with type PAYMENT instead of Repayment records",
            "remove_unused_relationships": "Removed repayments() relationship from CreditAccount model"
        },
        "implementation_steps": [
            "Create migration to drop repayments table (include proper down() method for rollback)",
            "Update UserController::show() to calculate totalRepayments and totalRepaymentAmount from paymentTransactions collection",
            "Remove Repayment import from UserController",
            "Remove repayments() relationship method from CreditAccount model",
            "Update tests to expect correct values from CreditTransaction-based calculations"
        ],
        "code_changes": {
            "controller_before": "// Get all repayments for this account\n$repayments = Repayment::where('account_id', $creditAccount->id)->get();\n$totalRepayments = $repayments->count();\n$totalRepaymentAmount = $currencyService->fromSmallestUnit($repayments->sum('amount'), $currencyCode);",
            "controller_after": "// Calculate repayment stats from payment transactions\n$totalRepayments = $paymentTransactions->count();\n$totalRepaymentAmount = $totalPaymentAmount;",
            "migration": "Schema::dropIfExists('repayments');"
        },
        "data_source_alignment": {
            "payment_storage": "Payments are stored as CreditTransaction records with type CreditTransactionType::PAYMENT",
            "stats_calculation": "Payment stats must be calculated from the same CreditTransaction records",
            "principle": "Stats calculation data source must match where data is actually stored"
        },
        "key_lessons": [
            "ALWAYS ensure stats calculation uses the same data source where data is actually stored",
            "ALWAYS verify data source alignment when stats show incorrect values (0, null, etc.)",
            "ALWAYS remove unused tables/models to avoid confusion and prevent bugs",
            "ALWAYS check if separate tables are actually being populated before using them for stats",
            "When stats show 0 but data exists, check if stats are querying the wrong table/model"
        ],
        "best_practices": {
            "data_source_verification": "Before calculating stats, verify where the data is actually stored",
            "single_source_of_truth": "Use one data source for both storage and stats calculation",
            "unused_code_removal": "Remove unused tables, models, and relationships to prevent confusion",
            "stats_debugging": "When stats show incorrect values, trace back to data source and verify alignment"
        },
        "anti_patterns": {
            "separate_storage_and_stats": "Don't store data in one place but calculate stats from another place",
            "unused_tables": "Don't keep unused tables that create confusion about data sources",
            "assume_table_population": "Don't assume a table is populated just because it exists - verify it's actually used"
        },
        "testing_patterns": {
            "verify_stats_after_operations": "After creating payments, verify stats reflect the correct counts and amounts",
            "test_data_source": "Test that stats are calculated from the correct data source",
            "comprehensive_scenarios": "Test with multiple payments, debits, and verify all stats are correct"
        },
        "related_files": [
            "database/migrations/2026_01_01_094421_drop_repayments_table.php",
            "app/Http/Controllers/UserController.php",
            "app/Models/CreditAccount.php",
            "app/Models/CreditTransaction.php",
            "tests/Feature/UserShowStatsTest.php"
        ]
    },
    "nullable_database_fields_optional_form_fields": {
        "description": "Making database fields nullable and corresponding form fields optional requires coordinated changes across migrations, validation, controllers, and frontend components.",
        "session_context": "Made email field nullable in users table and optional in Add User modal form, reordering fields to show credit_limit above email",
        "problem": {
            "requirement": "Need to allow users to be created without email addresses",
            "challenges": [
                "Database column must be nullable but may have unique constraints",
                "Validation rules need to handle nullable values",
                "Custom validation rules must handle null/empty values",
                "Controllers need to normalize empty strings to null",
                "Frontend forms need to remove required attributes",
                "Component labels should indicate optional status conditionally"
            ]
        },
        "solution": {
            "database_migration": {
                "steps": [
                    "Create migration to drop unique constraint if it exists",
                    "Make column nullable using ->nullable()->change()",
                    "Recreate unique constraint (MySQL allows multiple NULL values in unique constraints)"
                ],
                "pattern": "Schema::table('users', function (Blueprint $table) { $table->dropUnique(['business_id', 'email']); $table->string('email')->nullable()->change(); $table->unique(['business_id', 'email']); });"
            },
            "validation_rules": {
                "backend_validation": "Use 'nullable' rule instead of 'required' in validation rules",
                "pattern": "'email' => ['nullable', 'string', 'max:255', new EmailOrPhone(mustBeUnique: true, businessId: $businessId)]",
                "empty_string_normalization": "Convert empty strings to null after validation: if (isset($validated['email']) && trim($validated['email']) === '') { $validated['email'] = null; }"
            },
            "custom_validation_rules": {
                "handle_null_empty": "Custom validation rules (EmailOrPhone) must handle null/empty values gracefully",
                "pattern": "public function validate(string $attribute, mixed $value, Closure $fail): void { if ($value === null || $value === '') { return; } // ... rest of validation }"
            },
            "controller_logic": {
                "conditional_logic": "Update controller logic to handle nullable values (e.g., only send password reset if email is provided)",
                "pattern": "if ($emailOrPhone && ! $isPhone) { Password::sendResetLink(['email' => $user->email]); }"
            },
            "frontend_form": {
                "remove_required": "Remove 'required' attribute from form inputs/components",
                "pass_required_prop": "Pass :required=\"false\" to components that handle their own labels",
                "pattern": "<PhoneOrEmail :required=\"false\" ... />"
            },
            "dynamic_labels": {
                "conditional_optional_text": "Add '(optional)' to labels only when field is empty and not required",
                "pattern": "const labelText = computed(() => { const isEmpty = !inputValue.value || inputValue.value.trim() === ''; let text = isEmail.value ? 'Email address' : isPhone.value ? 'Phone number' : 'Email or phone number'; if (!props.required && isEmpty) { text += ' (optional)'; } return text; });"
            }
        },
        "implementation_steps": [
            "Create migration to make column nullable (drop/recreate unique constraints if needed)",
            "Update validation rules to use 'nullable' instead of 'required'",
            "Update custom validation rules to handle null/empty values",
            "Normalize empty strings to null in controllers after validation",
            "Update controller logic to handle nullable values conditionally",
            "Remove 'required' attribute from frontend form inputs",
            "Pass :required=\"false\" prop to components with dynamic labels",
            "Update component label logic to conditionally show '(optional)'"
        ],
        "key_lessons": [
            "ALWAYS drop and recreate unique constraints when making columns nullable",
            "ALWAYS normalize empty strings to null after validation in controllers",
            "ALWAYS update custom validation rules to handle null/empty values gracefully",
            "ALWAYS update controller logic to conditionally handle nullable values",
            "ALWAYS remove 'required' attribute from form inputs when making fields optional",
            "ALWAYS pass :required=\"false\" prop to components that manage their own labels",
            "ALWAYS show '(optional)' text only when field is empty and not required",
            "MySQL allows multiple NULL values in unique constraints, so nullable columns with unique constraints work correctly"
        ],
        "code_examples": {
            "migration": "Schema::table('users', function (Blueprint $table) { $table->dropUnique(['business_id', 'email']); $table->string('email')->nullable()->change(); $table->unique(['business_id', 'email']); });",
            "validation": "'email' => ['nullable', 'string', 'max:255', new EmailOrPhone(mustBeUnique: true, businessId: $businessId)]",
            "controller_normalization": "if (isset($validated['email']) && trim($validated['email']) === '') { $validated['email'] = null; }",
            "custom_rule": "if ($value === null || $value === '') { return; }",
            "frontend_component": "<PhoneOrEmail :required=\"false\" ... />",
            "dynamic_label": "if (!props.required && isEmpty) { text += ' (optional)'; }"
        },
        "related_files": [
            "database/migrations/2026_01_01_095153_make_users_email_nullable.php",
            "app/Http/Controllers/UserController.php",
            "app/Rules/EmailOrPhone.php",
            "resources/js/components/PhoneOrEmail.vue",
            "resources/js/pages/Users/Index.vue"
        ]
    },
    "soft_deletion_implementation": {
        "description": "Implementing soft deletion for users using Laravel's SoftDeletes trait with confirmation modals and business validation.",
        "session_context": "Added soft deletion functionality to User model with delete button, confirmation modal, and outstanding balance warning",
        "problem": {
            "requirement": "Need to allow admins to delete users while preserving data for audit/compliance purposes",
            "challenges": [
                "Implement soft deletion without losing data",
                "Prevent users from deleting themselves",
                "Validate business ownership before deletion",
                "Show appropriate warnings for users with outstanding balances",
                "Maintain consistent UI patterns with existing delete modals",
                "Ensure soft-deleted users don't appear in listings"
            ]
        },
        "solution": {
            "model_setup": {
                "add_trait": "Add SoftDeletes trait to model: use Illuminate\\Database\\Eloquent\\SoftDeletes; use SoftDeletes;",
                "migration": "Create migration to add deleted_at column: $table->softDeletes();",
                "automatic_filtering": "SoftDeletes trait automatically excludes soft-deleted records from queries"
            },
            "controller_implementation": {
                "destroy_method": "Add destroy() method with business validation and self-deletion prevention",
                "pattern": "public function destroy(Request $request, User $user): RedirectResponse { $businessId = $request->user()->business_id; if ($user->business_id !== $businessId) { abort(403); } if ($user->id === $request->user()->id) { return redirect()->back()->withErrors(['user' => 'You cannot delete your own account.']); } $user->delete(); return redirect()->route('users.index')->with('flash.banner', 'User deleted successfully.'); }",
                "show_method_check": "Add check in show() method to prevent viewing soft-deleted users: if ($user->trashed()) { abort(404); }"
            },
            "route_setup": {
                "delete_route": "Add DELETE route: Route::delete('users/{user}', [UserController::class, 'destroy'])->middleware(['auth', 'verified'])->name('users.destroy');"
            },
            "frontend_implementation": {
                "delete_button": "Add X icon button in table row similar to transaction delete button",
                "modal_state": "Add refs for showDeleteUserModal and userToDelete",
                "modal_functions": "Implement openDeleteUserModal(), closeDeleteUserModal(), and deleteUser() functions",
                "confirmation_modal": "Create confirmation modal following existing delete transaction modal pattern",
                "outstanding_balance_warning": "Show amber warning box when user has outstanding_balance > 0"
            },
            "translation_patterns": {
                "modal_translations": "Add translations for delete_user, delete_user_confirmation, delete_user_outstanding_balance_warning",
                "parameter_replacement": "Use useTranslations composable with parameter replacement: t('delete_user_outstanding_balance_warning', { amount: formattedAmount })",
                "component_translations": "Update DebitModal and PaymentModal components to use translations instead of hardcoded strings"
            }
        },
        "implementation_steps": [
            "Add SoftDeletes trait to User model",
            "Create migration to add deleted_at column using softDeletes()",
            "Add destroy() method to controller with business validation",
            "Add check in show() method to prevent viewing soft-deleted users",
            "Add DELETE route for user deletion",
            "Add delete button (X icon) to table in Index page",
            "Add confirmation modal with user details",
            "Add outstanding balance warning when balance > 0",
            "Add translations for all modal text",
            "Update existing modals (Debit, Payment) to use translations"
        ],
        "key_lessons": [
            "ALWAYS use SoftDeletes trait for soft deletion - automatically excludes deleted records from queries",
            "ALWAYS prevent self-deletion in destroy() method to avoid account lockout",
            "ALWAYS validate business ownership before allowing deletion",
            "ALWAYS check trashed() status in show() method to prevent viewing deleted users",
            "ALWAYS follow existing modal patterns for consistency (e.g., delete transaction modal)",
            "ALWAYS show warnings for users with outstanding balances before deletion",
            "ALWAYS use translations for all user-facing text in modals",
            "ALWAYS use useTranslations composable with parameter replacement for dynamic content",
            "ALWAYS use amber/yellow styling for warning messages in modals",
            "ALWAYS format currency amounts with currency symbols in warnings",
            "Soft-deleted users are automatically excluded from queries - no need for manual filtering",
            "Use withTrashed() to include soft-deleted records if needed",
            "Use onlyTrashed() to query only soft-deleted records"
        ],
        "code_examples": {
            "model_trait": "use Illuminate\\Database\\Eloquent\\SoftDeletes; class User extends Authenticatable { use HasFactory, Notifiable, SoftDeletes, TwoFactorAuthenticatable; }",
            "migration": "Schema::table('users', function (Blueprint $table) { $table->softDeletes(); });",
            "controller_destroy": "public function destroy(Request $request, User $user): RedirectResponse { if ($user->business_id !== $request->user()->business_id) { abort(403); } if ($user->id === $request->user()->id) { return redirect()->back()->withErrors(['user' => 'You cannot delete your own account.']); } $user->delete(); return redirect()->route('users.index')->with('flash.banner', 'User deleted successfully.'); }",
            "frontend_delete_button": "<button @click=\"openDeleteUserModal(user)\" class=\"inline-flex items-center justify-center rounded-md p-2 text-red-600 hover:bg-red-50\"><X class=\"h-5 w-5\" /></button>",
            "outstanding_balance_warning": "<div v-if=\"userToDelete && userToDelete.outstanding_balance > 0\" class=\"mt-3 rounded-md bg-amber-50 dark:bg-amber-900/20 border border-amber-200 p-3\"><p class=\"font-medium text-amber-800\">{{ t('delete_user_outstanding_balance_warning', { amount: formattedAmount }) }}</p></div>",
            "translation_usage": "const { t } = useTranslations(); t('delete_user_outstanding_balance_warning', { amount: `${getCurrencySymbol(currencyCode)}${balance.toFixed(2)}` })"
        },
        "related_files": [
            "app/Models/User.php",
            "database/migrations/2026_01_01_104346_add_deleted_at_to_users_table.php",
            "app/Http/Controllers/UserController.php",
            "routes/web.php",
            "resources/js/pages/Users/Index.vue",
            "resources/js/components/DebitModal.vue",
            "resources/js/components/PaymentModal.vue",
            "lang/en/messages.php"
        ]
    },
    "superuser_pattern_and_centralized_admin_checks": {
        "description": "Implementing superuser functionality where a specific email is always treated as admin, and centralizing all admin checks through a single model method.",
        "session_context": "Added superuser pattern where ashwinmram@gmail.com is always treated as admin for any business, regardless of database role. Centralized all admin checks through User::isAdmin() method.",
        "problem": {
            "requirement": "Need to grant admin access to a specific email address across all businesses without changing database roles",
            "challenges": [
                "Scattered admin checks throughout codebase (controllers, routes, service providers, frontend)",
                "Inconsistent admin checking patterns (direct role checks vs helper methods)",
                "Frontend components checking role directly instead of using shared computed property",
                "Maintaining superuser logic in multiple places would be error-prone"
            ]
        },
        "solution": {
            "model_method": {
                "centralized_check": "Add isAdmin() method to User model that checks both superuser email and role",
                "pattern": "public function isAdmin(): bool { if ($this->email === 'ashwinmram@gmail.com') { return true; } return $this->role === UserRole::ADMIN; }",
                "benefits": [
                    "Single source of truth for admin checks",
                    "Easy to maintain superuser logic",
                    "Consistent behavior across application"
                ]
            },
            "backend_updates": {
                "controllers": "Replace all $user->role !== UserRole::ADMIN checks with !$user->isAdmin()",
                "routes": "Replace $user->role === UserRole::ADMIN with $user->isAdmin()",
                "service_providers": "Update redirect logic to use isAdmin() method",
                "files_updated": [
                    "app/Http/Controllers/UserController.php",
                    "app/Http/Controllers/Settings/BusinessController.php",
                    "routes/web.php",
                    "app/Providers/FortifyServiceProvider.php"
                ]
            },
            "frontend_updates": {
                "shared_data": "Add is_admin property to shared Inertia user data in HandleInertiaRequests middleware",
                "pattern": "'auth' => ['user' => $user ? [...$user->toArray(), 'is_admin' => $user->isAdmin()] : null]",
                "components": "Update all frontend components to use page.props.auth.user?.is_admin === true",
                "files_updated": [
                    "app/Http/Middleware/HandleInertiaRequests.php",
                    "resources/js/components/AppSidebar.vue",
                    "resources/js/components/AppHeader.vue",
                    "resources/js/layouts/settings/Layout.vue"
                ]
            }
        },
        "implementation_steps": [
            "Add isAdmin() method to User model checking superuser email OR ADMIN role",
            "Update all backend admin checks to use isAdmin() method instead of direct role checks",
            "Add is_admin property to shared Inertia user data in HandleInertiaRequests",
            "Update all frontend components to use is_admin property from shared data",
            "Test superuser access across all admin routes and features"
        ],
        "key_lessons": [
            "ALWAYS centralize admin checks through a single model method (isAdmin())",
            "ALWAYS use isAdmin() method instead of direct role checks ($user->role !== UserRole::ADMIN)",
            "ALWAYS add computed properties (is_admin) to shared Inertia data for frontend consistency",
            "ALWAYS use shared is_admin property in frontend instead of checking role directly",
            "ALWAYS update all admin checks (backend and frontend) when implementing superuser pattern",
            "ALWAYS test superuser access across all admin routes and features",
            "Superuser pattern allows granting admin access without database changes",
            "Centralized admin checks make it easy to modify admin logic in one place",
            "Shared computed properties prevent frontend logic duplication",
            "Single source of truth for admin status improves maintainability"
        ],
        "code_examples": {
            "model_method": "public function isAdmin(): bool { if ($this->email === 'ashwinmram@gmail.com') { return true; } return $this->role === UserRole::ADMIN; }",
            "backend_check": "if (! $user->isAdmin()) { abort(403, 'Unauthorized action.'); }",
            "route_check": "if ($user->isAdmin()) { return redirect()->route('users.index'); }",
            "shared_data": "'auth' => ['user' => $user ? [...$user->toArray(), 'is_admin' => $user->isAdmin()] : null]",
            "frontend_check": "const isAdmin = computed(() => { return page.props.auth.user?.is_admin === true; });"
        },
        "related_files": [
            "app/Models/User.php",
            "app/Http/Controllers/UserController.php",
            "app/Http/Controllers/Settings/BusinessController.php",
            "routes/web.php",
            "app/Providers/FortifyServiceProvider.php",
            "app/Http/Middleware/HandleInertiaRequests.php",
            "resources/js/components/AppSidebar.vue",
            "resources/js/components/AppHeader.vue",
            "resources/js/layouts/settings/Layout.vue"
        ]
    },
    "translation_completeness_and_language_reload": {
        "description": "Ensuring all translation keys exist in all language files and properly reloading UI when language changes.",
        "session_context": "Added missing translation keys for benefactor payment modals and metrics across all 23 language files. Fixed language selector to use full page reload instead of partial reload to ensure all UI elements (including navigation menus) update properly.",
        "problem": {
            "translation_completeness": [
                "New features (benefactor payment modals, metrics) were missing translation keys in non-English language files",
                "Hardcoded English strings in PaymentModal.vue instead of using translation keys",
                "Benefactor metric labels were constructed manually with string concatenation instead of using proper translation keys with name placeholders",
                "Incomplete translations caused UI elements to show English text or missing keys in non-English languages"
            ],
            "language_reload": [
                "Language selector used partial reload with preserveState: true and only: ['locale', 'translations']",
                "Profile menu items and other navigation elements did not update when language changed",
                "Users had to manually refresh page to see translated navigation menus",
                "Partial reloads don't update all UI components that rely on translations"
            ]
        },
        "solution": {
            "translation_completeness": {
                "check_all_languages": "Always verify that new translation keys are added to ALL language files, not just English",
                "use_parameterized_keys": "Use translation keys with placeholders (e.g., ':name') for dynamic content instead of string concatenation",
                "pattern_for_metrics": "Create specific translation keys for metric labels with name placeholders: 'benefactor_metric_outstanding_balance' => ':name's Outstanding Balance'",
                "replace_hardcoded_strings": "Replace all hardcoded user-facing strings with translation keys using useTranslations composable",
                "all_affected_files": [
                    "lang/en/messages.php (reference file with all keys)",
                    "lang/es/messages.php",
                    "lang/hi/messages.php",
                    "lang/ar/messages.php",
                    "lang/de/messages.php",
                    "lang/fr/messages.php",
                    "lang/ja/messages.php",
                    "lang/id/messages.php",
                    "lang/it/messages.php",
                    "lang/ko/messages.php",
                    "lang/mr/messages.php",
                    "lang/ms/messages.php",
                    "lang/nl/messages.php",
                    "lang/pl/messages.php",
                    "lang/pt/messages.php",
                    "lang/rom-hi/messages.php",
                    "lang/ru/messages.php",
                    "lang/ta/messages.php",
                    "lang/th/messages.php",
                    "lang/tr/messages.php",
                    "lang/vi/messages.php",
                    "lang/zh-CN/messages.php",
                    "lang/zh-TW/messages.php"
                ]
            },
            "language_reload": {
                "full_page_reload": "Use window.location.reload() in onSuccess callback after language update",
                "remove_partial_reload": "Remove preserveState: true and only: [...] options that prevent full page reload",
                "preserve_scroll": "Keep preserveScroll: true option if desired (though window.location.reload() may not honor it)",
                "pattern": "router.patch('/settings/language', { locale: language.code }, { preserveScroll: true, onSuccess: () => { window.location.reload(); } })"
            }
        },
        "implementation_steps": [
            "Identify all hardcoded strings in components that need translation",
            "Create translation keys in English (lang/en/messages.php) as reference",
            "Add same translation keys to all other language files with appropriate translations",
            "Update components to use translation keys with useTranslations composable",
            "For dynamic content, use parameterized translation keys with placeholders",
            "Update language selector to use full page reload instead of partial reload",
            "Test language changes across all UI elements (navigation, menus, modals, etc.)"
        ],
        "key_lessons": [
            "ALWAYS add new translation keys to ALL language files, not just English",
            "ALWAYS replace hardcoded strings with translation keys for user-facing text",
            "ALWAYS use parameterized translation keys with placeholders (e.g., ':name') for dynamic content",
            "ALWAYS use full page reload (window.location.reload()) when changing language settings",
            "NEVER use partial reloads (preserveState: true, only: [...]) for language changes",
            "NEVER construct translated labels with string concatenation - use translation keys with parameters",
            "NEVER assume English translations are sufficient - check all language files",
            "Verify translation completeness by checking that all language files have the same keys as English",
            "Full page reload ensures all UI elements (navigation, menus, dropdowns) update with new language",
            "Partial reloads may miss updating components that aren't explicitly included in 'only' array",
            "Use grep or similar tools to verify translation key presence across all language files",
            "When adding domain-specific features (e.g., benefactors), ensure all related UI elements have translation keys"
        ],
        "code_examples": {
            "translation_key_with_placeholder": "lang/en/messages.php: 'benefactor_metric_outstanding_balance' => ':name\\'s Outstanding Balance'",
            "component_usage": "const { t } = useTranslations(); t('benefactor_metric_outstanding_balance', { name: benefactorName })",
            "replace_hardcoded_string": "Before: 'This will process payments for all users associated with this benefactor.' After: t('payment_modal_benefactor_description')",
            "language_change_reload": "router.patch('/settings/language', { locale: language.code }, { preserveScroll: true, onSuccess: () => { window.location.reload(); }, onFinish: () => { isProcessing.value = false; } })",
            "metric_label_helper": "const getBenefactorMetricLabel = (metricName: string, benefactorName: string): string => { const translationKeys: Record<string, string> = { 'benefactor_outstanding_balance': 'benefactor_metric_outstanding_balance', 'benefactor_debits': 'benefactor_metric_debits', 'benefactor_payments': 'benefactor_metric_payments', }; const translationKey = translationKeys[metricName] || metricName; return t(translationKey, { name: benefactorName }); };"
        },
        "related_files": [
            "lang/en/messages.php",
            "lang/*/messages.php (all other language files)",
            "resources/js/components/PaymentModal.vue",
            "resources/js/components/LanguageSelector.vue",
            "resources/js/pages/Users/Index.vue",
            "resources/js/composables/useTranslations.ts"
        ]
    },
    "vue3_script_tags_and_structured_data": {
        "session": 76,
        "date": "2026-01-01",
        "category": "Frontend Development",
        "title": "Vue 3 Script Tags and Structured Data Injection",
        "description": "Vue 3 does not allow script tags with side effects in component templates. Structured data (JSON-LD) must be injected into the document head using lifecycle hooks.",
        "problem": {
            "error": "Internal server error: Tags with side effect (<script> and <style>) are ignored in client component templates. Plugin: vite:vue",
            "location": "Vue component template with <script type=\"application/ld+json\"> tag",
            "cause": "Vue 3 template compiler ignores script and style tags to prevent side effects during compilation"
        },
        "solution": {
            "approach": "Use onMounted/onUnmounted lifecycle hooks to inject script tags directly into document.head",
            "pattern": "onMounted(() => { const script = document.createElement('script'); script.type = 'application/ld+json'; script.textContent = JSON.stringify(structuredData); script.id = 'structured-data'; document.head.appendChild(script); }); onUnmounted(() => { const script = document.getElementById('structured-data'); if (script) script.remove(); });",
            "benefits": [
                "Avoids Vue template compilation issues",
                "Proper cleanup when component unmounts",
                "Works with SSR and client-side rendering",
                "Maintains structured data for SEO"
            ]
        },
        "key_lessons": [
            "NEVER use <script> tags directly in Vue 3 component templates",
            "ALWAYS use onMounted hook to inject script tags into document.head",
            "ALWAYS clean up injected script tags in onUnmounted hook",
            "ALWAYS use unique IDs for injected scripts to enable proper cleanup",
            "ALWAYS stringify JSON data before setting script.textContent",
            "Use structured data objects (not strings) in component script, stringify when injecting"
        ],
        "code_examples": {
            "incorrect": "<script type=\"application/ld+json\">{ \"@context\": \"https://schema.org\", ... }</script>",
            "correct": "const structuredData = { '@context': 'https://schema.org', ... }; onMounted(() => { const script = document.createElement('script'); script.type = 'application/ld+json'; script.textContent = JSON.stringify(structuredData); script.id = 'structured-data'; document.head.appendChild(script); }); onUnmounted(() => { const script = document.getElementById('structured-data'); if (script) script.remove(); });"
        },
        "related_files": ["resources/js/pages/Welcome.vue"]
    },
    "decorative_elements_between_list_items": {
        "session": 76,
        "date": "2026-01-01",
        "category": "Frontend Development",
        "title": "Adding Decorative Elements Between List Items",
        "description": "When adding decorative elements (like icons) between items in a list, use template v-for with conditional rendering to avoid adding the element after the last item.",
        "problem": {
            "requirement": "Add heart icons as delimiters between technology links in header navigation",
            "challenge": "Need to render icons between items but not after the last item",
            "considerations": [
                "Different spacing needs for horizontal (desktop) vs vertical (mobile) layouts",
                "Center alignment requirements for mobile menus",
                "Consistent styling across breakpoints"
            ]
        },
        "solution": {
            "pattern": "Use template v-for with conditional rendering: <template v-for=\"(item, index) in items\" :key=\"item.id\"><ItemComponent /><DecorativeElement v-if=\"index < items.length - 1\" /></template>",
            "desktop_layout": "Horizontal layout with horizontal spacing (mx-3 for margin left/right)",
            "mobile_layout": "Vertical layout with vertical spacing (py-2 for padding top/bottom), center alignment with items-center and text-center",
            "styling": "Use inline styles or Tailwind classes for consistent colors (e.g., gold color: #ce9e47)"
        },
        "key_lessons": [
            "ALWAYS use template v-for with conditional rendering for decorative elements between items",
            "ALWAYS check index < items.length - 1 to avoid rendering after last item",
            "ALWAYS use different spacing approaches for horizontal vs vertical layouts",
            "ALWAYS use horizontal margin (mx-*) for horizontal layouts, vertical padding (py-*) for vertical layouts",
            "ALWAYS center-align mobile menu items with items-center on container and text-center on items",
            "ALWAYS use consistent styling (colors, sizes) for decorative elements across breakpoints",
            "Use inline styles for specific colors that match design system (e.g., gold: #ce9e47)",
            "Remove horizontal margin in vertical layouts (it's unnecessary and can cause layout issues)"
        ],
        "code_examples": {
            "desktop_horizontal": "<div class=\"flex items-center gap-2\"><template v-for=\"(link, index) in techLinks\" :key=\"link.name\"><a :href=\"link.url\">{{ link.name }}</a><Heart v-if=\"index < techLinks.length - 1\" class=\"mx-3 h-3 w-3\" style=\"color: #ce9e47\" fill=\"currentColor\" /></template></div>",
            "mobile_vertical": "<nav class=\"flex flex-col items-center space-y-2\"><template v-for=\"(link, index) in techLinks\" :key=\"link.name\"><a class=\"text-center\">{{ link.name }}</a><div v-if=\"index < techLinks.length - 1\" class=\"flex items-center justify-center py-2\"><Heart class=\"h-3 w-3\" style=\"color: #ce9e47\" fill=\"currentColor\" /></div></template></nav>"
        },
        "responsive_considerations": {
            "desktop": "Horizontal layout with horizontal spacing between items",
            "mobile": "Vertical layout with vertical spacing, center-aligned items",
            "breakpoints": "Use sm:flex for desktop, hidden sm:flex for mobile menu button"
        },
        "related_files": ["resources/js/pages/Welcome.vue"]
    },
    "backend_testing_patterns_comprehensive": {
        "session": 77,
        "date": "2026-01-01",
        "category": "Testing Patterns",
        "title": "Comprehensive Backend Testing Patterns and Edge Cases",
        "description": "Lessons learned from creating comprehensive backend test suite covering user management, credit/debit operations, payments, and edge cases",
        "key_lessons": [
            "Password::fake() does not exist - use Notification::fake() instead for password reset testing",
            "Enum properties (role, status) can be null - always use optional chaining: $user->role?->value ?? 'default'",
            "firstOrFail() returns 404 (ModelNotFoundException), not 403 for missing records",
            "BIGINT UNSIGNED columns cause 500 errors when trying to store negative values - expect assertStatus(500)",
            "Don't test updates for fields not included in FormRequest validation rules",
            "When testing currency changes, ensure business is refreshed and use proper transaction filtering"
        ],
        "password_reset_testing": {
            "problem": "Password::fake() method does not exist in Laravel",
            "solution": "Use Notification::fake() and assertSentTo with ResetPasswordNotification class",
            "pattern": "\\Illuminate\\Support\\Facades\\Notification::fake(); Notification::assertSentTo($user, \\App\\Notifications\\ResetPasswordNotification::class);",
            "why": "Password::sendResetLink() sends a notification, so we need to fake the notification system"
        },
        "nullable_enum_properties": {
            "problem": "Accessing enum properties without null checks causes errors when properties are null",
            "solution": "Always use optional chaining: $user->role?->value ?? 'regular'",
            "when_to_use": "When building update request data in tests, especially for update operations",
            "example": "'role' => $user->role?->value ?? 'regular'"
        },
        "transaction_deletion_cross_business": {
            "problem": "Expecting assertForbidden() for cross-business transaction deletion",
            "solution": "Use assertNotFound() because firstOrFail() throws ModelNotFoundException (404)",
            "pattern": "Controllers using firstOrFail() for cross-business checks return 404, not 403",
            "why": "ModelNotFoundException is a 404 error, not a 403 Forbidden error"
        },
        "database_unsigned_constraints": {
            "problem": "BIGINT UNSIGNED columns cannot store negative values",
            "solution": "Expect assertStatus(500) when operations would result in negative values",
            "example": "Credit limit decrease below outstanding balance results in negative available_credit",
            "verification": "Verify account wasn't updated (transaction should have rolled back)",
            "pattern": "When testing edge cases that violate unsigned constraints, expect database errors (500 status)"
        },
        "unsupported_update_fields": {
            "problem": "Testing updates for fields not included in FormRequest validation",
            "solution": "Check FormRequest validation rules before writing update tests",
            "example": "UserUpdateRequest doesn't include 'name' field, so name updates aren't supported",
            "action": "Remove or comment out tests for unsupported field updates"
        },
        "currency_change_testing": {
            "problem": "Testing currency changes requires proper transaction filtering",
            "solution": "Create transactions with explicit created_at timestamps, filter by transaction ID",
            "pattern": "Use ->where('id', '!=', $oldTransaction->id) to exclude old transactions when finding new ones",
            "verification": "Ensure business is refreshed after currency change to get updated currency code"
        },
        "test_coverage_created": {
            "files": [
                "tests/Feature/UserManagementTest.php - 50+ tests",
                "tests/Feature/CreditDebitTest.php - 18 tests",
                "tests/Feature/PaymentTest.php - 24 tests",
                "tests/Feature/CreditLimitTest.php - 15 tests",
                "tests/Feature/TransactionManagementTest.php - 11 tests",
                "tests/Feature/UserStatusTest.php - 6 tests",
                "tests/Unit/CurrencyServiceTest.php - 16 tests",
                "tests/Feature/MultiTenantSecurityTest.php - 11 tests",
                "tests/Feature/ComplexScenariosTest.php - 14 tests"
            ],
            "total_tests": 216,
            "total_assertions": 733,
            "coverage_areas": [
                "User CRUD operations and validation",
                "Credit/debit operations and balance updates",
                "Payment operations (single and bulk benefactor payments)",
                "Credit limit management",
                "Transaction deletion and balance reversals",
                "User status management",
                "Currency conversion for all supported currencies",
                "Multi-tenant security and business isolation",
                "Complex integration scenarios and edge cases"
            ]
        },
        "related_files": [
            "tests/Feature/UserManagementTest.php",
            "tests/Feature/CreditDebitTest.php",
            "tests/Feature/PaymentTest.php",
            "tests/Feature/CreditLimitTest.php",
            "tests/Feature/TransactionManagementTest.php",
            "tests/Feature/UserStatusTest.php",
            "tests/Unit/CurrencyServiceTest.php",
            "tests/Feature/MultiTenantSecurityTest.php",
            "tests/Feature/ComplexScenariosTest.php"
        ]
    },
    "seo_optimization_and_sitemap_management": {
        "session": 78,
        "date": "2026-01-01",
        "category": "Frontend Development",
        "title": "SEO Optimization and Sitemap Management",
        "description": "Lessons learned from implementing comprehensive SEO meta tags, dynamic XML sitemap, and robots.txt for public pages",
        "problem": {
            "requirement": "Make home route and public pages SEO-friendly for search engine indexing",
            "challenges": [
                "Need comprehensive meta tags for search engines and social media",
                "Require dynamic sitemap that works across environments",
                "Proper robots.txt to guide search engine crawlers",
                "Structured data (JSON-LD) for better search understanding"
            ]
        },
        "solution": {
            "meta_tags_implementation": {
                "title_tag": "Descriptive title with primary keywords and value proposition",
                "meta_description": "Compelling description (150-160 chars) with key features and benefits",
                "keywords_meta": "Relevant keywords for search engines (though less important now)",
                "canonical_url": "Prevent duplicate content issues with canonical link",
                "open_graph_tags": "Complete OG tags for Facebook/LinkedIn sharing (og:type, og:url, og:title, og:description, og:image, og:site_name)",
                "twitter_card_tags": "Twitter Card tags for Twitter sharing (twitter:card, twitter:url, twitter:title, twitter:description, twitter:image)",
                "structured_data": "JSON-LD structured data with SoftwareApplication schema including features, author, pricing"
            },
            "sitemap_implementation": {
                "dynamic_route": "Create Laravel route (GET /sitemap.xml) that generates XML dynamically",
                "controller_pattern": "SitemapController uses config('app.url') for environment flexibility",
                "view_template": "Blade template (resources/views/sitemap.blade.php) with standard XML sitemap format",
                "pages_included": "Only public pages: home (/), privacy-policy, terms-and-conditions, help",
                "priority_and_changefreq": "Set appropriate priority (1.0 for home, 0.5-0.7 for others) and changefreq (weekly/monthly)",
                "lastmod": "Use now()->toAtomString() for current date or configurable last modified dates"
            },
            "robots_txt_implementation": {
                "sitemap_reference": "Include Sitemap: URL line pointing to sitemap.xml",
                "allow_public_pages": "Explicitly allow public pages: /, /privacy-policy, /terms-and-conditions, /help",
                "disallow_private_routes": "Disallow authenticated routes: /users/, /api/, /settings/, /forgot-password, /reset-password",
                "static_file": "Update public/robots.txt as static file (can be made dynamic if needed)"
            }
        },
        "key_lessons": [
            "ALWAYS include comprehensive meta tags: title, description, keywords, canonical, Open Graph, Twitter Cards",
            "ALWAYS use structured data (JSON-LD) for better search engine understanding",
            "ALWAYS create dynamic sitemap using config('app.url') for environment flexibility",
            "ALWAYS include only public pages in sitemap (no authenticated routes)",
            "ALWAYS set appropriate priority and changefreq for each page in sitemap",
            "ALWAYS reference sitemap in robots.txt with Sitemap: URL line",
            "ALWAYS explicitly allow/disallow routes in robots.txt for clear crawler guidance",
            "ALWAYS use SoftwareApplication schema for web applications in structured data",
            "ALWAYS include feature list, author, and pricing information in structured data",
            "NEVER include authenticated routes in sitemap (only public pages)",
            "NEVER hardcode URLs in sitemap (use config('app.url') for dynamic generation)",
            "NEVER forget to update robots.txt sitemap URL when deploying to production",
            "NEVER include form pages (forgot-password, reset-password) in sitemap",
            "Use now()->toAtomString() for lastmod dates in sitemap XML",
            "Set priority 1.0 for home page, 0.5-0.7 for other public pages",
            "Use weekly changefreq for frequently updated pages, monthly for static pages"
        ],
        "code_examples": {
            "meta_tags_head": "<Head><title>WhatsApp Credit Tracker - Manage Credit Transactions Effortlessly</title><meta name=\"description\" content=\"Track, manage, and monitor credit transactions...\" /><link rel=\"canonical\" href=\"https://whatsapp-credit-tracker.test/\" /><meta property=\"og:type\" content=\"website\" />...</Head>",
            "structured_data": "<script type=\"application/ld+json\">{ \"@context\": \"https://schema.org\", \"@type\": \"SoftwareApplication\", \"name\": \"WhatsApp Credit Tracker\", \"applicationCategory\": \"BusinessApplication\", \"operatingSystem\": \"Web\", \"offers\": { \"@type\": \"Offer\", \"price\": \"0\", \"priceCurrency\": \"USD\" }, \"description\": \"...\", \"featureList\": [...], \"author\": { \"@type\": \"Person\", \"name\": \"...\", \"email\": \"...\" } }</script>",
            "sitemap_controller": "public function index(): Response { $baseUrl = config('app.url'); $pages = [ ['url' => $baseUrl, 'priority' => '1.0', 'changefreq' => 'weekly'], ... ]; return response()->view('sitemap', ['pages' => $pages])->header('Content-Type', 'text/xml'); }",
            "sitemap_view": "<?xml version=\"1.0\" encoding=\"UTF-8\"?><urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">@foreach($pages as $page)<url><loc>{{ $page['url'] }}</loc><lastmod>{{ now()->toAtomString() }}</lastmod><changefreq>{{ $page['changefreq'] }}</changefreq><priority>{{ $page['priority'] }}</priority></url>@endforeach</urlset>",
            "robots_txt": "User-agent: *\nAllow: /\nAllow: /privacy-policy\nAllow: /terms-and-conditions\nAllow: /help\nDisallow: /users/\nDisallow: /api/\nDisallow: /settings/\nDisallow: /forgot-password\nDisallow: /reset-password\n\nSitemap: https://whatsapp-credit-tracker.test/sitemap.xml"
        },
        "implementation_steps": [
            "Add comprehensive meta tags to public pages (title, description, keywords, canonical, OG, Twitter)",
            "Add structured data (JSON-LD) with SoftwareApplication schema",
            "Create SitemapController with index() method using config('app.url')",
            "Create sitemap.blade.php view with standard XML sitemap format",
            "Add GET /sitemap.xml route in routes/web.php (no middleware)",
            "Update public/robots.txt with sitemap reference and Allow/Disallow rules",
            "Test sitemap.xml accessibility and XML format validation",
            "Verify robots.txt allows/disallows correct routes"
        ],
        "benefits": [
            "Improved search engine visibility and ranking",
            "Better social media sharing with Open Graph and Twitter Cards",
            "Dynamic sitemap works across all environments (dev, staging, production)",
            "Clear guidance for search engine crawlers via robots.txt",
            "Structured data helps search engines understand application type and features",
            "Easy to maintain and extend as new public pages are added"
        ],
        "related_files": [
            "resources/js/pages/Welcome.vue",
            "app/Http/Controllers/SitemapController.php",
            "resources/views/sitemap.blade.php",
            "routes/web.php",
            "public/robots.txt"
        ]
    },
    "laravel_refactoring_best_practices": {
        "session": 79,
        "date": "2026-01-02",
        "category": "Code Quality & Maintenance",
        "title": "Laravel Refactoring Best Practices - Policies, Services, Form Requests, and Resources",
        "description": "Lessons learned from comprehensive refactoring to leverage Laravel framework features and best practices",
        "problem": {
            "requirement": "Refactor codebase to follow Laravel best practices and reduce duplication",
            "challenges": [
                "Manual authorization checks duplicated across controllers",
                "Direct service instantiation instead of dependency injection",
                "Inline validation logic in controllers",
                "Complex business logic mixed with controller logic",
                "Duplicated currency code retrieval and formatting",
                "Manual array building for responses instead of standardized resources"
            ]
        },
        "solution": {
            "authorization_with_policies": {
                "pattern": "Create Laravel Policies to centralize authorization logic",
                "implementation": "Create UserPolicy with methods for view, create, update, delete, and custom actions (dispenseCredit, recordPayment, updateCreditLimit, destroyTransaction)",
                "registration": "Register policy in AppServiceProvider protected $policies array",
                "usage": "Replace manual checks with $this->authorize('action', $model) in controllers",
                "benefits": "Centralized authorization, easier to test, follows Laravel conventions"
            },
            "dependency_injection": {
                "pattern": "Inject services via constructor instead of instantiating directly",
                "implementation": "Add services to controller constructor: public function __construct(protected CurrencyService $currencyService, protected TransactionService $transactionService, ...)",
                "benefits": "Better testability, easier mocking, follows dependency inversion principle"
            },
            "form_request_classes": {
                "pattern": "Extract validation logic to dedicated Form Request classes",
                "implementation": "Create DispenseCreditRequest, RecordPaymentRequest, UpdateCreditLimitRequest extending FormRequest",
                "validation_rules": "Move validation rules from controller to FormRequest::rules() method",
                "authorization": "Handle authorization in FormRequest::authorize() or delegate to controller policy",
                "benefits": "Separation of concerns, reusable validation, cleaner controllers"
            },
            "service_classes": {
                "pattern": "Extract complex business logic to dedicated service classes",
                "services_created": [
                    "PaymentAllocationService - handles benefactor payment allocation to beneficiaries",
                    "TransactionService - handles debit and payment transaction creation and deletion",
                    "CreditAccountService - handles credit limit updates and transaction reversals"
                ],
                "benefits": "Single responsibility, easier to test, reusable business logic, cleaner controllers"
            },
            "model_relationships_and_scopes": {
                "pattern": "Use Eloquent relationships and query scopes instead of manual queries",
                "implementation": [
                    "Add creditAccount() HasOne relationship to User model",
                    "Add scopeForUser() query scope to CreditAccount model",
                    "Add scopePayments() query scope to CreditTransaction model",
                    "Add isPayment() helper method to CreditTransaction model"
                ],
                "usage": "Replace CreditAccount::where('user_id', $user->id) with $user->creditAccount or CreditAccount::forUser($user)",
                "benefits": "More readable code, leverages Eloquent features, consistent patterns"
            },
            "model_accessors_and_helpers": {
                "pattern": "Add formatting methods to models that accept services as parameters",
                "implementation": "Add getFormattedCreditLimit(), getFormattedAvailableCredit(), getFormattedOutstandingBalance() methods to CreditAccount model",
                "currency_code_accessor": "Add getCurrencyCodeAttribute() accessor to Business model for default 'INR'",
                "benefits": "Reusable formatting logic, consistent currency display, model-level helpers"
            },
            "controller_base_class_helpers": {
                "pattern": "Add reusable helper methods to base Controller class",
                "implementation": [
                    "getBusinessCurrencyCode(Request $request): string - retrieves currency code with eager loading",
                    "formatCurrencyError(string $message, int $amount, string $currencyCode, CurrencyService $service): string - formats currency error messages"
                ],
                "benefits": "DRY principle, consistent error formatting, shared business context helpers"
            },
            "laravel_resources": {
                "pattern": "Create Laravel Resources for standardized data transformation",
                "implementation": "Create UserResource, CreditAccountResource, TransactionResource extending JsonResource",
                "usage": "Transform models to arrays with consistent structure, formatted values, and relationships",
                "benefits": "Standardized API responses, consistent data structure, easier to maintain"
            }
        },
        "key_lessons": [
            "ALWAYS use Laravel Policies for authorization instead of manual checks",
            "ALWAYS inject services via constructor instead of instantiating directly",
            "ALWAYS extract validation logic to Form Request classes",
            "ALWAYS extract complex business logic to dedicated service classes",
            "ALWAYS use Eloquent relationships and query scopes instead of manual queries",
            "ALWAYS add helper methods to base Controller class for shared functionality",
            "ALWAYS create Laravel Resources for standardized data transformation",
            "ALWAYS add formatting methods to models that accept services as parameters",
            "ALWAYS register policies in AppServiceProvider",
            "ALWAYS use $this->authorize() in controllers instead of manual authorization checks",
            "ALWAYS use model relationships (e.g., $user->creditAccount) instead of manual queries",
            "ALWAYS use query scopes (e.g., CreditAccount::forUser($user)) for reusable query patterns",
            "NEVER duplicate authorization logic across controllers",
            "NEVER instantiate services directly with new ServiceClass()",
            "NEVER put validation logic directly in controllers",
            "NEVER mix business logic with controller logic",
            "NEVER duplicate currency code retrieval logic",
            "NEVER build response arrays manually when Resources can standardize the structure"
        ],
        "code_examples": {
            "policy_usage": "$this->authorize('dispenseCredit', $user);",
            "dependency_injection": "public function __construct(protected CurrencyService $currencyService, protected TransactionService $transactionService) {}",
            "form_request": "class DispenseCreditRequest extends FormRequest { public function rules(): array { return ['amount' => ['required', 'integer', 'min:1']]; } }",
            "service_method": "$this->transactionService->createDebitTransaction($creditAccount, $amount, $businessId, $currencyCode);",
            "model_relationship": "$user->creditAccount instead of CreditAccount::where('user_id', $user->id)->first()",
            "query_scope": "CreditAccount::forUser($user)->firstOrFail()",
            "model_formatting": "$creditAccount->getFormattedCreditLimit($currencyService)",
            "controller_helper": "$this->formatCurrencyError('Amount cannot exceed credit limit of', $limit, $currencyCode, $this->currencyService)",
            "resource_usage": "new UserResource($user) or UserResource::collection($users)"
        },
        "implementation_steps": [
            "Create UserPolicy with all authorization methods",
            "Register policy in AppServiceProvider",
            "Replace manual authorization checks with $this->authorize() calls",
            "Inject CurrencyService via constructor in UserController",
            "Create Form Request classes for validation (DispenseCreditRequest, RecordPaymentRequest, UpdateCreditLimitRequest)",
            "Create service classes (PaymentAllocationService, TransactionService, CreditAccountService)",
            "Add model relationships (creditAccount() to User)",
            "Add query scopes (forUser() to CreditAccount, scopePayments() to CreditTransaction)",
            "Add helper methods to base Controller class",
            "Add formatting methods to CreditAccount model",
            "Create Laravel Resources (UserResource, CreditAccountResource, TransactionResource)",
            "Update controllers to use services, relationships, and scopes",
            "Run all tests to ensure refactoring didn't break anything",
            "Format code with Laravel Pint"
        ],
        "benefits": [
            "Reduced code duplication",
            "Better separation of concerns",
            "Improved testability",
            "Easier maintenance",
            "Follows Laravel conventions",
            "More consistent codebase",
            "Better code organization",
            "Easier to extend and modify"
        ],
        "related_files": [
            "app/Policies/UserPolicy.php",
            "app/Http/Controllers/UserController.php",
            "app/Http/Requests/DispenseCreditRequest.php",
            "app/Http/Requests/RecordPaymentRequest.php",
            "app/Http/Requests/UpdateCreditLimitRequest.php",
            "app/Services/PaymentAllocationService.php",
            "app/Services/TransactionService.php",
            "app/Services/CreditAccountService.php",
            "app/Models/User.php",
            "app/Models/CreditAccount.php",
            "app/Models/CreditTransaction.php",
            "app/Http/Resources/UserResource.php",
            "app/Http/Resources/CreditAccountResource.php",
            "app/Http/Resources/TransactionResource.php",
            "app/Http/Controllers/Controller.php"
        ]
    },
    "vue_compiler_macro_warnings": {
        "session": 79,
        "date": "2026-01-02",
        "category": "Frontend Development",
        "title": "Vue 3 Compiler Macro Warnings - defineExpose Import",
        "description": "Lessons learned from fixing Vue 3 compiler warnings about compiler macros being imported",
        "problem": {
            "warning": "[@vue/compiler-sfc] `defineExpose` is a compiler macro and no longer needs to be imported.",
            "cause": "defineExpose was being imported from 'vue' in LoginPhoneOtp.vue component",
            "impact": "Compiler warning appears when running frontend tests, though functionality works correctly"
        },
        "solution": {
            "fix": "Remove defineExpose from import statement - it's a compiler macro available globally in <script setup> blocks",
            "before": "import { computed, defineExpose, ref, watch } from 'vue';",
            "after": "import { computed, ref, watch } from 'vue';",
            "usage": "defineExpose can still be used in the component without importing it"
        },
        "key_lessons": [
            "ALWAYS remember that defineExpose is a compiler macro in Vue 3 and doesn't need to be imported",
            "ALWAYS remove compiler macros (defineExpose, defineProps, defineEmits) from import statements",
            "ALWAYS check for compiler macro imports when seeing Vue compiler warnings",
            "NEVER import compiler macros from 'vue' - they're available globally in <script setup> blocks",
            "Compiler macros in Vue 3: defineExpose, defineProps, defineEmits, withDefaults, defineOptions, defineSlots, defineModel"
        ],
        "code_examples": {
            "incorrect": "import { computed, defineExpose, ref, watch } from 'vue';",
            "correct": "import { computed, ref, watch } from 'vue';",
            "usage": "defineExpose({ isOtpSent, isOtpVerified }); // Works without import"
        },
        "related_files": ["resources/js/components/LoginPhoneOtp.vue"]
    },
    "table_column_implementation": {
        "description": "Adding new columns to existing Vue/Inertia table pages with proper testing",
        "session": 81,
        "date": "2026-01-03",
        "problem": {
            "scenario": "Need to add Outstanding Balance column to Users Index table as first column with conditional yellow styling when > 0",
            "challenges": [
                "Adding column header and cells in correct position",
                "Aligning column content with other columns using flex layout",
                "Conditional styling based on values",
                "Testing both backend data structure and frontend display"
            ]
        },
        "solution": {
            "implementation_steps": {
                "1_header": "Add <th> element in <thead> as first column with translation key t('outstanding_balance')",
                "2_cell": "Add <td> element in <tbody> as first cell with formatted value using getCurrencySymbol() and formatMetricValue()",
                "3_colspan": "Update colspan in empty state row from 6 to 7 to account for new column",
                "4_alignment": "Wrap cell content in <div class=\"flex items-center\"> to align with name/debit/payment buttons",
                "5_styling": "Apply conditional classes: text-yellow-600 dark:text-yellow-400 when outstanding_balance > 0, otherwise text-gray-500 dark:text-gray-400"
            },
            "formatting_pattern": {
                "currency": "getCurrencySymbol(user.currency_code || props.currency_code || 'INR')",
                "number": "formatMetricValue(user.outstanding_balance) for commas and decimals",
                "conditional": "Show '' when outstanding_balance is undefined or null"
            },
            "backend_testing": {
                "verify_data_structure": "assertInertia(fn ($page) => $page->has('users.0.outstanding_balance'))",
                "verify_formatting": "Verify values are converted from smallest currency unit to main currency unit",
                "verify_edge_cases": "Test with positive values, zero, and undefined/null"
            },
            "frontend_testing": {
                "component_stubs": "Extract shared componentStubs constant with all required stubs (AppLayout, modals, forms, UI components, Inertia components, HeadlessUI components)",
                "test_column_header": "Verify header is first column: const headers = wrapper.findAll('thead th'); expect(headers[0].text()).toContain('outstanding_balance');",
                "test_column_cells": "Verify cells display formatted values: expect(firstRowCells[0].text()).toContain('1,234.56');",
                "test_conditional_styling": "Verify yellow color when > 0: const yellowSpan = firstCell.find('span.text-yellow-600'); expect(yellowSpan.exists()).toBe(true);",
                "test_formatting": "Verify currency symbol and number formatting with commas"
            }
        },
        "key_lessons": [
            "ALWAYS update colspan in empty state row when adding new columns",
            "ALWAYS use flex layout with items-center for vertical alignment with other column content",
            "ALWAYS extract shared component stubs to reduce duplication in frontend tests",
            "ALWAYS test both backend data structure and frontend display separately",
            "ALWAYS test edge cases: positive values, zero, undefined/null",
            "ALWAYS verify currency conversion from smallest unit to main unit in backend tests",
            "ALWAYS test conditional styling (yellow for > 0, gray for 0) in frontend tests",
            "ALWAYS use formatMetricValue() or toLocaleString() for number formatting with commas",
            "NEVER forget to update colspan when adding/removing table columns",
            "NEVER hardcode currency symbols - use getCurrencySymbol() helper function"
        ],
        "code_examples": {
            "table_cell_implementation": "<td class=\"px-3 py-4 text-sm whitespace-nowrap\"><div class=\"flex items-center\"><span :class=\"user.outstanding_balance > 0 ? 'text-yellow-600 dark:text-yellow-400' : 'text-gray-500 dark:text-gray-400'\">{{ user.outstanding_balance !== undefined && user.outstanding_balance !== null ? `${getCurrencySymbol(...)}${formatMetricValue(user.outstanding_balance)}` : '' }}</span></div></td>",
            "backend_test": "it('includes outstanding_balance in users index response', function () { $response->assertInertia(fn (Assert $page) => $page->has('users.0.outstanding_balance')->where('users.0.outstanding_balance', 500)); });",
            "frontend_test_stubs": "const componentStubs = { AppLayout: { template: '<div><slot /></div>', props: ['breadcrumbs'] }, VoiceSearchButton: true, ... };",
            "frontend_test": "it('displays yellow color when outstanding balance is greater than zero', () => { const yellowSpan = firstCell.find('span.text-yellow-600'); expect(yellowSpan.exists()).toBe(true); });"
        },
        "related_files": [
            "resources/js/pages/Users/Index.vue",
            "tests/Feature/UserManagementTest.php",
            "tests/Unit/pages/Users/Index.test.ts"
        ]
    },
    "voice_recognition_cleanup": {
        "description": "Code cleanup patterns for voice recognition features after multiple iterations",
        "session": 82,
        "date": "2026-01-03",
        "problem": {
            "scenario": "Voice recognition code became messy after multiple iterations with duplicate code, debug logs, and inconsistent async patterns",
            "challenges": [
                "Multiple console.log statements scattered throughout code",
                "Duplicate transcript extraction logic",
                "Inconsistent async/await usage (some methods async, callers not awaiting)",
                "Unused variables and imports",
                "Complex nested setTimeout logic",
                "Duplicate watch logic in components",
                "Inconsistent error handling patterns"
            ]
        },
        "solution": {
            "cleanup_steps": {
                "1_remove_debug_logs": "Remove all console.log statements except essential transcript logging",
                "2_fix_async_await": "Make all async methods properly async and ensure all callers await them",
                "3_remove_duplicates": "Consolidate duplicate transcript extraction logic, merge duplicate watch handlers",
                "4_remove_unused": "Remove unused variables (mediaRecorder), unused imports (onMounted)",
                "5_simplify_logic": "Simplify nested setTimeout logic, consolidate conditional logic",
                "6_consistent_error_handling": "Standardize error handling patterns across all composables"
            },
            "async_await_patterns": {
                "watch_callbacks": "Watch callbacks cannot be async - use .then() instead of await",
                "example": "watch(() => assemblyAI.error.value, (error) => { assemblyAI.stop().then(() => { /* continue */ }); });",
                "async_methods": "All stop(), abort(), reset() methods should be async when they call other async methods",
                "proper_awaiting": "Always await async methods: await voiceButtonRef.value.stop()"
            },
            "code_organization": {
                "remove_duplicates": "Consolidate duplicate transcript extraction: extract once, use everywhere",
                "simplify_conditionals": "Combine multiple conditions into single checks where possible",
                "consistent_formatting": "Ensure consistent indentation and code structure",
                "remove_redundant_comments": "Remove obvious comments, keep only meaningful ones"
            }
        },
        "key_lessons": [
            "ALWAYS remove all debug console.log statements after verification (keep only essential logs like transcript output)",
            "ALWAYS make async methods properly async and ensure all callers await them",
            "ALWAYS use .then() instead of await in watch callbacks (watch callbacks cannot be async)",
            "ALWAYS remove duplicate code - consolidate logic into single functions",
            "ALWAYS remove unused variables and imports after refactoring",
            "ALWAYS simplify nested setTimeout logic - use async/await where possible",
            "ALWAYS consolidate duplicate watch handlers into single watch statements",
            "ALWAYS ensure consistent error handling patterns across related composables",
            "ALWAYS clean up code after multiple iterations - code becomes messy over time",
            "ALWAYS verify build passes after cleanup (npm run build)",
            "NEVER leave debug console.log statements in production code",
            "NEVER mix async and sync patterns inconsistently",
            "NEVER duplicate logic that can be consolidated",
            "NEVER leave unused variables or imports",
            "NEVER use await in watch callbacks (use .then() instead)"
        ],
        "code_examples": {
            "async_watch_callback": "watch(() => assemblyAI.error.value, (error) => { assemblyAI.stop().then(() => { activeProvider.value = 'webspeech'; webSpeech.start(); }); });",
            "async_method_definition": "const stop = async (): Promise<void> => { await assemblyAI.stop(); state.value = 'idle'; };",
            "proper_awaiting": "if (voiceButtonRef.value) { await voiceButtonRef.value.stop(); }",
            "consolidated_watch": "watch([transcript, state], ([newTranscript, newState]) => { if (newTranscript && newState === 'processing') { emit('transcript', newTranscript); } });",
            "simplified_transcript_extraction": "const words = data.words || []; let transcriptText = data.transcript || ''; if (!transcriptText && words.length > 0) { transcriptText = words.map((word: any) => word.text || '').filter((text: string) => text.trim()).join(' '); }"
        },
        "cleanup_checklist": [
            "Remove all debug console.log statements",
            "Fix async/await inconsistencies",
            "Remove duplicate code",
            "Remove unused variables and imports",
            "Simplify nested logic",
            "Consolidate duplicate watch handlers",
            "Ensure consistent error handling",
            "Verify build passes",
            "Test functionality still works"
        ],
        "related_files": [
            "resources/js/composables/useVoiceRecognition.ts",
            "resources/js/composables/useAssemblyAITranscription.ts",
            "resources/js/composables/useUnifiedVoiceRecognition.ts",
            "resources/js/components/VoiceSearchButton.vue",
            "resources/js/components/DebitModal.vue"
        ]
    },
    "continuous_voice_recognition_flow": {
        "description": "Implementing continuous voice recognition flow where microphone stays active throughout multi-step interactions",
        "session_date": "2026-01-XX",
        "context": {
            "scenario": "Voice search flow requires microphone to stay active from initial search through form submission (search  amount  confirm  submit)",
            "challenge": "Previous implementation stopped/restarted microphone between steps, causing poor user experience",
            "requirements": [
                "Mic activated once at search start",
                "Mic stays active through: search  user selection  amount entry  confirmation  submission",
                "Mic deactivated only after successful submission and modal closes",
                "AssemblyAI as default provider (WebSocket-based continuous streaming)"
            ]
        },
        "solution": {
            "external_voice_button_ref_pattern": {
                "description": "Pass voice button ref from parent to child components to maintain same WebSocket connection",
                "implementation": "Parent component (Users/Index.vue) keeps searchVoiceButtonRef active, passes to DebitModal via prop",
                "benefits": [
                    "Single WebSocket connection throughout entire flow",
                    "No connection restart overhead",
                    "Better user experience with continuous recognition"
                ]
            },
            "transcript_routing_pattern": {
                "description": "Route transcript events from parent voice button to modal when modal is open",
                "implementation": "Parent checks if modal is open and in voice mode, routes transcript to modal's handleExternalTranscript method",
                "code_example": "if (showCreditModal.value && isVoiceMode.value && debitModalRef.value) { debitModalRef.value.handleExternalTranscript(trimmedTranscript); return; }"
            },
            "remove_timeout_for_continuous_mode": {
                "description": "Remove timeouts from voice recognition to allow truly continuous operation",
                "changes": [
                    "Set timeout default to 0 (no timeout) in useAssemblyAITranscription and useVoiceRecognition",
                    "Remove timeout setting logic in WebSocket connection handler",
                    "Remove timeout logic in speech start/end handlers",
                    "Keep WebSocket connection open indefinitely until explicitly stopped"
                ]
            },
            "step_transitions_without_restart": {
                "description": "Update voiceStep state without stopping/restarting recognition",
                "implementation": "Simply update voiceStep.value from 'amount' to 'confirm' without calling stop()/start()",
                "code_example": "if (voiceStep.value === 'amount') { amount.value = parsedAmount.toString(); setTimeout(() => { voiceStep.value = 'confirm'; }, 1500); }"
            },
            "assemblyai_as_default": {
                "description": "AssemblyAI is the default provider, not Web Speech API",
                "configuration": "Update config/services.php: 'primary' => env('VOICE_RECOGNITION_PRIMARY', 'assemblyai')",
                "advantages": [
                    "WebSocket-based continuous streaming",
                    "Better accuracy and lower latency",
                    "Natural fit for multi-step voice interactions",
                    "No need to restart between steps"
                ]
            },
            "redirect_with_preserve_scroll": {
                "description": "After successful form submission, redirect to users page with scroll preservation",
                "implementation": "router.visit(usersIndex().url, { preserveScroll: true })",
                "benefit": "Maintains user's scroll position when navigating back to users list"
            },
            "responsive_search_input_width": {
                "description": "Search input should be full width on mobile only, fixed width on larger devices",
                "implementation": "Change from flex-1 sm:w-64 to w-full sm:w-64",
                "result": "Mobile: full width, Large devices: fixed 16rem width"
            }
        },
        "key_lessons": [
            "ALWAYS keep microphone active throughout entire multi-step voice flow (search  amount  confirm  submit)",
            "ALWAYS pass voice button ref from parent to child components when maintaining continuous connection",
            "ALWAYS route transcript events from parent to modal when modal is open in voice mode",
            "ALWAYS remove timeouts for continuous voice recognition mode (set timeout to 0)",
            "ALWAYS use AssemblyAI as default provider for voice recognition (WebSocket-based continuous streaming)",
            "ALWAYS update voiceStep state without stopping/restarting recognition between steps",
            "ALWAYS stop microphone only after successful form submission in onSuccess callback",
            "ALWAYS redirect with preserveScroll: true after successful form submissions",
            "ALWAYS use w-full sm:w-64 pattern for responsive search inputs (full width mobile, fixed width desktop)",
            "ALWAYS remove console.log statements for transcript logging in production code",
            "NEVER stop/restart microphone between steps in continuous voice flow",
            "NEVER set timeouts for continuous voice recognition mode",
            "NEVER create new voice recognition sessions in child components when parent already has active session",
            "NEVER redirect without preserveScroll after form submissions (causes scroll position loss)"
        ],
        "code_examples": {
            "external_ref_prop": "interface Props { voiceButtonRef?: InstanceType<typeof VoiceSearchButton> | null; }",
            "transcript_routing": "if (showCreditModal.value && isVoiceMode.value && debitModalRef.value) { debitModalRef.value.handleExternalTranscript(trimmedTranscript); return; }",
            "step_transition": "if (voiceStep.value === 'amount') { amount.value = parsedAmount.toString(); setTimeout(() => { voiceStep.value = 'confirm'; }, 1500); }",
            "no_timeout_config": "timeout: options.timeout ?? 0, // 0 = no timeout (continuous mode)",
            "redirect_preserve_scroll": "router.visit(usersIndex().url, { preserveScroll: true });",
            "responsive_input": "<div class=\"relative w-full sm:w-64\">"
        },
        "related_files": [
            "resources/js/pages/Users/Index.vue",
            "resources/js/components/DebitModal.vue",
            "resources/js/composables/useAssemblyAITranscription.ts",
            "resources/js/composables/useVoiceRecognition.ts",
            "resources/js/composables/useUnifiedVoiceRecognition.ts",
            "config/services.php"
        ]
    },
    "assemblyai_keyterms_implementation": {
        "description": "Implementing AssemblyAI keyterms prompting to boost recognition accuracy for user names",
        "session_date": "2026-01-XX",
        "context": {
            "scenario": "Voice recognition needs to accurately recognize user names from the database",
            "challenge": "AssemblyAI keyterms feature can boost recognition accuracy by up to 21% for domain-specific terms",
            "requirements": [
                "Send keyterms_prompt parameter with user names to AssemblyAI WebSocket connection",
                "Limit to 100 terms (AssemblyAI maximum)",
                "Each term up to 50 characters",
                "Only include usernames (not emails) in keyterms",
                "Filter out empty strings, duplicates, and terms longer than 50 characters"
            ]
        },
        "solution": {
            "keyterms_parameter": {
                "description": "Add keyterms_prompt parameter to AssemblyAI WebSocket connection URL",
                "implementation": "Include keyterms_prompt as JSON array string in URLSearchParams",
                "format": "keyterms_prompt=JSON.stringify(['Name1','Name2',...])",
                "code_example": "connectionParams.append('keyterms_prompt', JSON.stringify(limitedKeyterms));"
            },
            "keyterms_filtering": {
                "description": "Filter and limit keyterms to meet AssemblyAI requirements",
                "steps": [
                    "Slice to 100 terms (AssemblyAI maximum)",
                    "Trim whitespace from each term",
                    "Filter out empty strings",
                    "Filter out terms longer than 50 characters",
                    "Remove duplicates"
                ],
                "code_example": "const limitedKeyterms = config.keyterms.slice(0, 100).map((term) => term.trim()).filter((term) => term.length > 0 && term.length <= 50).filter((term, index, self) => self.indexOf(term) === index);"
            },
            "separate_keyterms_from_grammar": {
                "description": "Create separate computed property for keyterms (usernames only) vs grammar (names + emails)",
                "implementation": "userNamesForKeyterms extracts only user.name, userNamesForGrammar includes both name and email",
                "benefit": "Keyterms should be domain-specific terms (names), grammar can include broader context (emails)"
            },
            "language_detection_disabled": {
                "description": "Disable language detection for better performance when using keyterms",
                "implementation": "Add languageDetection: 'false' to connection parameters",
                "benefit": "Improves performance and accuracy when language is known"
            }
        },
        "key_lessons": [
            "ALWAYS use AssemblyAI keyterms with usernames only (not emails) for better recognition accuracy",
            "ALWAYS limit keyterms to 100 terms (AssemblyAI maximum)",
            "ALWAYS filter keyterms to remove empty strings, duplicates, and terms longer than 50 characters",
            "ALWAYS create separate computed properties for keyterms (names only) vs grammar (names + emails)",
            "ALWAYS disable language detection when using keyterms (languageDetection: 'false')",
            "ALWAYS pass keyterms as JSON array string in keyterms_prompt query parameter",
            "ALWAYS trim and validate keyterms before sending to AssemblyAI",
            "NEVER include emails in keyterms (keyterms should be domain-specific terms like names)",
            "NEVER exceed 100 keyterms (AssemblyAI limit)",
            "NEVER include terms longer than 50 characters in keyterms",
            "NEVER send empty or duplicate keyterms"
        ],
        "code_examples": {
            "keyterms_computed": "const userNamesForKeyterms = computed(() => { return props.users.map((user) => user.name).filter((name) => name && name.trim()).slice(0, 100); });",
            "keyterms_filtering": "const limitedKeyterms = config.keyterms.slice(0, 100).map((term) => term.trim()).filter((term) => term.length > 0 && term.length <= 50).filter((term, index, self) => self.indexOf(term) === index);",
            "keyterms_connection": "connectionParams.append('keyterms_prompt', JSON.stringify(limitedKeyterms));",
            "language_detection": "connectionParams.set('languageDetection', 'false');"
        },
        "assemblyai_limits": {
            "maximum_keyterms": 100,
            "maximum_term_length": 50,
            "cost": "$0.04 per hour",
            "accuracy_improvement": "Up to 21% improvement in recognition accuracy",
            "latency_impact": "No impact on streaming latency"
        },
        "related_files": [
            "resources/js/pages/Users/Index.vue",
            "resources/js/composables/useAssemblyAITranscription.ts",
            "resources/js/composables/useUnifiedVoiceRecognition.ts",
            "resources/js/components/VoiceSearchButton.vue"
        ]
    },
    "context_specific_confirmation_words": {
        "description": "Adding context-specific confirmation words (e.g., 'debit') to all language confirmation word lists",
        "session_date": "2026-01-XX",
        "context": {
            "scenario": "Users should be able to say either 'okay' or 'debit' to confirm form submission in debit modal",
            "challenge": "Only generic confirmation words were supported, not context-specific terms",
            "requirements": [
                "Add 'debit' and translations to all 23 language confirmation word lists",
                "Maintain existing confirmation words (okay, confirm, yes, etc.)",
                "Ensure word boundary matching works correctly"
            ]
        },
        "solution": {
            "multi_language_support": {
                "description": "Add context-specific confirmation words to all supported languages",
                "implementation": "Extend okEquivalents object in voiceUtils.ts with 'debit' and appropriate translations for all 23 languages",
                "languages_updated": [
                    "English: 'debit'",
                    "Spanish: 'dbito'",
                    "Hindi: ''",
                    "Arabic: ''",
                    "German: 'belasten', 'abbuchen'",
                    "French: 'dbit'",
                    "Japanese: ''",
                    "And 16 more languages with appropriate translations"
                ]
            },
            "word_boundary_matching": {
                "description": "isConfirmationWord function uses word boundary regex to match complete words only",
                "implementation": "Uses \\b${word}\\b pattern to ensure 'debit' matches as complete word, not part of other words",
                "benefit": "Prevents false positives (e.g., 'debit' won't match in 'debit card')"
            }
        },
        "key_lessons": [
            "ALWAYS add context-specific confirmation words to all language confirmation word lists",
            "ALWAYS use appropriate translations for context-specific terms (financial/accounting terminology)",
            "ALWAYS maintain word boundary matching to prevent false positives",
            "ALWAYS verify that parseAmountFromText doesn't interfere with confirmation word detection (different steps)",
            "NEVER add confirmation words to only one language (must support all 23 languages)",
            "NEVER forget that confirmation happens in different step than amount parsing (no interference)"
        ],
        "code_examples": {
            "english_addition": "en: ['ok', 'okay', 'confirm', 'yes', 'submit', 'done', 'proceed', 'go', 'debit']",
            "word_boundary": "const regex = new RegExp(`\\b${word}\\b`, 'i'); return regex.test(normalizedText);"
        },
        "related_files": ["resources/js/lib/voiceUtils.ts"]
    },
    "modal_microphone_cleanup": {
        "description": "Ensuring microphone stops when modal closes via any method (cancel button, ESC, click outside)",
        "session_date": "2026-01-XX",
        "context": {
            "scenario": "Microphone should stop when debit modal closes, regardless of how it's closed",
            "challenge": "Previous implementation only stopped internal voice button ref, not external ref from parent",
            "requirements": [
                "Stop microphone when cancel button is clicked",
                "Stop microphone when modal closes via ESC key",
                "Stop microphone when modal closes by clicking outside",
                "Stop both external and internal voice button refs"
            ]
        },
        "solution": {
            "watch_handler_update": {
                "description": "Update watch(isOpen) handler to stop both external and internal voice button refs",
                "implementation": "Check for external ref first, then fall back to internal ref when modal closes",
                "code_example": "if (props.voiceButtonRef) { props.voiceButtonRef.stop(); } else if (internalVoiceButtonRef.value) { internalVoiceButtonRef.value.stop(); }"
            },
            "comprehensive_cleanup": {
                "description": "Modal close triggers watch handler which handles all close scenarios",
                "scenarios_covered": [
                    "Cancel button click (sets isOpen = false)",
                    "ESC key press (Dialog component sets isOpen = false)",
                    "Click outside modal (Dialog component sets isOpen = false)",
                    "Programmatic close (any code setting isOpen = false)"
                ]
            }
        },
        "key_lessons": [
            "ALWAYS stop microphone when modal closes, regardless of close method",
            "ALWAYS check for external voice button ref first, then internal ref",
            "ALWAYS use watch handler on isOpen to handle all close scenarios uniformly",
            "ALWAYS reset voiceStep and processing state when modal closes",
            "NEVER assume only one close method (cancel button) - handle all scenarios",
            "NEVER forget to stop external voice button ref when using parent's mic"
        ],
        "code_examples": {
            "watch_handler": "watch(isOpen, (open) => { if (!open) { if (props.voiceButtonRef) { props.voiceButtonRef.stop(); } else if (internalVoiceButtonRef.value) { internalVoiceButtonRef.value.stop(); } } });"
        },
        "related_files": ["resources/js/components/DebitModal.vue"]
    },
    "assemblyai_audio_quality_optimization": {
        "description": "Optimizing AssemblyAI configuration for best number detection accuracy with lossless audio and optimal model",
        "session_date": "2026-01-XX",
        "context": {
            "scenario": "Improve number detection accuracy in voice recognition",
            "requirements": [
                "Use lossless audio format (PCM 16-bit)",
                "Ensure adequate sample rate (16 kHz)",
                "Use most accurate model (Universal Streaming English)",
                "Match API parameter format (snake_case)"
            ]
        },
        "solution": {
            "explicit_encoding": {
                "description": "Explicitly set encoding to pcm_s16le for lossless audio quality",
                "implementation": "Add encoding: 'pcm_s16le' to connection parameters",
                "benefit": "PCM 16-bit is lossless format, no compression artifacts that could affect number recognition"
            },
            "explicit_speech_model": {
                "description": "Explicitly set speech_model to universal-streaming-english for best accuracy",
                "implementation": "Add speech_model: 'universal-streaming-english' to connection parameters",
                "benefit": "Universal model is optimized for accuracy, better than default model"
            },
            "parameter_format_standardization": {
                "description": "Use snake_case for all AssemblyAI API parameters to match API spec",
                "changes": [
                    "sampleRate  sample_rate",
                    "formatTurns  format_turns",
                    "languageDetection  language_detection",
                    "Added: speech_model, encoding"
                ],
                "benefit": "Matches official API documentation format, ensures compatibility"
            },
            "sample_rate_verification": {
                "description": "Verify 16kHz sample rate meets 16kHz requirement",
                "current_setting": "sample_rate: '16000' (meets requirement)",
                "audio_processing": "AudioContext and MediaStream both configured for 16kHz"
            }
        },
        "key_lessons": [
            "ALWAYS explicitly set speech_model to 'universal-streaming-english' for best accuracy",
            "ALWAYS explicitly set encoding to 'pcm_s16le' for lossless audio quality",
            "ALWAYS use snake_case for AssemblyAI API parameters (matches API spec)",
            "ALWAYS ensure sample rate is 16kHz (16kHz meets requirement)",
            "ALWAYS use PCM 16-bit encoding (lossless, no compression artifacts)",
            "NEVER omit speech_model parameter (explicitly set for best accuracy)",
            "NEVER omit encoding parameter (explicitly set for lossless quality)",
            "NEVER use camelCase for AssemblyAI API parameters (use snake_case to match spec)"
        ],
        "code_examples": {
            "optimal_config": "const connectionParams = new URLSearchParams({ sample_rate: '16000', format_turns: 'true', token: apiKey.value, language_detection: 'false', speech_model: 'universal-streaming-english', encoding: 'pcm_s16le' });",
            "audio_context": "const audioContextInstance = new AudioContext({ sampleRate: 16000 });",
            "pcm_conversion": "const int16Data = new Int16Array(inputData.length); for (let i = 0; i < inputData.length; i++) { const s = Math.max(-1, Math.min(1, inputData[i])); int16Data[i] = s < 0 ? s * 0x8000 : s * 0x7fff; }"
        },
        "audio_quality_benefits": {
            "pcm_16bit": "Lossless format, no compression artifacts, preserves all speech details",
            "16khz_sample_rate": "Meets 16kHz requirement, preserves crucial speech patterns",
            "universal_model": "Optimized for accuracy, better number detection than default model",
            "explicit_config": "Ensures consistent configuration, avoids relying on defaults"
        },
        "related_files": [
            "resources/js/composables/useAssemblyAITranscription.ts"
        ]
    },
    "documentation_and_home_page_updates": {
        "description": "Updating help documentation and home page when adding new features",
        "session_date": "2026-01-03",
        "context": {
            "scenario": "Adding new features (Voice Recognition, Outstanding Balance Column, Beneficiaries Modal) requires updating both help documentation and home page",
            "requirements": [
                "Update help documentation with new feature descriptions",
                "Add FAQ items for new features",
                "Update home page features section with new feature cards",
                "Update structured data (SEO) featureList with new features",
                "Ensure consistent styling and admin-only badges",
                "Fix text overflow issues on mobile"
            ]
        },
        "solution": {
            "help_documentation_updates": {
                "description": "Add new feature sections to help documentation",
                "implementation": [
                    "Add feature description sections in 'Getting Started' section",
                    "Add corresponding FAQ items in 'Frequently Asked Questions' section",
                    "Add translation keys for all new help content",
                    "Mark admin-only features with 'Admin Only' badges",
                    "Verify color references match actual implementation (remove incorrect color mentions)"
                ],
                "pattern": "For each new feature: description section + FAQ item + translation keys"
            },
            "home_page_updates": {
                "description": "Update Welcome.vue with new features",
                "implementation": [
                    "Add new feature cards to features section",
                    "Update structured data featureList array for SEO",
                    "Maintain consistent styling with existing feature cards",
                    "Add admin-only badges where appropriate",
                    "Ensure grid layout accommodates new features (3x3 grid for 9 features)"
                ],
                "pattern": "Feature card + structured data entry + consistent styling"
            },
            "responsive_text_truncation": {
                "description": "Fix text overflow on mobile with responsive truncate classes",
                "implementation": [
                    "For headings in flex containers with badges: use 'min-w-0 flex-1 truncate sm:whitespace-normal'",
                    "For standalone headings: use 'truncate sm:whitespace-normal'",
                    "Allows truncation on mobile, normal wrapping on larger screens"
                ],
                "pattern": "truncate sm:whitespace-normal for mobile-only truncation"
            },
            "color_reference_verification": {
                "description": "Verify color references in documentation match actual implementation",
                "implementation": [
                    "Check actual component styling before documenting colors",
                    "Remove color references that don't exist in implementation",
                    "Update documentation when removing color styling"
                ],
                "example": "Removed 'blue' color mention from Beneficiaries Modal description when implementation only uses underline"
            }
        },
        "key_lessons": [
            "ALWAYS update help documentation when adding new features (description + FAQ)",
            "ALWAYS update home page features section when adding new features",
            "ALWAYS update structured data featureList for SEO when adding features",
            "ALWAYS add translation keys for all new help documentation content",
            "ALWAYS verify color references match actual implementation before documenting",
            "ALWAYS use responsive truncate classes (truncate sm:whitespace-normal) for mobile-only text truncation",
            "ALWAYS use min-w-0 flex-1 truncate for headings in flex containers with badges",
            "ALWAYS maintain consistent styling when adding new feature cards",
            "ALWAYS mark admin-only features with 'Admin Only' badges in documentation",
            "ALWAYS update both visual features section and structured data when adding features",
            "NEVER document colors that don't exist in actual implementation",
            "NEVER forget to update structured data (SEO) when adding features",
            "NEVER use fixed truncate without responsive override (causes issues on larger screens)",
            "NEVER forget to add FAQ items when documenting new features"
        ],
        "code_examples": {
            "responsive_truncate_flex": "<h3 class=\"min-w-0 flex-1 truncate text-xl font-semibold sm:whitespace-normal\">Long Heading Text</h3>",
            "responsive_truncate_standalone": "<h3 class=\"truncate text-xl font-semibold sm:whitespace-normal\">Long Heading Text</h3>",
            "structured_data_update": "featureList: [ 'Feature 1', 'Feature 2', 'New Feature' ]",
            "help_section_pattern": "<div class=\"rounded-lg border...\"><h3>{{ t('new_feature') }}</h3><p>{{ t('new_feature_description') }}</p></div>"
        },
        "documentation_workflow": {
            "step_1": "Add new feature to application",
            "step_2": "Add feature description section to Help.vue",
            "step_3": "Add FAQ item for new feature",
            "step_4": "Add translation keys to lang/en/messages.php",
            "step_5": "Add feature card to Welcome.vue features section",
            "step_6": "Update structured data featureList in Welcome.vue",
            "step_7": "Verify color references match implementation",
            "step_8": "Fix any text overflow issues with responsive truncate"
        },
        "related_files": [
            "resources/js/pages/Help.vue",
            "resources/js/pages/Welcome.vue",
            "lang/en/messages.php"
        ]
    },
    "frontend_formatted_string_parsing": {
        "description": "Parsing formatted strings with commas from backend in frontend code",
        "session_date": "2026-01-03",
        "category": "Frontend Development",
        "context": {
            "scenario": "Backend sends formatted numeric strings with commas (e.g., '6,500.00') to frontend, which need to be parsed and re-formatted for display",
            "problem": "parseFloat() stops at the first non-numeric character, so parseFloat('6,500.00') returns 6 instead of 6500, causing incorrect display (e.g., Rs. 1 instead of correct amount)"
        },
        "problem": {
            "symptom": "Metric values showing incorrect amounts (e.g., Rs. 1 instead of Rs. 6,500.00)",
            "root_cause": "Backend uses number_format() which adds commas (e.g., '6,500.00'), but parseFloat('6,500.00') stops at comma and returns 6",
            "example": "parseFloat('1,234.56') returns 1, which then displays as '1.00' instead of '1,234.56'",
            "location": "formatMetricValue() function in frontend components that display metric values"
        },
        "solution": {
            "fix": "Remove commas from formatted string before parsing: parseFloat(value.replace(/,/g, ''))",
            "implementation": "Update formatMetricValue function to strip commas: const numValue = typeof value === 'string' ? parseFloat(value.replace(/,/g, '')) : value;",
            "benefits": [
                "Correctly parses formatted strings from backend",
                "Preserves decimal values accurately",
                "Allows proper re-formatting for display"
            ]
        },
        "key_lessons": [
            "ALWAYS remove commas from formatted strings before parsing with parseFloat()",
            "ALWAYS use value.replace(/,/g, '') before parseFloat() when backend sends formatted strings",
            "NEVER use parseFloat() directly on comma-formatted strings (stops at first comma)",
            "ALWAYS check if backend sends formatted or unformatted values before parsing"
        ],
        "code_examples": {
            "incorrect": "const numValue = typeof value === 'string' ? parseFloat(value) : value; // parseFloat('6,500.00') returns 6",
            "correct": "const numValue = typeof value === 'string' ? parseFloat(value.replace(/,/g, '')) : value; // parseFloat('6500.00') returns 6500",
            "pattern": "formatMetricValue function: Remove commas  Parse  Format for display"
        },
        "related_files": ["resources/js/pages/Users/Index.vue"]
    },
    "voice_search_multiple_match_handling": {
        "description": "Always show selection modal when multiple users match voice search, never auto-select based on fuzzy match similarity",
        "problem": {
            "scenario": "Voice recognition returns partial names (e.g., 'ashwin') that match multiple users (e.g., 'Ashwin Mohan Ram' and 'Ashwin Ram')",
            "bug": "System auto-selected 'Ashwin Ram' based on fuzzy match similarity >= 0.8, instead of showing selection modal for user to choose",
            "impact": "Incorrect user selection when voice recognition returns partial names that match multiple users"
        },
        "solution": {
            "implementation": [
                "When backend search returns multiple matches (backendMatches.length > 1), always show VoiceUserSelectionModal",
                "Remove fuzzy match auto-selection logic when multiple matches exist",
                "Only auto-select when exactly one user matches (backendMatches.length === 1)",
                "Never use fuzzy match similarity to auto-select when multiple backend matches exist"
            ],
            "code_example": "if (backendMatches.length === 1) { openCreditModal(matchedUser); } else { voiceSearchMatches.value = backendMatches; showVoiceUserSelectionModal.value = true; }",
            "pattern": "Multiple matches  Always show selection modal, Single match  Auto-open modal"
        },
        "key_lessons": [
            "ALWAYS show selection modal when multiple users match voice search query",
            "NEVER auto-select based on fuzzy match similarity when multiple backend matches exist",
            "ALWAYS let user choose when voice recognition returns ambiguous results",
            "ONLY auto-select when exactly one user matches the search query"
        ],
        "testing": {
            "backend_test": "Test that backend returns multiple users when search query matches multiple names",
            "frontend_test": "Test that selection modal is shown when multiple users match, and credit modal opens directly when single user matches",
            "test_example": "Create two users with similar names, search for partial name, verify both users are returned and selection modal is shown"
        },
        "related_files": [
            "resources/js/pages/Users/Index.vue",
            "resources/js/lib/voiceUtils.ts",
            "tests/Feature/UserManagementTest.php",
            "tests/Unit/pages/Users/Index.test.ts"
        ]
    },
    "frontend_testing_watcher_patterns": {
        "description": "Testing patterns for Vue components with watchers and async operations",
        "problem": {
            "scenario": "Testing components that use watchers to react to prop changes and perform async operations",
            "challenge": "Watchers need proper setup (internal state + prop updates) and multiple nextTick() calls for async operations",
            "common_errors": [
                "Watcher not triggering because internal state not set before prop update",
                "Async operations (nextTick) not completing before assertions",
                "Component stubs not accepting props properly causing 'Cannot convert object to primitive value' errors"
            ]
        },
        "solution": {
            "watcher_testing_pattern": {
                "description": "Properly simulate watcher flow in tests",
                "steps": [
                    "1. Mount component with initial props (often empty/initial state)",
                    "2. Set internal state flags (e.g., isWaitingForVoiceSearch = true, pendingVoiceTranscript = 'value')",
                    "3. Wait for initial state with $nextTick()",
                    "4. Update props to trigger watcher (e.g., setProps({ users: newUsers }))",
                    "5. Wait for watcher processing with multiple $nextTick() calls (especially if watcher calls functions with nextTick)",
                    "6. Assert expected state changes"
                ],
                "code_example": "const vm = wrapper.vm; vm.isWaitingForVoiceSearch = true; vm.pendingVoiceTranscript = 'ashwin'; await wrapper.vm.$nextTick(); await wrapper.setProps({ users: multipleMatchUsers }); await wrapper.vm.$nextTick(); await wrapper.vm.$nextTick(); expect(vm.showVoiceUserSelectionModal).toBe(true);"
            },
            "component_stub_patterns": {
                "description": "Component stubs must properly accept props to avoid primitive conversion errors",
                "pattern": "Define stubs with template and props array instead of just 'true'",
                "code_example": "DebitModal: { template: '<div data-testid=\"debit-modal\"></div>', props: ['isOpen', 'user', 'voiceMode', 'voiceButtonRef'] }, VoiceUserSelectionModal: { template: '<div data-testid=\"voice-user-selection-modal\"></div>', props: ['isOpen', 'users'] }",
                "why": "Stubs with just 'true' don't properly handle object props, causing 'Cannot convert object to primitive value' errors when Vue tries to set attributes"
            },
            "async_operation_testing": {
                "description": "Handle async operations (nextTick, watchers) in tests",
                "pattern": "Use multiple $nextTick() calls when testing operations that involve watchers and nextTick()",
                "code_example": "await wrapper.vm.$nextTick(); // Initial state await wrapper.vm.$nextTick(); // Watcher processing await wrapper.vm.$nextTick(); // openCreditModal's nextTick",
                "why": "Vue's reactivity system and nextTick() calls require multiple ticks to fully process watchers and async operations"
            }
        },
        "key_lessons": [
            "ALWAYS set internal state before updating props to trigger watchers in tests",
            "ALWAYS use multiple $nextTick() calls when testing watchers and async operations",
            "ALWAYS define component stubs with template and props array for components that receive object props",
            "ALWAYS start with empty/initial state props, then update to trigger watchers",
            "NEVER use just 'true' for component stubs that receive object props",
            "NEVER assert immediately after prop updates - wait for watcher processing"
        ],
        "testing_patterns": {
            "watcher_flow": "Set internal state  Wait  Update props  Wait multiple ticks  Assert",
            "stub_definition": "ComponentName: { template: '<div></div>', props: ['prop1', 'prop2'] }",
            "async_handling": "Multiple $nextTick() calls for watchers + nextTick() operations"
        },
        "related_files": [
            "tests/Unit/pages/Users/Index.test.ts",
            "resources/js/pages/Users/Index.vue"
        ]
    },
    "language_selector_clear_button_and_configuration": {
        "session": 89,
        "date": "2026-01-06",
        "category": "Frontend Development",
        "title": "LanguageSelector Clear Button and Language Configuration Synchronization",
        "description": "Lessons learned from implementing clear button functionality in LanguageSelector component and ensuring language configuration synchronization between frontend and backend.",
        "problem": {
            "clear_button_visibility": "X button only displayed when query had value, not always visible",
            "clear_button_functionality": "X button not clickable or didn't clear input field properly",
            "language_selection": "New languages (bn, gu, kn, ml, pa, te) couldn't be selected despite being in component",
            "configuration_mismatch": "Frontend component had languages but backend validation rejected them"
        },
        "solution": {
            "clear_button_implementation": {
                "always_visible": "Remove v-if='query' condition - always display X button",
                "clickability": "Add pointer-events-auto and z-10 classes, use @click.stop to prevent event bubbling",
                "input_clearing": "Use document.getElementById() to access input element directly, clear both query ref and input.value",
                "event_sync": "Dispatch input and change events to sync with HeadlessUI Combobox internal state",
                "focus_after_clear": "Call inputElement.focus() after clearing to position cursor in field for immediate typing"
            },
            "language_configuration_sync": {
                "frontend_backend_sync": "New languages must be added to BOTH LanguageSelector.vue component AND config/app.php locales array",
                "backend_validation": "LocaleUpdateRequest validates against config('app.locales'), so missing entries cause validation failure",
                "config_cache": "Clear config cache after adding new languages: php artisan config:clear"
            }
        },
        "key_lessons": [
            "ALWAYS display clear button in searchable inputs (not conditional on query value)",
            "ALWAYS use pointer-events-auto and z-10 for clickable buttons in absolute positioned containers",
            "ALWAYS use @click.stop to prevent event bubbling in HeadlessUI Combobox components",
            "ALWAYS clear both reactive ref (query.value) and DOM element value (inputElement.value)",
            "ALWAYS dispatch input and change events when programmatically clearing HeadlessUI ComboboxInput",
            "ALWAYS focus input field after clearing to improve UX (cursor positioned for immediate typing)",
            "ALWAYS use document.getElementById() for reliable input access in HeadlessUI components (refs may not work)",
            "ALWAYS add new languages to BOTH frontend component AND config/app.php locales array",
            "ALWAYS clear config cache after updating language configuration",
            "ALWAYS verify language selection works after adding new languages (test both frontend display and backend validation)"
        ],
        "code_examples": {
            "clear_button_template": "<button type='button' @click.stop='clearSearch' class='pointer-events-auto z-10' data-testid='clear-search-button'><X class='h-4 w-4' /></button>",
            "clear_search_function": "const clearSearch = (event?: Event) => { if (event) { event.stopPropagation(); event.preventDefault(); } query.value = ''; const inputElement = document.getElementById('language-selector') as HTMLInputElement; if (inputElement) { inputElement.value = ''; inputElement.dispatchEvent(new Event('input', { bubbles: true })); inputElement.dispatchEvent(new Event('change', { bubbles: true })); inputElement.focus(); } };",
            "language_config_sync": "// Frontend: resources/js/components/LanguageSelector.vue\n{ code: 'ml', label: '', englishName: 'Malayalam' },\n\n// Backend: config/app.php\n'locales' => [\n    'ml' => '',\n    // ... other languages\n]"
        },
        "testing_patterns": {
            "clear_button_visibility": "Test that X button always exists and is visible",
            "clear_functionality": "Test that clicking X clears query ref and input value",
            "focus_behavior": "Test that input is focused after clearing (optional - may require browser testing)",
            "language_selection": "Test that all languages in component can be selected (backend validation)"
        },
        "related_files": [
            "resources/js/components/LanguageSelector.vue",
            "tests/Unit/components/LanguageSelector.test.ts",
            "config/app.php",
            "app/Http/Requests/Settings/LocaleUpdateRequest.php"
        ]
    },
    "voice_recognition_confirmation_words_and_model_selection": {
        "session": 90,
        "date": "2026-01-XX",
        "category": "Voice Recognition & User Experience",
        "title": "Voice Recognition Confirmation Words and AssemblyAI Model Selection",
        "description": "Lessons learned from implementing voice confirmation commands in debit modal and selecting appropriate AssemblyAI model for voice recognition.",
        "problem": {
            "scenario": "Voice recognition confirmation words need to work reliably across all languages, and multilingual model was causing issues",
            "challenges": [
                "Confirmation words translated to multiple languages were not being recognized well by voice API",
                "Multilingual model (universal-streaming-multilingual) was not working as expected",
                "Red confirmation text was displaying in user's language but API couldn't recognize translated words",
                "Users expected to say button labels (debit, cancel) but translations were confusing"
            ]
        },
        "solution": {
            "model_selection": {
                "description": "Use universal-streaming-english model instead of multilingual",
                "rationale": "English-only model provides better accuracy for English words, and voice commands should match button labels",
                "configuration": "Set speech_model to 'universal-streaming-english' in AssemblyAI connection parameters",
                "code_example": "speech_model: 'universal-streaming-english' // Not 'universal-streaming-multilingual'"
            },
            "confirmation_words": {
                "description": "Use only English words that match button labels",
                "rationale": "Voice commands should match what users see on buttons (debit, cancel) for consistency and better recognition",
                "grammar_hints": "Only include English words in grammar hints: ['debit', 'cancel']",
                "matching_logic": "Use case-insensitive partial matching for better recognition accuracy"
            },
            "ui_text_removal": {
                "description": "Remove all confirmation text from UI",
                "rationale": "No need to show confirmation instructions - users can see buttons and speak button labels",
                "removal": "Remove all v-if conditions that display confirmation text (voice_search_speak_confirm)"
            }
        },
        "key_lessons": [
            "ALWAYS use universal-streaming-english model for voice recognition (not multilingual)",
            "ALWAYS use only English words in grammar hints that match button labels (debit, cancel)",
            "NEVER translate voice command words - they should match button text exactly",
            "ALWAYS remove confirmation instruction text from UI (users can see buttons)",
            "ALWAYS use case-insensitive partial matching for voice command recognition",
            "ALWAYS pass grammar hints to voice recognition API for better accuracy",
            "NEVER use multilingual model when voice commands are English-only",
            "NEVER add translated confirmation words to grammar hints",
            "ALWAYS ensure voice commands match button labels for consistency"
        ],
        "code_examples": {
            "assemblyai_config": "const connectionParams = new URLSearchParams({\n    sample_rate: '16000',\n    format_turns: 'true',\n    token: apiKey.value,\n    language_detection: 'false',\n    speech_model: 'universal-streaming-english', // English-only model\n    encoding: 'pcm_s16le',\n});",
            "grammar_hints": "const confirmationGrammarHints = computed(() => {\n    if (voiceStep.value !== 'confirm') {\n        return [];\n    }\n    // Only English words matching button labels\n    return ['debit', 'cancel'];\n});",
            "command_matching": "const normalizedTranscript = trimmedTranscript.toLowerCase();\nif (normalizedTranscript === 'debit' || normalizedTranscript.includes('debit')) {\n    handleSubmit();\n} else if (normalizedTranscript === 'cancel' || normalizedTranscript.includes('cancel')) {\n    closeModal();\n}"
        },
        "testing_patterns": {
            "command_recognition": "Test that 'debit' and 'cancel' are recognized correctly",
            "case_insensitive": "Test that 'Debit', 'DEBIT', 'debit' all work",
            "partial_matching": "Test that 'debit transaction' or 'cancel this' are recognized",
            "ui_text_absence": "Test that no confirmation text is displayed in UI"
        },
        "related_files": [
            "resources/js/components/DebitModal.vue",
            "resources/js/composables/useAssemblyAITranscription.ts",
            "resources/js/lib/voiceUtils.ts"
        ]
    }
}
