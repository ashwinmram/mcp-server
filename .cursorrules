# Laravel Package Development - Testing & Configuration Lessons

## Config Files in Packages

When creating Laravel package configuration files:
- Use `env()` directly, not `config()` helper inside config files
- Example: `'server_url' => env('MCP_SERVER_URL')` instead of `'server_url' => config('services.mcp.server_url', env('MCP_SERVER_URL'))`
- The `config()` helper cannot reference other config values during config file merging and causes binding resolution errors
- Service classes should handle fallback logic using the null coalescing operator: `config('package.key') ?? config('services.fallback.key')`

## Service Provider Testing

When testing Laravel service providers:
- Avoid manually instantiating service providers with `new ServiceProvider(app())` in unit tests
- Manual instantiation causes issues with `mergeConfigFrom()` which requires fully bootstrapped application context
- Instead, rely on Laravel's package discovery mechanism (configured via `composer.json` `extra.laravel.providers`)
- Tests should verify commands exist in `Artisan::all()` and config values are accessible, rather than manually instantiating

## Exception Messages

- Keep exception messages concise and match test expectations exactly
- Detailed error information can be added to documentation or logging, but exception messages should be focused
- Consistency between exception messages and test assertions is critical for maintainability

## HTTP Fake Setup in Tests

When setting up HTTP fake in Pest tests with `beforeEach`:
- Ensure config values are properly reset between tests
- Explicitly set package config to null (e.g., `Config::set('package.key', null)`) so services can properly fallback
- This ensures tests accurately reflect fallback behavior without config persistence between tests

## Code Formatting

- Always run Laravel Pint (`vendor/bin/pint --dirty`) before finalizing changes
- Pint automatically fixes formatting issues like `new_with_parentheses`, `no_superfluous_phpdoc_tags`, and other Laravel style rules
- This ensures consistency with Laravel conventions and project code standards

## Packagist Publication

When preparing a Laravel package for Packagist publication:
- Create a separate git repository in the package directory (not the parent monorepo)
- Initialize git with `git init`, commit all package files, create an initial version tag (e.g., `v1.0.0`), and push to GitHub
- Package `composer.json` should include: proper name (vendor/package), description, keywords array, license, authors with name and email
- Set `minimum-stability` to `stable` (not `dev`) in package composer.json
- Remove any `version` field from composer.json as Composer will parse versions from git tags automatically
- Before publishing, update the main project's composer.json to remove the local path repository and change the package requirement from `@dev` to a version constraint like `^1.0`

## GitHub Webhook for Packagist Auto-Updates

To enable automatic Packagist updates when pushing new tags:
- Configure GitHub webhook URL as: `https://packagist.org/api/github?username=PACKAGIST_USERNAME`
- The webhook secret must be your Packagist API token (found on your Packagist profile page)
- Set content type to `application/json` and events to `push`
- When bumping package versions, create annotated tags with `git tag -a v1.0.1 -m 'Release v1.0.1'` and push with `git push origin v1.0.1`
- Use semantic versioning (MAJOR.MINOR.PATCH) for all version tags
- Packagist will automatically detect new tags and make them available for installation via Composer
