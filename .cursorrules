# Laravel Package Development - Testing & Configuration Lessons

## Config Files in Packages

When creating Laravel package configuration files:
- Use `env()` directly, not `config()` helper inside config files
- Example: `'server_url' => env('MCP_SERVER_URL')` instead of `'server_url' => config('services.mcp.server_url', env('MCP_SERVER_URL'))`
- The `config()` helper cannot reference other config values during config file merging and causes binding resolution errors
- Service classes should handle fallback logic using the null coalescing operator: `config('package.key') ?? config('services.fallback.key')`

## Service Provider Testing

When testing Laravel service providers:
- Avoid manually instantiating service providers with `new ServiceProvider(app())` in unit tests
- Manual instantiation causes issues with `mergeConfigFrom()` which requires fully bootstrapped application context
- Instead, rely on Laravel's package discovery mechanism (configured via `composer.json` `extra.laravel.providers`)
- Tests should verify commands exist in `Artisan::all()` and config values are accessible, rather than manually instantiating

## Exception Messages

- Keep exception messages concise and match test expectations exactly
- Detailed error information can be added to documentation or logging, but exception messages should be focused
- Consistency between exception messages and test assertions is critical for maintainability

## HTTP Fake Setup in Tests

When setting up HTTP fake in Pest tests with `beforeEach`:
- Ensure config values are properly reset between tests
- Explicitly set package config to null (e.g., `Config::set('package.key', null)`) so services can properly fallback
- This ensures tests accurately reflect fallback behavior without config persistence between tests

## Code Formatting

- Always run Laravel Pint (`vendor/bin/pint --dirty`) before finalizing changes
- Pint automatically fixes formatting issues like `new_with_parentheses`, `no_superfluous_phpdoc_tags`, and other Laravel style rules
- This ensures consistency with Laravel conventions and project code standards
